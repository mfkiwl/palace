diff --git a/CHANGELOG b/CHANGELOG
index b68e7b053..358f5490d 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -54,7 +54,7 @@ Meshing improvements
 - Added support for free connectivity of NURBS patches allowing for more complex
   patch configurations such as C-meshes. This is demonstrated in a new NURBS
   miniapp.
-  
+
 - The edge to knot map for NURBS meshes can be determined automatically. It is no
   longer needed to specify this in the NURBS mesh. A mesh in the NURBS miniapp
   demonstrates this.
@@ -83,6 +83,12 @@ Discretization improvements
 - Support for parallel transfer of H1 fields using the low-order refined (LOR)
   transfer operators in L2ProjectionGridTransfer
 
+- Introduced support for higher order non conformal Nedelec elements on
+  simplices in ParMesh.
+
+- Introduced support for internal boundary elements in nonconformal adapted
+  meshes.
+
 Linear and nonlinear solvers
 ----------------------------
 - Updated interface to MUMPS direct solver to support multiple right-hand
diff --git a/data/p1_prism.msh b/data/p1_prism.msh
new file mode 100644
index 000000000..b05d1470c
--- /dev/null
+++ b/data/p1_prism.msh
@@ -0,0 +1,53 @@
+$MeshFormat
+2.2 0 8
+$EndMeshFormat
+$PhysicalNames
+2
+2 2 "boundaries"
+3 1 "cylinder"
+$EndPhysicalNames
+$Nodes
+15
+1 2.74 0 0
+2 2.74 0 5.48
+3 -7.133049998451843e-15 2.74 0
+4 -2.74 -3.31486008200114e-15 0
+5 4.363887905507124e-15 -2.74 0
+6 2.74 0 2.74
+7 -7.133049998451843e-15 2.74 5.48
+8 -2.74 -3.31486008200114e-15 5.48
+9 4.363887905507124e-15 -2.74 5.48
+10 -5.920473312798202e-16 -4.967313603494313e-16 0
+11 -7.133049998451843e-15 2.74 2.74
+12 -2.74 -3.31486008200114e-15 2.74
+13 4.363887905507124e-15 -2.74 2.74
+14 -5.920473312798202e-16 -4.967313603494313e-16 5.48
+15 -5.920473312798202e-16 -4.967313603494313e-16 2.74
+$EndNodes
+$Elements
+24
+1 2 2 2 1 3 10 1
+2 2 2 2 1 5 10 4
+3 2 2 2 1 4 10 3
+4 2 2 2 1 1 10 5
+5 2 2 2 3 7 14 2
+6 2 2 2 3 9 14 8
+7 2 2 2 3 8 14 7
+8 2 2 2 3 2 14 9
+9 3 2 2 2 1 3 11 6
+10 3 2 2 2 6 11 7 2
+11 3 2 2 2 3 4 12 11
+12 3 2 2 2 11 12 8 7
+13 3 2 2 2 4 5 13 12
+14 3 2 2 2 12 13 9 8
+15 3 2 2 2 5 1 6 13
+16 3 2 2 2 13 6 2 9
+17 6 2 1 1 1 3 10 6 11 15
+18 6 2 1 1 6 11 15 2 7 14
+19 6 2 1 1 4 5 10 12 13 15
+20 6 2 1 1 12 13 15 8 9 14
+21 6 2 1 1 3 4 10 11 12 15
+22 6 2 1 1 11 12 15 7 8 14
+23 6 2 1 1 5 1 10 13 6 15
+24 6 2 1 1 13 6 15 9 2 14
+$EndElements
diff --git a/data/p2_prism.msh b/data/p2_prism.msh
new file mode 100644
index 000000000..0cb3f66d6
--- /dev/null
+++ b/data/p2_prism.msh
@@ -0,0 +1,103 @@
+$MeshFormat
+2.2 0 8
+$EndMeshFormat
+$PhysicalNames
+2
+2 2 "boundaries"
+3 1 "cylinder"
+$EndPhysicalNames
+$Nodes
+65
+1 2.74 0 0
+2 2.74 0 5.48
+3 -7.133049998451843e-15 2.74 0
+4 -2.74 -3.31486008200114e-15 0
+5 4.363887905507124e-15 -2.74 0
+6 1.937472580451138 1.937472580451143 0
+7 -1.937472580451143 1.937472580451137 0
+8 -1.937472580451138 -1.937472580451143 0
+9 1.937472580451142 -1.937472580451139 0
+10 2.74 0 2.74
+11 2.74 0 1.37
+12 2.74 0 4.11
+13 -7.133049998451843e-15 2.74 5.48
+14 -2.74 -3.31486008200114e-15 5.48
+15 4.363887905507124e-15 -2.74 5.48
+16 1.937472580451138 1.937472580451143 5.48
+17 -1.937472580451143 1.937472580451137 5.48
+18 -1.937472580451138 -1.937472580451143 5.48
+19 1.937472580451142 -1.937472580451139 5.48
+20 -5.920473312798202e-16 -4.967313603494313e-16 0
+21 -3.862548664865832e-15 1.37 0
+22 1.37 -2.483656801747156e-16 0
+23 1.885920287113652e-15 -1.37 0
+24 -1.370000000000001 -1.905795721175286e-15 0
+25 -7.133049998451843e-15 2.74 2.74
+26 -2.74 -3.31486008200114e-15 2.74
+27 4.363887905507124e-15 -2.74 2.74
+28 1.677766114831874e-16 2.74 1.37
+29 1.937472580451138 1.937472580451143 2.74
+30 1.937472580451141 1.937472580451143 1.37
+31 1.677766114831874e-16 2.74 4.11
+32 1.937472580451141 1.937472580451143 4.11
+33 -2.74 3.355532229663748e-16 1.37
+34 -1.937472580451143 1.937472580451137 2.74
+35 -1.93747258045114 1.937472580451139 1.37
+36 -2.74 3.355532229663748e-16 4.11
+37 -1.93747258045114 1.937472580451139 4.11
+38 -5.033298344495622e-16 -2.74 1.37
+39 -1.937472580451138 -1.937472580451143 2.74
+40 -1.937472580451141 -1.937472580451141 1.37
+41 -5.033298344495622e-16 -2.74 4.11
+42 -1.937472580451141 -1.937472580451141 4.11
+43 1.937472580451142 -1.937472580451139 2.74
+44 1.937472580451139 -1.937472580451139 1.37
+45 1.937472580451139 -1.937472580451139 4.11
+46 -5.920473312798202e-16 -4.967313603494313e-16 5.48
+47 -3.862548664865832e-15 1.37 5.48
+48 1.37 -2.483656801747157e-16 5.48
+49 1.885920287113652e-15 -1.37 5.48
+50 -1.370000000000001 -1.905795721175286e-15 5.48
+51 -5.920473312798202e-16 -4.967313603494313e-16 2.74
+52 -5.920473312798202e-16 -4.967313603494313e-16 1.37
+53 1.37 -2.483656801747157e-16 2.74
+54 -3.862548664865832e-15 1.37 2.74
+55 1.37 -2.483656801747157e-16 1.37
+56 -2.121353598983164e-16 1.37 1.37
+57 -5.920473312798202e-16 -4.967313603494313e-16 4.11
+58 1.37 -2.483656801747157e-16 4.11
+59 -2.121353598983164e-16 1.37 4.11
+60 -1.37 -1.905795721175286e-15 2.74
+61 1.885920287113652e-15 -1.37 2.74
+62 -1.37 -8.058906869152782e-17 1.37
+63 -5.476885828646913e-16 -1.37 1.37
+64 -1.37 -8.058906869152802e-17 4.11
+65 -5.476885828646913e-16 -1.37 4.11
+$EndNodes
+$Elements
+24
+1 9 2 2 1 3 20 1 21 22 6
+2 9 2 2 1 5 20 4 23 24 8
+3 9 2 2 1 4 20 3 24 21 7
+4 9 2 2 1 1 20 5 22 23 9
+5 9 2 2 3 13 46 2 47 48 16
+6 9 2 2 3 15 46 14 49 50 18
+7 9 2 2 3 14 46 13 50 47 17
+8 9 2 2 3 2 46 15 48 49 19
+9 10 2 2 2 1 3 25 10 6 28 29 11 30
+10 10 2 2 2 10 25 13 2 29 31 16 12 32
+11 10 2 2 2 3 4 26 25 7 33 34 28 35
+12 10 2 2 2 25 26 14 13 34 36 17 31 37
+13 10 2 2 2 4 5 27 26 8 38 39 33 40
+14 10 2 2 2 26 27 15 14 39 41 18 36 42
+15 10 2 2 2 5 1 10 27 9 11 43 38 44
+16 10 2 2 2 27 10 2 15 43 12 19 41 45
+17 13 2 1 1 1 3 20 10 25 51 6 22 11 21 28 52 29 53 54 30 55 56
+18 13 2 1 1 10 25 51 2 13 46 29 53 12 54 31 57 16 48 47 32 58 59
+19 13 2 1 1 4 5 20 26 27 51 8 24 33 23 38 52 39 60 61 40 62 63
+20 13 2 1 1 26 27 51 14 15 46 39 60 36 61 41 57 18 50 49 42 64 65
+21 13 2 1 1 3 4 20 25 26 51 7 21 28 24 33 52 34 54 60 35 56 62
+22 13 2 1 1 25 26 51 13 14 46 34 54 31 60 36 57 17 47 50 37 59 64
+23 13 2 1 1 5 1 20 27 10 51 9 23 38 22 11 52 43 61 53 44 63 55
+24 13 2 1 1 27 10 51 15 2 46 43 61 41 53 12 57 19 49 48 45 65 58
+$EndElements
diff --git a/examples/ex13p.cpp b/examples/ex13p.cpp
index da3a7cdba..af3cbc696 100644
--- a/examples/ex13p.cpp
+++ b/examples/ex13p.cpp
@@ -54,6 +54,7 @@ int main(int argc, char *argv[])
    int par_ref_levels = 1;
    int order = 1;
    int nev = 5;
+   bool nc = false;
    bool visualization = 1;
    const char *device_config = "cpu";
 
@@ -69,6 +70,9 @@ int main(int argc, char *argv[])
                   " isoparametric space.");
    args.AddOption(&nev, "-n", "--num-eigs",
                   "Number of desired eigenmodes.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-c",
+                  "--conforming",
+                  "Mark the mesh as nonconforming before partitioning.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -107,6 +111,11 @@ int main(int argc, char *argv[])
       mesh->UniformRefinement();
    }
 
+   if (nc)
+   {
+      mesh->EnsureNCMesh(true);
+   }
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution (1 time by
    //    default, or specified on the command line with -rp). Once the parallel
diff --git a/examples/ex3.cpp b/examples/ex3.cpp
index edbfdac7d..d36ec62bf 100644
--- a/examples/ex3.cpp
+++ b/examples/ex3.cpp
@@ -63,6 +63,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = 1;
 
@@ -77,6 +78,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -103,19 +106,26 @@ int main(int argc, char *argv[])
    dim = mesh->Dimension();
    int sdim = mesh->SpaceDimension();
 
+
    // 4. Refine the mesh to increase the resolution. In this example we do
    //    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
    //    largest number that gives a final mesh with no more than 50,000
    //    elements.
+
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+   mesh->UniformRefinement();
    {
       int ref_levels =
-         (int)floor(log(50000./mesh->GetNE())/log(2.)/dim);
+         (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
       {
          mesh->UniformRefinement();
       }
    }
-
    // 5. Define a finite element space on the mesh. Here we use the Nedelec
    //    finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/examples/ex3p.cpp b/examples/ex3p.cpp
index e24c52809..285fcc8e8 100644
--- a/examples/ex3p.cpp
+++ b/examples/ex3p.cpp
@@ -70,6 +70,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = true;
 #ifdef MFEM_USE_AMGX
@@ -87,6 +88,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -129,6 +132,12 @@ int main(int argc, char *argv[])
    //    this example we do 'ref_levels' of uniform refinement. We choose
    //    'ref_levels' to be the largest number that gives a final mesh with no
    //    more than 1,000 elements.
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+
    {
       int ref_levels = (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
@@ -137,19 +146,20 @@ int main(int argc, char *argv[])
       }
    }
 
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution. Once the
    //    parallel mesh is defined, the serial mesh can be deleted.
    ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);
+
    delete mesh;
    {
-      int par_ref_levels = 2;
+      int par_ref_levels = 1;
       for (int l = 0; l < par_ref_levels; l++)
       {
          pmesh->UniformRefinement();
       }
    }
-
    // 7. Define a parallel finite element space on the parallel mesh. Here we
    //    use the Nedelec finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index b0bf84145..7d36985de 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -488,6 +488,7 @@ int IsoparametricTransformation::OrderGrad(const FiniteElement *fe) const
 void IsoparametricTransformation::Transform (const IntegrationPoint &ip,
                                              Vector &trans)
 {
+   MFEM_ASSERT(FElem != nullptr, "!");
    shape.SetSize(FElem->GetDof());
    trans.SetSize(PointMat.Height());
 
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index c898d4983..4d97a5929 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -492,13 +492,12 @@ void FiniteElementSpace::BuildDofToArrays()
    }
 }
 
-static void mark_dofs(const Array<int> &dofs, Array<int> &mark_array)
+void
+FiniteElementSpace::MarkDofs(const Array<int> &dofs, Array<int> &mark_array)
 {
-   for (int i = 0; i < dofs.Size(); i++)
+   for (auto d : dofs)
    {
-      int k = dofs[i];
-      if (k < 0) { k = -1 - k; }
-      mark_array[k] = -1;
+      mark_array[d >= 0 ? d : -1 - d] = -1;
    }
 }
 
@@ -506,7 +505,7 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
                                            Array<int> &ess_vdofs,
                                            int component) const
 {
-   Array<int> vdofs, dofs;
+   Array<int> dofs;
 
    ess_vdofs.SetSize(GetVSize());
    ess_vdofs = 0;
@@ -515,19 +514,49 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
    {
       if (bdr_attr_is_ess[GetBdrAttribute(i)-1])
       {
-         if (component < 0)
+         int ncface = -1;
+         if (Nonconforming())
+         {
+            // Need to take care on internal non-conforming "boundaries". Boundary
+            // elements are conforming or slave. The only exception to this
+            // being "ghost boundary elements" which are master faces
+            int f = mesh->GetBdrElementEdgeIndex(i);
+            int inf1, inf2;
+            mesh->GetFaceInfos(f, &inf1, &inf2, &ncface);
+         }
+
+         if (ncface >= 0)
+         {
+            auto face_index = mesh->GetNCMasterFaceIndex(ncface);
+            int inf1, inf2;
+            mesh->GetFaceInfos(face_index, &inf1, &inf2, &ncface);
+            if (face_index >= mesh->GetNumFaces() && ncface < 0)
+            {
+               // Ghost master face, do not process on this rank
+               continue;
+            }
+            else if (component < 0)
+            {
+               GetEntityVDofs(mesh->Dimension() - 1, face_index, dofs);
+            }
+            else
+            {
+               GetEntityDofs(mesh->Dimension() - 1, face_index, dofs);
+               for (auto &d : dofs) { d = DofToVDof(d, component); }
+            }
+         }
+         else if (component < 0)
          {
             // Mark all components.
-            GetBdrElementVDofs(i, vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetBdrElementVDofs(i, dofs);
          }
          else
          {
             GetBdrElementDofs(i, dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 
@@ -542,31 +571,27 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
       {
          if (component < 0)
          {
-            GetVertexVDofs(bdr_verts[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetVertexVDofs(bdr_verts[i], dofs);
          }
          else
          {
             GetVertexDofs(bdr_verts[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
       for (int i = 0; i < bdr_edges.Size(); i++)
       {
          if (component < 0)
          {
-            GetEdgeVDofs(bdr_edges[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetEdgeVDofs(bdr_edges[i], dofs);
          }
          else
          {
             GetEdgeDofs(bdr_edges[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 }
@@ -585,6 +610,19 @@ void FiniteElementSpace::GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
    else
    {
       R->BooleanMult(ess_vdofs, ess_tdofs);
+#ifdef MFEM_DEBUG
+      // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs
+      Array<int> ess_tdofs2(ess_tdofs.Size());
+      GetConformingProlongation()->BooleanMultTranspose(ess_vdofs, ess_tdofs2);
+
+      int counter = 0;
+      for (int i = 0; i < ess_tdofs2.Size(); ++i)
+      {
+         if (bool(ess_tdofs[i]) != bool(ess_tdofs2[i])) { ++counter; }
+      }
+
+      MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter);
+#endif
    }
    MarkerToList(ess_tdofs, ess_tdof_list);
 }
@@ -933,6 +971,15 @@ int FiniteElementSpace::GetEntityDofs(int entity, int index, Array<int> &dofs,
    }
 }
 
+int FiniteElementSpace::GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                                       Geometry::Type master_geom,
+                                       int variant) const
+{
+   int n = GetEntityDofs(entity, index, dofs, master_geom, variant);
+   DofsToVDofs(dofs);
+   return n;
+}
+
 void FiniteElementSpace::BuildConformingInterpolation() const
 {
 #ifdef MFEM_USE_MPI
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 9afa756f5..5db18dece 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -382,6 +382,10 @@ protected:
    int GetEntityDofs(int entity, int index, Array<int> &dofs,
                      Geometry::Type master_geom = Geometry::INVALID,
                      int variant = 0) const;
+   /// Helper to get vertex, edge or face VDOFs (entity=0,1,2 resp.).
+   int GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                      Geometry::Type master_geom = Geometry::INVALID,
+                      int variant = 0) const;
 
    // Get degenerate face DOFs: see explanation in method implementation.
    int GetDegenerateFaceDofs(int index, Array<int> &dofs,
@@ -822,6 +826,7 @@ public:
    /// @brief Returns the indices of the degrees of freedom for the specified
    /// face, including the DOFs for the edges and the vertices of the face.
    ///
+   ///
    /// In variable order spaces, multiple variants of DOFs can be returned.
    /// See GetEdgeDofs() for more details.
    /// @return Order of the selected variant, or -1 if there are no more
@@ -1164,6 +1169,15 @@ public:
    static void ListToMarker(const Array<int> &list, int marker_size,
                             Array<int> &marker, int mark_val = -1);
 
+   /**
+    * @brief Helper for looping over entries in mark_array, and setting equal
+    * to -1 if present in dofs. Used in GetEssentialVDofs.
+    *
+    * @param[in] dofs The set of dofs to mark
+    * @param[out] mark_array Array of dofs to mark, indices with
+    */
+   static void MarkDofs(const Array<int> &dofs, Array<int> &mark_array);
+
    /** @brief For a partially conforming FE space, convert a marker array (nonzero
        entries are true) on the partially conforming dofs to a marker array on
        the conforming dofs. A conforming dofs is marked iff at least one of its
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index cb58b6033..fc55af976 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -836,6 +836,9 @@ double GridFunction::GetValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -975,6 +978,9 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -999,6 +1005,8 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
          FaceElementTransformations * FET =
             dynamic_cast<FaceElementTransformations *>(&T);
 
+         MFEM_ASSERT(FET != nullptr,
+                     "FaceElementTransformation must be valid for a boundary element");
          // Evaluate in neighboring element for both continuous and
          // discontinuous fields (the integration point in T1 should have
          // already been set).
@@ -1116,11 +1124,10 @@ int GridFunction::GetFaceVectorValues(
    int i, int side, const IntegrationRule &ir,
    DenseMatrix &vals, DenseMatrix &tr) const
 {
-   int n, di;
+   int di;
    FaceElementTransformations *Transf;
 
-   n = ir.GetNPoints();
-   IntegrationRule eir(n);  // ---
+   IntegrationRule eir(ir.GetNPoints());  // ---
    Transf = fes->GetMesh()->GetFaceElementTransformations(i, 0);
    if (side == 2)
    {
@@ -1142,12 +1149,14 @@ int GridFunction::GetFaceVectorValues(
    if (di == 0)
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 5);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc1.Transform(ir, eir);
       GetVectorValues(*Transf->Elem1, eir, vals, &tr);
    }
    else
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 10);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc2.Transform(ir, eir);
       GetVectorValues(*Transf->Elem2, eir, vals, &tr);
    }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index fb0c7cf9f..107b1e2d2 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -90,18 +90,18 @@ ParNURBSExtension *ParFiniteElementSpace::MakeLocalNURBSext(
 void ParFiniteElementSpace::ParInit(ParMesh *pm)
 {
    pmesh = pm;
-   pncmesh = NULL;
+   pncmesh = nullptr;
 
    MyComm = pmesh->GetComm();
    NRanks = pmesh->GetNRanks();
    MyRank = pmesh->GetMyRank();
 
-   gcomm = NULL;
+   gcomm = nullptr;
 
-   P = NULL;
-   Pconf = NULL;
+   P = nullptr;
+   Pconf = nullptr;
    nonconf_P = false;
-   R = NULL;
+   R = nullptr;
 
    num_face_nbr_dofs = -1;
 
@@ -532,12 +532,14 @@ ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs) const
 int ParFiniteElementSpace::GetFaceDofs(int i, Array<int> &dofs,
                                        int variant) const
 {
-   if (face_dof && variant == 0)
+   if (face_dof != nullptr && variant == 0)
    {
       face_dof->GetRow(i, dofs);
       return fec->GetOrder();
    }
+
    int p = FiniteElementSpace::GetFaceDofs(i, dofs, variant);
+
    if (Conforming())
    {
       ApplyLDofSigns(dofs);
@@ -1062,6 +1064,38 @@ void ParFiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
 {
    FiniteElementSpace::GetEssentialVDofs(bdr_attr_is_ess, ess_dofs, component);
 
+   if (mesh->Nonconforming())
+   {
+      // In a nonconforming mesh, there can be internal boundary elements that
+      // can only be marked from ghost child faces. These are constructed during the
+      // ExchangeFaceNbrData phase
+
+      Array<int> dofs;
+      for (const auto &kv : pncmesh->GetGhostBoundaryElements())
+      {
+         if (bdr_attr_is_ess[kv.first - 1])
+         {
+            if (component < 0)
+            {
+               for (auto f : kv.second)
+               {
+                  GetEntityVDofs(mesh->Dimension() - 1, f, dofs);
+                  MarkDofs(dofs, ess_dofs);
+               }
+            }
+            else
+            {
+               for (auto f : kv.second)
+               {
+                  GetEntityDofs(mesh->Dimension() - 1, f, dofs);
+                  for (auto &d : dofs) { d = DofToVDof(d, component); }
+                  MarkDofs(dofs, ess_dofs);
+               }
+            }
+         }
+      }
+   }
+
    // Make sure that processors without boundary elements mark
    // their boundary dofs (if they have any).
    Synchronize(ess_dofs);
@@ -1080,18 +1114,28 @@ void ParFiniteElementSpace::GetEssentialTrueDofs(const Array<int>
 #ifdef MFEM_DEBUG
    // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs.
    Array<int> true_ess_dofs2(true_ess_dofs.Size());
-   HypreParMatrix *Pt = Dof_TrueDof_Matrix()->Transpose();
+   auto Pt = std::unique_ptr<HypreParMatrix>(Dof_TrueDof_Matrix()->Transpose());
+
    const int *ess_dofs_data = ess_dofs.HostRead();
    Pt->BooleanMult(1, ess_dofs_data, 0, true_ess_dofs2);
-   delete Pt;
    int counter = 0;
    const int *ted = true_ess_dofs.HostRead();
+   std::string error_msg = "failed dof: ";
    for (int i = 0; i < true_ess_dofs.Size(); i++)
    {
-      if (bool(ted[i]) != bool(true_ess_dofs2[i])) { counter++; }
+      if (bool(ted[i]) != bool(true_ess_dofs2[i]))
+      {
+         error_msg += std::to_string(i) += "(R ";
+         error_msg += std::to_string(bool(ted[i])) += " P^T ";
+         error_msg += std::to_string(bool(true_ess_dofs2[i])) += ") ";
+         ++counter;
+      }
    }
+   MFEM_ASSERT(R->Height() == P->Width(), "!");
+   MFEM_ASSERT(R->Width() == P->Height(), "!");
+   MFEM_ASSERT(R->Width() == ess_dofs.Size(), "!");
    MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter
-               << ", rank = " << MyRank);
+               << ", rank = " << MyRank << ", " << error_msg);
 #endif
 
    MarkerToList(true_ess_dofs, ess_tdof_list);
@@ -1261,6 +1305,7 @@ void ParFiniteElementSpace::ExchangeFaceNbrData()
    // element)
    face_nbr_element_dof.MakeI(recv_el_off[num_face_nbrs]);
 
+
    int *send_I = send_nbr_elem_dof.GetI();
    int *recv_I = face_nbr_element_dof.GetI();
    for (int fn = 0; fn < num_face_nbrs; fn++)
@@ -1923,9 +1968,8 @@ struct PMatrixRow
    void AddRow(const PMatrixRow &other, double coef)
    {
       elems.reserve(elems.size() + other.elems.size());
-      for (unsigned i = 0; i < other.elems.size(); i++)
+      for (const PMatrixElement &oei : other.elems)
       {
-         const PMatrixElement &oei = other.elems[i];
          elems.push_back(
             PMatrixElement(oei.column, oei.stride, coef * oei.value));
       }
@@ -2059,6 +2103,7 @@ void NeighborRowMessage::Encode(int rank)
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+
          const RowInfo &ri = rows[row_idx[ent][i]];
          MFEM_ASSERT(ent == ri.entity, "");
 
@@ -2110,24 +2155,36 @@ void NeighborRowMessage::Decode(int rank)
    rows.reserve(nrows);
 
    // read rows
+   // ent = {0,1,2} means vertex, edge and face entity
    for (int ent = 0, gi = 0; ent < 3; ent++)
    {
+      // extract the vertex list, edge list or face list.
       const Array<MeshId> &ids = ent_ids[ent];
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+         // read the particular element dof value off the stream.
          int edof = bin_io::read<int>(stream);
 
-         // handle orientation and sign change
-         const int *ind = NULL;
+         // Handle orientation and sign change.
+         // This flips the sign on dofs where necessary, and for edges and faces
+         // also reorders if flipped, i.e. an edge with
+         //    1 -> 2 -> 3 -> 4
+         // might become
+         //    -4 -> -3 -> -2 -> -1
+         // This cannot treat all face dofs, as they can have rotations and
+         // reflections.
+         const int *ind = nullptr;
+         Geometry::Type geom = Geometry::Type::INVALID;
          if (ent == 1)
          {
+            // edge NC orientation is element defined.
             int eo = pncmesh->GetEdgeNCOrientation(id);
             ind = fec->DofOrderForOrientation(Geometry::SEGMENT, eo);
          }
          else if (ent == 2)
          {
-            Geometry::Type geom = pncmesh->GetFaceGeometry(id.index);
+            geom = pncmesh->GetFaceGeometry(id.index);
             int fo = pncmesh->GetFaceOrientation(id.index);
             ind = fec->DofOrderForOrientation(geom, fo);
          }
@@ -2149,6 +2206,7 @@ void NeighborRowMessage::Decode(int rank)
             s *= -1.0;
          }
 
+         // Create a row for this entity, recording the index of the mesh element
          rows.push_back(RowInfo(ent, id.index, edof, group_ids[gi++]));
          rows.back().row.read(stream, s);
 
@@ -2158,6 +2216,65 @@ void NeighborRowMessage::Decode(int rank)
                    << rows.back().index << ", edof " << rows.back().edof
                    << std::endl;
 #endif
+
+         if (ent == 2 && fec->GetContType() == FiniteElementCollection::TANGENTIAL
+             && !Geometry::IsTensorProduct(geom))
+         {
+            // ND face dofs need to be processed together, as the transformation
+            // is given by a 2x2 matrix, so we manually apply an extra increment
+            // to the loop counter and add in a new row. Once these rows are placed, they
+            // represent the Identity transformation. To map across the
+            // processor boundary, we also need to apply a Primal Transformation
+            // (see doftrans.hpp) to a notional "global dof" orientation.
+            // For simplicity we perform the action of these 2x2 matrices
+            // manually using the AddRow capability, followed by a Collapse.
+
+            // To perform the operations, we add and subtract initial versions
+            // of the rows, that represent [1 0; 0 1] in row major notation.
+            // The first row represents the 1 at (0,0) in [1 0; 0 1]
+            // The second row represents the 1 at (1,1) in [1 0; 0 1]
+
+            // We can safely bind this reference as rows was reserved above so
+            // there is no hidden copying that could result in a dangling reference.
+            auto &first_row = rows.back().row;
+            // This is the first "fundamental unit" used in the transformation.
+            const auto initial_first_row = first_row;
+            // Extract the next dof too, and apply any dof order transformation expected.
+            const MeshId &next_id = ids[++i];
+            int fo = pncmesh->GetFaceOrientation(next_id.index);
+            ind = fec->DofOrderForOrientation(geom, fo);
+
+            s = 1.0;
+            edof = bin_io::read<int>(stream);
+            if (ind && (edof = ind[edof]) < 0)
+            {
+               edof = -1 - edof;
+               s = -1.0;
+            }
+            rows.push_back(RowInfo(ent, next_id.index, edof, group_ids[gi++]));
+            rows.back().row.read(stream, s);
+
+            auto &second_row = rows.back().row;
+
+            // This is the second "fundamental unit" used in the transformation.
+            const auto initial_second_row = second_row;
+
+            const auto T = [&fo]()
+            {
+               auto T = ND_DofTransformation::GetFaceTransform(fo);
+               T(0,0) -= 1;
+               T(1,1) -= 1;
+               return T;
+            }();
+
+            first_row.AddRow(initial_first_row, T(0,0));
+            first_row.AddRow(initial_second_row, T(0,1));
+            second_row.AddRow(initial_first_row, T(1,0));
+            second_row.AddRow(initial_second_row, T(1,1));
+
+            first_row.Collapse();
+            second_row.Collapse();
+         }
       }
    }
 }
@@ -2285,12 +2402,6 @@ int ParFiniteElementSpace
                                        Array<int> *dof_tdof,
                                        bool partial) const
 {
-   // TODO: general face DOF transformations in NeighborRowMessage::Decode()
-   MFEM_VERIFY(!(fec->GetOrder() >= 2
-                 && pmesh->HasGeometry(Geometry::TETRAHEDRON)
-                 && fec->GetContType() == FiniteElementCollection::TANGENTIAL),
-               "Nedelec NC tets of order >= 2 are not supported yet.");
-
    const bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
 
 #ifdef MFEM_PMATRIX_STATS
@@ -2331,7 +2442,7 @@ int ParFiniteElementSpace
 
             if (master_dofs.Size() == 0) { continue; }
 
-            const FiniteElement* fe = fec->FiniteElementForGeometry(mf.Geom());
+            const FiniteElement * const fe = fec->FiniteElementForGeometry(mf.Geom());
             if (fe == nullptr) { continue; }
 
             switch (mf.Geom())
@@ -2480,6 +2591,8 @@ int ParFiniteElementSpace
       *dof_tdof = -1;
    }
 
+
+
    std::vector<PMatrixRow> pmatrix(total_dofs);
 
    const bool bynodes = (ordering == Ordering::byNODES);
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 3b940f2af..7bf683049 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -123,8 +123,8 @@ private:
    void GetGhostVertexDofs(const MeshId &id, Array<int> &dofs) const;
    void GetGhostEdgeDofs(const MeshId &edge_id, Array<int> &dofs) const;
    void GetGhostFaceDofs(const MeshId &face_id, Array<int> &dofs) const;
-
    void GetGhostDofs(int entity, const MeshId &id, Array<int> &dofs) const;
+
    /// Return the dofs associated with the interior of the given mesh entity.
    void GetBareDofs(int entity, int index, Array<int> &dofs) const;
 
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index 0a58530c1..50ee18668 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -469,17 +469,17 @@ void ParGridFunction::GetVectorValue(ElementTransformation &T,
    }
 
    Array<int> vdofs;
-   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no,
-                                                               vdofs);
-   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
-
-   int dof = fe->GetDof();
+   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no, vdofs);
    Vector loc_data;
    face_nbr_data.GetSubVector(vdofs, loc_data);
    if (doftrans)
    {
       doftrans->InvTransformPrimal(loc_data);
    }
+
+   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
+   int dof = fe->GetDof();
+
    if (fe->GetRangeType() == FiniteElement::SCALAR)
    {
       Vector shape(dof);
diff --git a/general/hash.hpp b/general/hash.hpp
index 288d51288..b517172aa 100644
--- a/general/hash.hpp
+++ b/general/hash.hpp
@@ -335,6 +335,8 @@ public:
 
    iterator begin() { return iterator(Base::begin()); }
    iterator end() { return iterator(); }
+   const_iterator begin() const { return const_iterator(Base::cbegin()); }
+   const_iterator end() const { return const_iterator(); }
 
    const_iterator cbegin() const { return const_iterator(Base::cbegin()); }
    const_iterator cend() const { return const_iterator(); }
diff --git a/general/table.cpp b/general/table.cpp
index 4c0bb68ee..da4c0187b 100644
--- a/general/table.cpp
+++ b/general/table.cpp
@@ -218,7 +218,8 @@ void Table::SetIJ(int *newI, int *newJ, int newsize)
 
 int Table::Push(int i, int j)
 {
-   MFEM_ASSERT( i >=0 && i<size, "Index out of bounds.  i = "<<i);
+   MFEM_ASSERT( i >=0 &&
+                i<size, "Index out of bounds.  i = " << i << " size " << size);
 
    for (int k = I[i], end = I[i+1]; k < end; k++)
    {
diff --git a/mesh/element.hpp b/mesh/element.hpp
index c37205eb1..2376c9dc3 100644
--- a/mesh/element.hpp
+++ b/mesh/element.hpp
@@ -57,12 +57,15 @@ public:
    /// Set element's attribute.
    inline void SetAttribute(const int attr) { attribute = attr; }
 
-   /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
-
-   /// Returns element's vertices.
+   /// Get the indices defining the vertices
    virtual void GetVertices(Array<int> &v) const = 0;
 
+   /// Set the indices defining the vertices
+   virtual void SetVertices(const Array<int> &v) = 0;
+
+   /// Set the indices the element according to the input.
+   virtual void SetVertices(const int *ind) = 0;
+
    /// @note The returned array should NOT be deleted by the caller.
    virtual int *GetVertices() = 0;
 
diff --git a/mesh/hexahedron.cpp b/mesh/hexahedron.cpp
index beeab3b6a..e86e209c1 100644
--- a/mesh/hexahedron.cpp
+++ b/mesh/hexahedron.cpp
@@ -43,10 +43,18 @@ Hexahedron::Hexahedron(int ind1, int ind2, int ind3, int ind4,
 void Hexahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(8);
-   for (int i = 0; i < 8; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 8, v.begin());
+}
+
+void Hexahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 8, "!");
+   std::copy(v.begin(), v.end(), indices);
+}
+
+void Hexahedron::SetVertices(const int *ind)
+{
+   std::copy(ind, ind + 8, indices);
 }
 
 TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/hexahedron.hpp b/mesh/hexahedron.hpp
index a8186c0c8..450cac0ce 100644
--- a/mesh/hexahedron.hpp
+++ b/mesh/hexahedron.hpp
@@ -37,35 +37,42 @@ public:
               int ind5, int ind6, int ind7, int ind8, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::HEXAHEDRON; }
+   Type GetType() const override { return Element::HEXAHEDRON; }
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int GetNVertices() const { return 8; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNEdges() const { return 12; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual const int *GetEdgeVertices(int ei) const
+   int GetNVertices() const override { return 8; }
+
+   int GetNEdges() const override { return 12; }
+
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 4; return 6; }
 
-   virtual int GetNFaces() const { return 6; }
+   int GetNFaces() const override { return 6; }
 
-   virtual int GetNFaceVertices(int) const { return 4; }
+   int GetNFaceVertices(int) const override { return 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Hexahedron(indices, attribute); }
 
-   virtual ~Hexahedron() { }
+   virtual ~Hexahedron() = default;
 };
 
 extern MFEM_EXPORT class TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 43651b881..8224ef5a2 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -1110,6 +1110,7 @@ FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
    {
       return NULL;
    }
+
    tr = GetFaceElementTransformations(fn, 21);
    tr->Attribute = boundary[BdrElemNo]->GetAttribute();
    tr->ElementNo = BdrElemNo;
@@ -1432,6 +1433,7 @@ Geometry::Type Mesh::GetFaceGeometry(int Face) const
          }
          // ghost face
          const int nc_face_id = faces_info[Face].NCFace;
+
          MFEM_ASSERT(nc_face_id >= 0, "parent ghost faces are not supported");
          return faces[nc_faces_info[nc_face_id].MasterFace]->GetGeometryType();
    }
@@ -1907,14 +1909,11 @@ int Mesh::AddBdrPoint(int v, int attr)
 
 void Mesh::GenerateBoundaryElements()
 {
-   int i, j;
    Array<int> &be2face = (Dim == 2) ? be_to_edge : be_to_face;
 
-   // GenerateFaces();
-
-   for (i = 0; i < boundary.Size(); i++)
+   for (auto &b : boundary)
    {
-      FreeElement(boundary[i]);
+      FreeElement(b);
    }
 
    if (Dim == 3)
@@ -1925,14 +1924,14 @@ void Mesh::GenerateBoundaryElements()
 
    // count the 'NumOfBdrElements'
    NumOfBdrElements = 0;
-   for (i = 0; i < faces_info.Size(); i++)
+   for (const auto &fi : faces_info)
    {
-      if (faces_info[i].Elem2No < 0) { NumOfBdrElements++; }
+      if (fi.Elem2No < 0) { ++NumOfBdrElements; }
    }
 
    boundary.SetSize(NumOfBdrElements);
    be2face.SetSize(NumOfBdrElements);
-   for (j = i = 0; i < faces_info.Size(); i++)
+   for (int j = 0, i = 0; i < faces_info.Size(); ++i)
    {
       if (faces_info[i].Elem2No < 0)
       {
@@ -4419,7 +4418,7 @@ Mesh::Mesh(Mesh *orig_mesh, int ref_factor, int ref_type)
    MakeRefined_(*orig_mesh, ref_factors, ref_type);
 }
 
-void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                         int ref_type)
 {
    SetEmpty();
@@ -6237,22 +6236,22 @@ int Mesh::CheckBdrElementOrientation(bool fix_it)
             {
                // swap vertices 0 and 1 so that we don't change the marked edge:
                // (0,1,2) -> (1,0,2)
-               mfem::Swap<int>(bv[0], bv[1]);
+               std::swap(bv[0], bv[1]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[1], be[2]);
+                  std::swap(be[1], be[2]);
                }
                break;
             }
             case Element::QUADRILATERAL:
             {
-               mfem::Swap<int>(bv[0], bv[2]);
+               std::swap(bv[0], bv[2]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[0], be[1]);
-                  mfem::Swap<int>(be[2], be[3]);
+                  std::swap(be[0], be[1]);
+                  std::swap(be[2], be[3]);
                }
                break;
             }
@@ -6956,9 +6955,9 @@ void Mesh::AddQuadFaceElement(int lf, int gf, int el,
 
 void Mesh::GenerateFaces()
 {
-   int i, nfaces = GetNumFaces();
+   int nfaces = GetNumFaces();
 
-   for (i = 0; i < faces.Size(); i++)
+   for (int i = 0; i < faces.Size(); ++i)
    {
       FreeElement(faces[i]);
    }
@@ -6966,16 +6965,17 @@ void Mesh::GenerateFaces()
    // (re)generate the interior faces and the info for them
    faces.SetSize(nfaces);
    faces_info.SetSize(nfaces);
-   for (i = 0; i < nfaces; i++)
+   for (int i = 0; i < nfaces; ++i)
    {
       faces[i] = NULL;
       faces_info[i].Elem1No = -1;
       faces_info[i].NCFace = -1;
    }
-   for (i = 0; i < NumOfElements; i++)
+
+   Array<int> v;
+   for (int i = 0; i < NumOfElements; ++i)
    {
-      const int *v = elements[i]->GetVertices();
-      const int *ef;
+      elements[i]->GetVertices(v);
       if (Dim == 1)
       {
          AddPointFaceElement(0, v[0], i);
@@ -6983,7 +6983,7 @@ void Mesh::GenerateFaces()
       }
       else if (Dim == 2)
       {
-         ef = el_to_edge->GetRow(i);
+         const int * const ef = el_to_edge->GetRow(i);
          const int ne = elements[i]->GetNEdges();
          for (int j = 0; j < ne; j++)
          {
@@ -6993,7 +6993,7 @@ void Mesh::GenerateFaces()
       }
       else
       {
-         ef = el_to_face->GetRow(i);
+         const int * const ef = el_to_face->GetRow(i);
          switch (GetElementType(i))
          {
             case Element::TETRAHEDRON:
@@ -7059,9 +7059,9 @@ void Mesh::GenerateNCFaceInfo()
 {
    MFEM_VERIFY(ncmesh, "missing NCMesh.");
 
-   for (int i = 0; i < faces_info.Size(); i++)
+   for (auto &x : faces_info)
    {
-      faces_info[i].NCFace = -1;
+      x.NCFace = -1;
    }
 
    const NCMesh::NCList &list =
@@ -7073,9 +7073,8 @@ void Mesh::GenerateNCFaceInfo()
    int nfaces = GetNumFaces();
 
    // add records for master faces
-   for (int i = 0; i < list.masters.Size(); i++)
+   for (const NCMesh::Master &master : list.masters)
    {
-      const NCMesh::Master &master = list.masters[i];
       if (master.index >= nfaces) { continue; }
 
       FaceInfo &master_fi = faces_info[master.index];
@@ -7087,10 +7086,8 @@ void Mesh::GenerateNCFaceInfo()
    }
 
    // add records for slave faces
-   for (int i = 0; i < list.slaves.Size(); i++)
+   for (const NCMesh::Slave &slave : list.slaves)
    {
-      const NCMesh::Slave &slave = list.slaves[i];
-
       if (slave.index < 0 || // degenerate slave face
           slave.index >= nfaces || // ghost slave
           slave.master >= nfaces) // has ghost master
@@ -7173,7 +7170,7 @@ STable3D *Mesh::GetFacesTable()
             break;
          }
          default:
-            MFEM_ABORT("Unexpected type of Element.");
+            MFEM_ABORT("Unexpected type of Element: " << GetElementType(i));
       }
    }
    return faces_tbl;
@@ -7181,7 +7178,7 @@ STable3D *Mesh::GetFacesTable()
 
 STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
 {
-   int i, *v;
+   Array<int> v;
    STable3D *faces_tbl;
 
    if (el_to_face != NULL)
@@ -7190,9 +7187,9 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    }
    el_to_face = new Table(NumOfElements, 6);  // must be 6 for hexahedra
    faces_tbl = new STable3D(NumOfVertices);
-   for (i = 0; i < NumOfElements; i++)
+   for (int i = 0; i < NumOfElements; i++)
    {
-      v = elements[i]->GetVertices();
+      elements[i]->GetVertices(v);
       switch (GetElementType(i))
       {
          case Element::TETRAHEDRON:
@@ -7256,9 +7253,10 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    el_to_face->Finalize();
    NumOfFaces = faces_tbl->NumberOfElements();
    be_to_face.SetSize(NumOfBdrElements);
-   for (i = 0; i < NumOfBdrElements; i++)
+
+   for (int i = 0; i < NumOfBdrElements; i++)
    {
-      v = boundary[i]->GetVertices();
+      boundary[i]->GetVertices(v);
       switch (GetBdrElementType(i))
       {
          case Element::TRIANGLE:
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index d148358c2..e1cda7069 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -563,7 +563,7 @@ protected:
    void Make1D(int n, double sx = 1.0);
 
    /// Internal function used in Mesh::MakeRefined
-   void MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+   void MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                      int ref_type);
 
    /// Initialize vertices/elements/boundary/tables from a nonconforming mesh.
@@ -1162,6 +1162,14 @@ public:
    /// the Element object itself should not be deleted by the caller.
    Element *GetBdrElement(int i) { return boundary[i]; }
 
+   inline int GetNCMasterFaceIndex(int i) const
+   {
+      MFEM_ASSERT(i < nc_faces_info.Size() &&
+                  i >= 0, i << " not in [0, " << nc_faces_info.Size() << ")");
+      const auto &ncf = nc_faces_info[i];
+      MFEM_VERIFY(ncf.Slave, "If the master face is requested, must be slave");
+      return ncf.MasterFace;
+   }
    const Element *GetFace(int i) const { return faces[i]; }
 
    /// @}
@@ -1650,7 +1658,7 @@ public:
                           };
 
    /** @brief This structure is used as a human readable output format that
-       decipheres the information contained in Mesh::FaceInfo when using the
+       deciphers the information contained in Mesh::FaceInfo when using the
        Mesh::GetFaceInformation() method.
 
        The element indices in this structure don't need further processing,
diff --git a/mesh/ncmesh.cpp b/mesh/ncmesh.cpp
index 381e73f60..550e104dd 100644
--- a/mesh/ncmesh.cpp
+++ b/mesh/ncmesh.cpp
@@ -2449,18 +2449,21 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
    // left uninitialized here; they will be initialized later by the Mesh from
    // Nodes -- here we just make sure mesh.vertices has the correct size.
 
-   for (int i = 0; i < mesh.NumOfElements; i++)
+   for (auto elem : mesh.elements)
    {
-      mesh.FreeElement(mesh.elements[i]);
+      mesh.FreeElement(elem);
    }
    mesh.elements.SetSize(0);
 
-   for (int i = 0; i < mesh.NumOfBdrElements; i++)
+   for (auto elem : mesh.boundary)
    {
-      mesh.FreeElement(mesh.boundary[i]);
+      mesh.FreeElement(elem);
    }
    mesh.boundary.SetSize(0);
 
+   // Save off boundary face vertices to make boundary elements later.
+   std::map<int, mfem::Array<int>> unique_boundary_faces;
+
    // create an mfem::Element for each leaf Element
    for (int i = 0; i < NElements; i++)
    {
@@ -2478,65 +2481,83 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
          elem->GetVertices()[j] = nodes[node[j]].vert_index;
       }
 
-      // create boundary elements
-      // TODO: use boundary_faces?
-      for (int k = 0; k < gi.nf; k++)
+      // Loop over faces and collect those marked as boundaries
+      for (int k = 0; k < gi.nf; ++k)
       {
-         const int* fv = gi.faces[k];
          const int nfv = gi.nfv[k];
-         const Face* face = faces.Find(node[fv[0]], node[fv[1]],
-                                       node[fv[2]], node[fv[3]]);
-         if (face->Boundary())
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+         if (id >= 0 && faces[id].Boundary())
          {
-            if ((nc_elem.geom == Geometry::CUBE) ||
-                ((nc_elem.geom == Geometry::PRISM ||
-                  nc_elem.geom == Geometry::PYRAMID) && nfv == 4))
-            {
-               auto* quad = (Quadrilateral*) mesh.NewElement(Geometry::SQUARE);
-               quad->SetAttribute(face->attribute);
-               for (int j = 0; j < 4; j++)
-               {
-                  quad->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(quad);
-            }
-            else if (nc_elem.geom == Geometry::PRISM ||
-                     nc_elem.geom == Geometry::PYRAMID ||
-                     nc_elem.geom == Geometry::TETRAHEDRON)
+            const auto &face = faces[id];
+            if (face.elem[0] >= 0 && face.elem[1] >= 0 &&
+                nc_elem.rank != std::min(elements[face.elem[0]].rank,
+                                         elements[face.elem[1]].rank))
             {
-               MFEM_ASSERT(nfv == 3, "");
-               auto* tri = (Triangle*) mesh.NewElement(Geometry::TRIANGLE);
-               tri->SetAttribute(face->attribute);
-               for (int j = 0; j < 3; j++)
-               {
-                  tri->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(tri);
+               // This is a conformal internal face, but this element is not the lowest
+               // ranking attached processor, thus not the owner of the face.
+               // Consequently, we do not add this face to avoid double
+               // counting.
+               continue;
             }
-            else if (nc_elem.geom == Geometry::SQUARE ||
-                     nc_elem.geom == Geometry::TRIANGLE)
+
+            // Add in all boundary faces that are actual boundaries or not masters of another face.
+            // The fv[2] in the edge split is on purpose.
+            if ((nfv == 4 &&
+                 QuadFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]], node[fv[3]]))
+                || (nfv == 3 && TriFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]]))
+                || (nfv == 2 &&
+                    EdgeSplitLevel(node[fv[0]], node[fv[2]] /* [2] not an error */) == 0))
             {
-               auto* segment = (Segment*) mesh.NewElement(Geometry::SEGMENT);
-               segment->SetAttribute(face->attribute);
-               for (int j = 0; j < 2; j++)
+               // This face has no split faces below, it is conformal or a
+               // slave.
+               unique_boundary_faces[id].SetSize(nfv);
+               for (int v = 0; v < nfv; ++v)
                {
-                  segment->GetVertices()[j] = nodes[node[fv[2*j]]].vert_index;
+                  // Using a map overwrites if a face is visited twice.
+                  // The nfv==2 is necessary because faces of 2D are storing the
+                  // second index in the 2 slot, not the 1 slot.
+                  unique_boundary_faces[id][v] = nodes[node[fv[(nfv==2) ? 2*v : v]]].vert_index;
                }
-               mesh.boundary.Append(segment);
-            }
-            else
-            {
-               MFEM_ASSERT(nc_elem.geom == Geometry::SEGMENT, "");
-               auto* point = (mfem::Point*) mesh.NewElement(Geometry::POINT);
-               point->SetAttribute(face->attribute);
-               point->GetVertices()[0] = nodes[node[fv[0]]].vert_index;
-               mesh.boundary.Append(point);
             }
          }
       }
    }
+
+   auto geom_from_nfv = [](int nfv)
+   {
+      switch (nfv)
+      {
+         case 1: return Geometry::POINT;
+         case 2: return Geometry::SEGMENT;
+         case 3: return Geometry::TRIANGLE;
+         case 4: return Geometry::SQUARE;
+      }
+      return Geometry::INVALID;
+   };
+
+   for (const auto &fv : unique_boundary_faces)
+   {
+      const auto f = fv.first;
+      const auto &v = fv.second;
+      const auto &face = faces.At(f);
+
+      auto geom = geom_from_nfv(v.Size());
+
+      MFEM_ASSERT(geom != Geometry::INVALID,
+                  "nfv: " << v.Size() <<
+                  " does not match a valid face geometry: Quad, Tri, Segment, Point");
+
+      // Add a new boundary element, with matching attribute and vertices
+      mesh.boundary.Append(mesh.NewElement(geom));
+      auto * const be = mesh.boundary.Last();
+      be->SetAttribute(face.attribute);
+      be->SetVertices(v);
+   }
 }
 
+
 void NCMesh::OnMeshUpdated(Mesh *mesh)
 {
    //// PART 1: pull indices of regular edges/faces from the Mesh
@@ -2651,13 +2672,14 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
       for (int j = 0; j < gi.nf; j++)
       {
          const int *fv = gi.faces[j];
-         Face* face = faces.Find(el.node[fv[0]], el.node[fv[1]],
-                                 el.node[fv[2]], el.node[fv[3]]);
-         MFEM_ASSERT(face, "face not found!");
+         int fid = faces.FindId(el.node[fv[0]], el.node[fv[1]],
+                                el.node[fv[2]], el.node[fv[3]]);
+         MFEM_ASSERT(fid >= 0, "face not found!");
+         auto &face = faces[fid];
 
-         if (face->index < 0)
+         if (face.index < 0)
          {
-            face->index = NFaces + (nghosts++);
+            face.index = NFaces + (nghosts++);
 
             // store the face geometry
             static const Geometry::Type types[5] =
@@ -2665,7 +2687,7 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
                Geometry::INVALID, Geometry::INVALID,
                Geometry::SEGMENT, Geometry::TRIANGLE, Geometry::SQUARE
             };
-            face_geom[face->index] = types[gi.nfv[j]];
+            face_geom[face.index] = types[gi.nfv[j]];
          }
       }
    }
@@ -2741,7 +2763,7 @@ bool NCMesh::TriFaceSplit(int v1, int v2, int v3, int mid[3]) const
 
    if (mid) { mid[0] = e1, mid[1] = e2, mid[2] = e3; }
 
-   // NOTE: face (v1, v2, v3) still needs to be checked
+   // This is necessary but not sufficient to determine if a face has been split.
    return true;
 }
 
@@ -5195,9 +5217,8 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetFaceList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int face : boundary_faces)
       {
-         int face = boundary_faces[i];
          if (bdr_attr_is_ess[faces[face].attribute - 1])
          {
             int node[4];
@@ -5226,9 +5247,8 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetEdgeList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int face : boundary_faces)
       {
-         int face = boundary_faces[i];
          Face &fc = faces[face];
          if (bdr_attr_is_ess[fc.attribute - 1])
          {
@@ -5245,18 +5265,35 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    bdr_edges.Unique();
 }
 
-static int max4(int a, int b, int c, int d)
+namespace
 {
-   return std::max(std::max(a, b), std::max(c, d));
-}
-static int max6(int a, int b, int c, int d, int e, int f)
-{
-   return std::max(max4(a, b, c, d), std::max(e, f));
-}
-static int max8(int a, int b, int c, int d, int e, int f, int g, int h)
+/**
+ * @brief Base case of convenience variadic max function.
+ *
+ * @tparam T Base type
+ * @param arg Recursion base value
+ * @return T value to max over
+ */
+template<typename T>
+T max(T&& arg)
+{
+   return arg;
+}
+/**
+ * @brief Convenience variadic max function.
+ *
+ * @tparam T Base Type
+ * @tparam Ts Parameter pack of other types
+ * @param arg Singular argument
+ * @param args Pack of arguments
+ * @return T maximum value
+ */
+template<typename T, typename... Ts>
+T max(T arg, Ts... args)
 {
-   return std::max(max4(a, b, c, d), max4(e, f, g, h));
+   return std::max(std::forward<T>(arg), max(args...));
 }
+} // namespace
 
 int NCMesh::EdgeSplitLevel(int vn1, int vn2) const
 {
@@ -5271,15 +5308,13 @@ int NCMesh::TriFaceSplitLevel(int vn1, int vn2, int vn3) const
    if (TriFaceSplit(vn1, vn2, vn3, mid) &&
        faces.FindId(vn1, vn2, vn3) < 0)
    {
-      return 1 + max4(TriFaceSplitLevel(vn1, mid[0], mid[2]),
-                      TriFaceSplitLevel(mid[0], vn2, mid[1]),
-                      TriFaceSplitLevel(mid[2], mid[1], vn3),
-                      TriFaceSplitLevel(mid[0], mid[1], mid[2]));
-   }
-   else // not split
-   {
-      return 0;
+      return 1 + max(TriFaceSplitLevel(vn1, mid[0], mid[2]),
+                     TriFaceSplitLevel(mid[0], vn2, mid[1]),
+                     TriFaceSplitLevel(mid[2], mid[1], vn3),
+                     TriFaceSplitLevel(mid[0], mid[1], mid[2]));
    }
+
+   return 0; // not split
 }
 
 void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
@@ -5309,6 +5344,13 @@ void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
    }
 }
 
+int NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const
+{
+   int h_level, v_level;
+   QuadFaceSplitLevel(vn1, vn2, vn3, vn4, h_level, v_level);
+   return h_level + v_level;
+}
+
 void NCMesh::CountSplits(int elem, int splits[3]) const
 {
    const Element &el = elements[elem];
@@ -5345,57 +5387,52 @@ void NCMesh::CountSplits(int elem, int splits[3]) const
 
    if (el.Geom() == Geometry::CUBE)
    {
-      splits[0] = max8(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
-                       elevel[0], elevel[2], elevel[4], elevel[6]);
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
+                      elevel[0], elevel[2], elevel[4], elevel[6]);
 
-      splits[1] = max8(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
-                       elevel[1], elevel[3], elevel[5], elevel[7]);
+      splits[1] = max(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
+                      elevel[1], elevel[3], elevel[5], elevel[7]);
 
-      splits[2] = max8(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[8], elevel[9], elevel[10], elevel[11]);
+      splits[2] = max(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[8], elevel[9], elevel[10], elevel[11]);
    }
    else if (el.Geom() == Geometry::PRISM)
    {
-      splits[0] = splits[1] =
-                     std::max(
-                        max6(flevel[0][0], flevel[1][0], 0,
-                             flevel[2][0], flevel[3][0], flevel[4][0]),
-                        max6(elevel[0], elevel[1], elevel[2],
-                             elevel[3], elevel[4], elevel[5]));
+      splits[0] = splits[1] = max(flevel[0][0], flevel[1][0], 0,
+                                  flevel[2][0], flevel[3][0], flevel[4][0],
+                                  elevel[0], elevel[1], elevel[2],
+                                  elevel[3], elevel[4], elevel[5]);
 
-      splits[2] = max6(flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[6], elevel[7], elevel[8]);
+      splits[2] = max(flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[6], elevel[7], elevel[8]);
    }
    else if (el.Geom() == Geometry::PYRAMID)
    {
-      splits[0] = std::max(
-                     max6(flevel[0][0], flevel[1][0], 0,
-                          flevel[2][0], flevel[3][0], flevel[4][0]),
-                     max8(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5],
-                          elevel[6], elevel[7]));
+      splits[0] = max(flevel[0][0], flevel[1][0], 0,
+                      flevel[2][0], flevel[3][0], flevel[4][0],
+                      elevel[0], elevel[1], elevel[2],
+                      elevel[3], elevel[4], elevel[5],
+                      elevel[6], elevel[7]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::TETRAHEDRON)
    {
-      splits[0] = std::max(
-                     max4(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0]),
-                     max6(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5]));
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0],
+                      elevel[0], elevel[1], elevel[2], elevel[3], elevel[4], elevel[5]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::SQUARE)
    {
-      splits[0] = std::max(elevel[0], elevel[2]);
-      splits[1] = std::max(elevel[1], elevel[3]);
+      splits[0] = max(elevel[0], elevel[2]);
+      splits[1] = max(elevel[1], elevel[3]);
    }
    else if (el.Geom() == Geometry::TRIANGLE)
    {
-      splits[0] = std::max(elevel[0], std::max(elevel[1], elevel[2]));
+      splits[0] = max(elevel[0], elevel[1], elevel[2]);
       splits[1] = splits[0];
    }
    else
@@ -6368,17 +6405,17 @@ void NCMesh::DebugDump(std::ostream &os) const
 
    // dump faces
    os << faces.Size() << "\n";
-   for (auto face = faces.cbegin(); face != faces.cend(); ++face)
+   for (const auto &face : faces)
    {
-      int elem = face->elem[0];
-      if (elem < 0) { elem = face->elem[1]; }
+      int elem = face.elem[0];
+      if (elem < 0) { elem = face.elem[1]; }
       MFEM_ASSERT(elem >= 0, "");
       const Element &el = elements[elem];
 
       int lf = find_local_face(el.Geom(),
-                               find_node(el, face->p1),
-                               find_node(el, face->p2),
-                               find_node(el, face->p3));
+                               find_node(el, face.p1),
+                               find_node(el, face.p2),
+                               find_node(el, face.p3));
 
       const int* fv = GI[el.Geom()].faces[lf];
       const int nfv = GI[el.Geom()].nfv[lf];
@@ -6388,7 +6425,7 @@ void NCMesh::DebugDump(std::ostream &os) const
       {
          os << " " << el.node[fv[i]];
       }
-      //os << " # face " << face.index() << ", index " << face->index << "\n";
+      //os << " # face " << face.index() << ", index " << face.index << "\n";
       os << "\n";
    }
 }
diff --git a/mesh/ncmesh.hpp b/mesh/ncmesh.hpp
index ddd423bfa..227aa4152 100644
--- a/mesh/ncmesh.hpp
+++ b/mesh/ncmesh.hpp
@@ -412,7 +412,6 @@ protected: // non-public interface for the Mesh class
        by calling Mesh::SetCurvature or otherwise setting the Nodes. */
    void MakeTopologyOnly() { coordinates.DeleteAll(); }
 
-
 protected: // implementation
 
    int Dim, spaceDim; ///< dimensions of the elements and the vertex coordinates
@@ -550,7 +549,6 @@ protected: // implementation
 
    Table element_vertex; ///< leaf-element to vertex table, see FindSetNeighbors
 
-
    /// Update the leaf elements indices in leaf_elements
    void UpdateLeafElements();
 
@@ -668,10 +666,79 @@ protected: // implementation
 
    mfem::Element* NewMeshElement(int geom) const;
 
-   int QuadFaceSplitType(int v1, int v2, int v3, int v4, int mid[5]
+   /**
+    * @brief Given a quad face defined by four vertices, establish which edges
+    * of this face have been split, and if so optionally return the mid points
+    * of those edges.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return int 0 -- no split, 1 -- "vertical" split, 2 -- "horizontal" split
+    */
+   int QuadFaceSplitType(int n1, int n2, int n3, int n4, int mid[5]
                          = NULL /*optional output of mid-edge nodes*/) const;
 
-   bool TriFaceSplit(int v1, int v2, int v3, int mid[3] = NULL) const;
+   /**
+    * @brief Given a tri face defined by three vertices, establish whether the
+    * edges that make up this face have been split, and if so optionally return
+    * the midpoints.
+    * @details This is a necessary condition for this face to have been split,
+    * but is not sufficient. Consider a triangle attached to three refined
+    * triangles, in this scenario all edges can be split but this face not be
+    * split. In this case, it is necessary to check if there is a face made up
+    * of the returned midpoint nodes.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return true Splits for all edges have been found
+    * @return false
+    */
+   bool TriFaceSplit(int n1, int n2, int n3, int mid[3] = NULL) const;
+
+   /**
+    * @brief Determine if a Triangle face is not a master
+    * @details This check requires looking for the edges making up the triangle
+    * being split, if nodes exist at their midpoints, and there are vertices at
+    * them, this implies the face COULD be split. To determine if it is, we then
+    * check whether these midpoints have all been connected, this is required to
+    * discriminate between an internal master face surrounded by nonconformal
+    * refinements and a conformal boundary face surrounded by refinements.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @return true The face is not a master
+    * @return false The face is a master
+    */
+   inline bool TriFaceNotMaster(int n1, int n2, int n3) const
+   {
+      int mid[3];
+      return !TriFaceSplit(n1, n2, n3, mid) // The edges aren't split
+             // OR none of the midpoints are connected.
+             || (nodes.FindId(mid[0], mid[1]) < 0 &&
+                 nodes.FindId(mid[0], mid[2]) < 0 &&
+                 nodes.FindId(mid[1], mid[2]) < 0);
+   }
+
+   /**
+    * @brief Determine if  a Quad face is not a master
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @return true The quad face is not a master
+    * @return false The quad face is a master
+    */
+   inline bool QuadFaceNotMaster(int n1, int n2, int n3, int n4) const
+   {
+      return QuadFaceSplitType(n1, n2, n3, n4) == 0;
+   }
 
    void ForceRefinement(int vn1, int vn2, int vn3, int vn4);
 
@@ -932,9 +999,7 @@ protected: // implementation
    void InitDerefTransforms();
    void SetDerefMatrixCodes(int parent, Array<int> &fine_coarse);
 
-
    // vertex temporary data, used by GetMeshComponents
-
    struct TmpVertex
    {
       bool valid, visited;
@@ -953,10 +1018,56 @@ protected: // implementation
 
    void FindFaceNodes(int face, int node[4]);
 
+   /**
+    * @brief Return the number of splits of this edge that have occurred in the
+    * NCMesh. If zero, this means the segment is not the master of any other segments.
+    *
+    * @param vn1 The first vertex making up the segment
+    * @param vn2 The second vertex making up the segment
+    * @return int The depth of splits of this segment that are present in the mesh.
+    */
    int EdgeSplitLevel(int vn1, int vn2) const;
+   /**
+    * @brief Return the number of splits of this triangle that have occurred in
+    * the NCMesh. If zero, this means the triangle is neither split, nor the
+    * master of a split face.
+    *
+    * @param vn1 The first vertex making up the triangle
+    * @param vn2 The second vertex making up the triangle
+    * @param vn3 The third vertex making up the triangle
+    * @return int The depth of splits of this triangle that are present in the mesh.
+    */
    int TriFaceSplitLevel(int vn1, int vn2, int vn3) const;
+   /**
+    * @brief Computes the number of horizontal and vertical splits of this quad
+    * that have occurred in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @param h_level The number of "horizontal" splits of the quad
+    * @param v_level The number of "vertical" splits of the quad
+    */
    void QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
                            int& h_level, int& v_level) const;
+   /**
+    * @brief Returns the total number of splits of this quad that have occurred
+    * in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    * @details This is a convenience wrapper that sums the horizontal and
+    * vertical levels from the full method.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @return int The depth of splits of this triangle that are present in the
+    * mesh. NB: An isotropic refinement has a level of 2, one horizontal split,
+    * followed by a vertical split.
+    */
+   int QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const;
 
    void CountSplits(int elem, int splits[3]) const;
    void GetLimitRefinements(Array<Refinement> &refinements, int max_level);
@@ -993,7 +1104,6 @@ protected: // implementation
    /// Load the deprecated MFEM mesh v1.1 format for backward compatibility.
    void LoadLegacyFormat(std::istream &input, int &curved, int &is_nc);
 
-
    // geometry
 
    /// This holds in one place the constants about the geometries we support
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index 356a13666..a781ff8ae 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -34,7 +34,6 @@ ParMesh::ParMesh(const ParMesh &pmesh, bool copy_nodes)
      group_sedge(pmesh.group_sedge),
      group_stria(pmesh.group_stria),
      group_squad(pmesh.group_squad),
-     face_nbr_el_to_face(NULL),
      glob_elem_offset(-1),
      glob_offset_sequence(-1),
      gtopo(pmesh.gtopo)
@@ -106,8 +105,7 @@ ParMesh& ParMesh::operator=(ParMesh &&mesh)
 
 ParMesh::ParMesh(MPI_Comm comm, Mesh &mesh, int *partitioning_,
                  int part_method)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -352,11 +350,8 @@ int ParMesh::BuildLocalVertices(const mfem::Mesh &mesh,
 int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
                                 const Array<int>& vert_global_local)
 {
-   int nelems = 0;
-   for (int i = 0; i < mesh.GetNE(); i++)
-   {
-      if (partitioning[i] == MyRank) { nelems++; }
-   }
+   const int nelems = std::count_if(partitioning,
+   partitioning + mesh.GetNE(), [this](int i) { return i == MyRank;});
 
    elements.SetSize(nelems);
 
@@ -375,7 +370,7 @@ int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
          {
             v[j] = vert_global_local[v[j]];
          }
-         element_counter++;
+         ++element_counter;
       }
    }
 
@@ -388,7 +383,6 @@ int ParMesh::BuildLocalBoundary(const Mesh& mesh, const int* partitioning,
                                 Table*& edge_element)
 {
    int nbdry = 0;
-
    if (mesh.NURBSext)
    {
       activeBdrElem.SetSize(mesh.GetNBE());
@@ -856,7 +850,6 @@ ParMesh::ParMesh(const ParNCMesh &pncmesh)
    : MyComm(pncmesh.MyComm)
    , NRanks(pncmesh.NRanks)
    , MyRank(pncmesh.MyRank)
-   , face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(MyComm)
@@ -908,7 +901,7 @@ void ParMesh::FinalizeParTopo()
    sface_lface.SetSize(nst + shared_quads.Size());
    if (sface_lface.Size())
    {
-      STable3D *faces_tbl = GetFacesTable();
+      auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
       for (int st = 0; st < nst; st++)
       {
          const int *v = shared_trias[st].v;
@@ -919,14 +912,12 @@ void ParMesh::FinalizeParTopo()
          const int *v = shared_quads[sq].v;
          sface_lface[nst+sq] = (*faces_tbl)(v[0], v[1], v[2], v[3]);
       }
-      delete faces_tbl;
    }
 }
 
 ParMesh::ParMesh(MPI_Comm comm, istream &input, int generate_edges,
                  int refine, bool fix_orientation)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
    , pncmesh(NULL)
@@ -1135,7 +1126,7 @@ void ParMesh::MakeRefined_(ParMesh &orig_mesh, int ref_factor, int ref_type)
    MyComm = orig_mesh.GetComm();
    NRanks = orig_mesh.GetNRanks();
    MyRank = orig_mesh.GetMyRank();
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face.reset();
    glob_elem_offset = -1;
    glob_offset_sequence = -1;
    gtopo = orig_mesh.gtopo;
@@ -2151,11 +2142,14 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Nonconforming())
    {
-      // with ParNCMesh we can set up face neighbors without communication
+      // with ParNCMesh we can set up face neighbors mostly without communication
       pncmesh->GetFaceNeighbors(*this);
       have_face_nbr_data = true;
 
-      ExchangeFaceNbrNodes();
+      // Internal boundary elements with an NC mesh requires extra "ghost
+      // boundary element" information for enforcing essential boundaries.
+      pncmesh->ComputeGhostBoundaryElements(*this);
+
       return;
    }
 
@@ -2220,7 +2214,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Dim == 3)
    {
-      GetFaceNbrElementToFaceTable();
+      BuildFaceNbrElementToFaceTable();
    }
 
    if (del_tables) { delete gr_sface; }
@@ -2348,6 +2342,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
    el_marker = -1;
    vertex_marker = -1;
    const int nst = shared_trias.Size();
+
    for (int fn = 0; fn < num_face_nbrs; fn++)
    {
       int nbr_group = face_nbr_group[fn];
@@ -2485,8 +2480,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
 
    // convert the element data into face_nbr_elements
    face_nbr_elements.SetSize(face_nbr_elements_offset[num_face_nbrs]);
-   face_nbr_el_ori.Clear();
-   face_nbr_el_ori.SetSize(face_nbr_elements_offset[num_face_nbrs], 6);
+   face_nbr_el_ori.reset(new Table(face_nbr_elements_offset[num_face_nbrs], 6));
    while (true)
    {
       int fn;
@@ -2517,7 +2511,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          if (Dim == 3)
          {
             int nf = el->GetNFaces();
-            int * fn_ori = face_nbr_el_ori.GetRow(elem_off);
+            int * fn_ori = face_nbr_el_ori->GetRow(elem_off);
             for (int j = 0; j < nf; j++)
             {
                fn_ori[j] = recv_elemdata[j];
@@ -2527,7 +2521,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          face_nbr_elements[elem_off++] = el;
       }
    }
-   face_nbr_el_ori.Finalize();
+   face_nbr_el_ori->Finalize();
 
    MPI_Waitall(num_face_nbrs, send_requests, statuses);
 
@@ -2749,191 +2743,118 @@ STable3D *ParMesh::GetSharedFacesTable()
    return sfaces_tbl;
 }
 
-STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
+template <int N>
+void
+ParMesh::AddTriFaces(const Array<int> &elem_vertices,
+                     const std::unique_ptr<STable3D> &faces,
+                     const std::unique_ptr<STable3D> &shared_faces,
+                     int elem, int start, int end, const int fverts[][N])
 {
-   int i, *v;
-   STable3D * faces_tbl = GetFacesTable();
-   STable3D * sfaces_tbl = GetSharedFacesTable();
-
-   if (face_nbr_el_to_face != NULL)
+   for (int i = start; i < end; ++i)
    {
-      delete face_nbr_el_to_face;
+      // Reference face vertices.
+      const auto fv = fverts[i];
+      // Element specific face vertices.
+      const Vert3 elem_fv(elem_vertices[fv[0]], elem_vertices[fv[1]],
+                          elem_vertices[fv[2]]);
+
+      // Check amongst the faces of elements local to this rank for this set of vertices
+      const int lf = faces->Index(elem_fv.v[0], elem_fv.v[1], elem_fv.v[2]);
+
+      // If the face wasn't found amonst processor local elements, search the
+      // ghosts for this set of vertices.
+      const int sf = lf < 0 ? shared_faces->Index(elem_fv.v[0], elem_fv.v[1],
+                                                  elem_fv.v[2]) : -1;
+      // If find local face -> use that
+      //    else if find shared face -> shift and use that
+      //       else no face found -> set to -1
+      const int face_to_add = lf < 0 ? (sf >= 0 ? sf + NumOfFaces : -1) : lf;
+
+      MFEM_ASSERT(sf >= 0 ||
+                  lf >= 0, "Face must be from a local or a face neighbor element");
+
+      // Add this discovered face to the list of faces of this face neighbor element
+      face_nbr_el_to_face->Push(elem, face_to_add);
    }
-   face_nbr_el_to_face = new Table(face_nbr_elements.Size(), 6);
-   for (i = 0; i < face_nbr_elements.Size(); i++)
+}
+
+void ParMesh::BuildFaceNbrElementToFaceTable()
+{
+   const auto faces = std::unique_ptr<STable3D>(GetFacesTable());
+   const auto shared_faces = std::unique_ptr<STable3D>(GetSharedFacesTable());
+
+   face_nbr_el_to_face.reset(new Table(face_nbr_elements.Size(), 6));
+
+   mfem::Array<int> v;
+
+   // Helper for adding quadrilateral faces.
+   auto add_quad_faces = [&faces, &shared_faces, &v, this]
+                         (int elem, int start, int end, const int fverts[][4])
    {
-      v = face_nbr_elements[i]->GetVertices();
-      switch (face_nbr_elements[i]->GetType())
+      for (int i = start; i < end; ++i)
       {
-         case Element::TETRAHEDRON:
+         const int * const fv = fverts[i];
+         int k = 0;
+         int max = v[fv[0]];
+
+         if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
+         if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
+         if (max < v[fv[3]]) { k = 3; }
+
+         int v0 = -1, v1 = -1, v2 = -1;
+         switch (k)
          {
-            for (int j = 0; j < 4; j++)
+            case 0:
+               v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 1:
+               v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 2:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
+               break;
+            case 3:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
+               break;
+         }
+         int lf = faces->Index(v0, v1, v2);
+         if (lf < 0)
+         {
+            lf = shared_faces->Index(v0, v1, v2);
+            if (lf >= 0)
             {
-               const int *fv = tet_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
+               lf += NumOfFaces;
             }
+         }
+         face_nbr_el_to_face->Push(elem, lf);
+      }
+   };
+
+   for (int i = 0; i < face_nbr_elements.Size(); i++)
+   {
+      face_nbr_elements[i]->GetVertices(v);
+      switch (face_nbr_elements[i]->GetType())
+      {
+         case Element::TETRAHEDRON:
+         {
+            AddTriFaces(v, faces, shared_faces, i, 0, 4, tet_t::FaceVert);
             break;
          }
          case Element::WEDGE:
          {
-            for (int j = 0; j < 2; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 2; j < 5; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            AddTriFaces(v, faces, shared_faces, i, 0, 2, pri_t::FaceVert);
+            add_quad_faces(i, 2, 5, pri_t::FaceVert);
             break;
          }
          case Element::PYRAMID:
          {
-            for (int j = 0; j < 1; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 1; j < 5; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 1, pyr_t::FaceVert);
+            AddTriFaces(v, faces, shared_faces, i, 1, 5, pyr_t::FaceVert);
             break;
          }
          case Element::HEXAHEDRON:
          {
-            // find the face by the vertices with the smallest 3 numbers
-            // z = 0, y = 0, x = 1, y = 1, x = 0, z = 1
-            for (int j = 0; j < 6; j++)
-            {
-               const int *fv = hex_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 6, hex_t::FaceVert);
             break;
          }
          default:
@@ -2941,14 +2862,6 @@ STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
       }
    }
    face_nbr_el_to_face->Finalize();
-
-   delete sfaces_tbl;
-   if (ret_ftbl)
-   {
-      return faces_tbl;
-   }
-   delete faces_tbl;
-   return NULL;
 }
 
 int ParMesh::GetFaceNbrRank(int fn) const
@@ -2969,33 +2882,31 @@ int ParMesh::GetFaceNbrRank(int fn) const
 }
 
 void
-ParMesh::GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const
+ParMesh::GetFaceNbrElementFaces(int i, Array<int> &faces,
+                                Array<int> &orientations) const
 {
-   int n, j;
    int el_nbr = i - GetNE();
-   if (face_nbr_el_to_face)
+   if (face_nbr_el_to_face != nullptr && el_nbr < face_nbr_el_to_face->Size())
    {
-      face_nbr_el_to_face->GetRow(el_nbr, fcs);
+      face_nbr_el_to_face->GetRow(el_nbr, faces);
    }
    else
    {
       MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
                  "face_nbr_el_to_face not generated.");
    }
-   if (el_nbr < face_nbr_el_ori.Size())
+
+   if (face_nbr_el_ori != nullptr && el_nbr < face_nbr_el_ori->Size())
    {
-      const int * row = face_nbr_el_ori.GetRow(el_nbr);
-      n = fcs.Size();
-      cor.SetSize(n);
-      for (j=0; j<n; j++)
-      {
-         cor[j] = row[j];
-      }
+      face_nbr_el_ori->GetRow(el_nbr, orientations);
    }
    else
    {
-      MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
-                 "face_nbr_el_to_face not generated.");
+      // No face_nbr_el_ori was generated, make the orientations invalid.
+      // This will cause errors if the face orientations are necessary to
+      // evaluate the basis in face neighbor elements.
+      orientations.SetSize(faces.Size());
+      orientations = -1;
    }
 }
 
@@ -3255,7 +3166,7 @@ int ParMesh::GetSharedFace(int sface) const
    {
       MFEM_ASSERT(Dim > 1, "");
       const NCMesh::NCList &shared = pncmesh->GetSharedList(Dim-1);
-      int csize = (int) shared.conforming.Size();
+      int csize = shared.conforming.Size();
       return sface < csize
              ? shared.conforming[sface].index
              : shared.slaves[sface - csize].index;
@@ -4605,7 +4516,7 @@ void ParMesh::UniformRefinement3D()
 
    DSTable v_to_v(NumOfVertices);
    GetVertexToVertexTable(v_to_v);
-   STable3D *faces_tbl = GetFacesTable();
+   auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
 
    // call Mesh::UniformRefinement3D_base so that it won't update the nodes
    Array<int> f2qf;
@@ -4620,7 +4531,6 @@ void ParMesh::UniformRefinement3D()
    // update the groups
    UniformRefineGroups3D(old_nv, old_nedges, v_to_v, *faces_tbl,
                          f2qf.Size() ? &f2qf : NULL);
-   delete faces_tbl;
 
    UpdateNodes();
 }
@@ -6722,6 +6632,8 @@ void ParMesh::Swap(ParMesh &other)
    mfem::Swap(face_nbr_vertices, other.face_nbr_vertices);
    mfem::Swap(send_face_nbr_elements, other.send_face_nbr_elements);
    mfem::Swap(send_face_nbr_vertices, other.send_face_nbr_vertices);
+   std::swap(face_nbr_el_ori, other.face_nbr_el_ori);
+   std::swap(face_nbr_el_to_face, other.face_nbr_el_to_face);
 
    // Nodes, NCMesh, and NURBSExtension are taken care of by Mesh::Swap
    mfem::Swap(pncmesh, other.pncmesh);
@@ -6742,8 +6654,7 @@ void ParMesh::Destroy()
    }
    shared_edges.DeleteAll();
 
-   delete face_nbr_el_to_face;
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face.reset();
 }
 
 ParMesh::~ParMesh()
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index 2ed8b00ec..c9d42aa73 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -85,8 +85,11 @@ protected:
    // sface ids: all triangles first, then all quads
    Array<int> sface_lface;
 
-   Table *face_nbr_el_to_face;
-   Table  face_nbr_el_ori; // orientations for each face (from nbr processor)
+   /// Table that maps from face neighbor element number, to the face numbers of
+   /// that element.
+   std::unique_ptr<Table> face_nbr_el_to_face;
+   /// orientations for each face (from nbr processor)
+   std::unique_ptr<Table> face_nbr_el_ori;
 
    IsoparametricTransformation FaceNbrTransformation;
 
@@ -123,7 +126,32 @@ protected:
    bool DecodeFaceSplittings(HashTable<Hashed2> &v_to_v, const int *v,
                              const Array<unsigned> &codes, int &pos);
 
-   STable3D *GetFaceNbrElementToFaceTable(int ret_ftbl = 0);
+   // Given a completed FacesTable and SharedFacesTable, construct a table that
+   // maps from face neighbor element number, to the set of faces of that
+   // element. Store the resulting data in the member variable
+   // face_nbr_el_to_face. If the mesh is nonconforming, this also builds the
+   // the face_nbr_el_ori variable from the faces_info.
+   void BuildFaceNbrElementToFaceTable();
+
+   /**
+    * @brief Helper function for adding triangle face neighbor element to face
+    * table entries. Have to use a template here rather than lambda capture
+    * because the FaceVert entries in Geometry have inner size of 3 for tets and
+    * 4 for everything else.
+    *
+    * @tparam N Inner dimension on the fvert variable, 3 for tet, 4 otherwise
+    * @param v Set of vertices for this element
+    * @param faces Table of faces interior to this rank
+    * @param shared_faces Table of faces shared by this rank and another
+    * @param elem The face neighbor element
+    * @param start Starting index into fverts
+    * @param end End index into fverts
+    * @param fverts Array of face vertices for this particular geometry.
+    */
+   template <int N>
+   void AddTriFaces(const Array<int> &v, const std::unique_ptr<STable3D> &faces,
+                    const std::unique_ptr<STable3D> &shared_faces,
+                    int elem, int start, int end, const int fverts[][N]);
 
    void GetFaceNbrElementTransformation(
       int i, IsoparametricTransformation *ElTr);
@@ -297,7 +325,7 @@ protected:
 
 public:
    /// Default constructor. Create an empty @a ParMesh.
-   ParMesh() : MyComm(0), NRanks(0), MyRank(-1), face_nbr_el_to_face(NULL),
+   ParMesh() : MyComm(0), NRanks(0), MyRank(-1),
       glob_elem_offset(-1), glob_offset_sequence(-1),
       have_face_nbr_data(false), pncmesh(NULL) { }
 
@@ -476,7 +504,8 @@ public:
    int GetFaceNbrRank(int fn) const;
 
    /** Similar to Mesh::GetElementFaces */
-   void GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const;
+   void GetFaceNbrElementFaces(int i, Array<int> &faces,
+                               Array<int> &orientation) const;
 
    /** Similar to Mesh::GetFaceToElementTable with added face-neighbor elements
        with indices offset by the local number of elements. */
@@ -566,6 +595,8 @@ public:
    /// Return the local face index for the given shared face.
    int GetSharedFace(int sface) const;
 
+
+
    /** @brief Returns the number of local faces according to the requested type,
        does not count master non-conforming faces.
 
diff --git a/mesh/pncmesh.cpp b/mesh/pncmesh.cpp
index 96501a82c..edddf1ce6 100644
--- a/mesh/pncmesh.cpp
+++ b/mesh/pncmesh.cpp
@@ -16,10 +16,12 @@
 #include "mesh_headers.hpp"
 #include "pncmesh.hpp"
 #include "../general/binaryio.hpp"
+#include "../general/communication.hpp"
 
 #include <numeric> // std::accumulate
 #include <map>
 #include <climits> // INT_MIN, INT_MAX
+#include <array>
 
 namespace mfem
 {
@@ -575,17 +577,17 @@ void ParNCMesh::CalcFaceOrientations()
    face_orient.SetSize(NFaces);
    face_orient = 0;
 
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto face : faces)
    {
-      if (face->elem[0] >= 0 && face->elem[1] >= 0 && face->index < NFaces)
+      if (face.elem[0] >= 0 && face.elem[1] >= 0 && face.index < NFaces)
       {
-         Element *e1 = &elements[face->elem[0]];
-         Element *e2 = &elements[face->elem[1]];
+         Element *e1 = &elements[face.elem[0]];
+         Element *e2 = &elements[face.elem[1]];
 
          if (e1->rank == e2->rank) { continue; }
          if (e1->rank > e2->rank) { std::swap(e1, e2); }
 
-         face_orient[face->index] = get_face_orientation(*face, *e1, *e2);
+         face_orient[face.index] = get_face_orientation(face, *e1, *e2);
       }
    }
 }
@@ -596,16 +598,16 @@ void ParNCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
 {
    NCMesh::GetBoundaryClosure(bdr_attr_is_ess, bdr_vertices, bdr_edges);
 
-   int i, j;
    // filter out ghost vertices
-   for (i = j = 0; i < bdr_vertices.Size(); i++)
+   int j = 0;
+   for (int i = j = 0; i < bdr_vertices.Size(); i++)
    {
       if (bdr_vertices[i] < NVertices) { bdr_vertices[j++] = bdr_vertices[i]; }
    }
    bdr_vertices.SetSize(j);
 
    // filter out ghost edges
-   for (i = j = 0; i < bdr_edges.Size(); i++)
+   for (int i = j = 0; i < bdr_edges.Size(); i++)
    {
       if (bdr_edges[i] < NEdges) { bdr_edges[j++] = bdr_edges[i]; }
    }
@@ -887,6 +889,7 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
 
    Array<Element*> fnbr;
    Array<Connection> send_elems;
+   std::map<int, std::vector<int>> recv_elems;
 
    // Counts the number of slave faces of a master. This may be larger than the
    // number of shared slaves if there exist degenerate slave-faces from face-edge constraints.
@@ -901,8 +904,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    fnbr.Reserve(bound);
    send_elems.Reserve(bound);
 
+   // If there are face neighbor elements with triangular faces, the
+   // `face_nbr_el_ori` structure will need to be built. This requires
+   // communication so we attempt to avoid it by checking first.
+   bool face_nbr_w_tri_faces = false;
+
    // go over all shared faces and collect face neighbor elements
-   for (int i = 0; i < shared.conforming.Size(); i++)
+   for (int i = 0; i < shared.conforming.Size(); ++i)
    {
       const MeshId &cf = shared.conforming[i];
       Face* face = GetFace(elements[cf.element], cf.local);
@@ -914,8 +922,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       if (e[0]->rank == MyRank) { std::swap(e[0], e[1]); }
       MFEM_ASSERT(e[0]->rank != MyRank && e[1]->rank == MyRank, "");
 
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
       fnbr.Append(e[0]);
       send_elems.Append(Connection(e[0]->rank, e[1]->index));
+      recv_elems[e[0]->rank].push_back(e[0]->index);
    }
 
    for (int i = 0; i < shared.masters.Size(); i++)
@@ -938,8 +950,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
          }
          if (loc0) { std::swap(e[0], e[1]); }
 
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
          fnbr.Append(e[0]);
          send_elems.Append(Connection(e[0]->rank, e[1]->index));
+         recv_elems[e[0]->rank].push_back(e[0]->index);
       }
    }
 
@@ -1022,6 +1038,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    send_elems.Sort();
    send_elems.Unique();
 
+   for (auto &kv : recv_elems)
+   {
+      std::sort(kv.second.begin(), kv.second.end());
+      kv.second.erase(std::unique(kv.second.begin(), kv.second.end()),
+                      kv.second.end());
+   }
+
    for (int i = 0, last_rank = -1; i < send_elems.Size(); i++)
    {
       Connection &c = send_elems[i];
@@ -1175,10 +1198,173 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       }
    }
 
+
+   // In 3D some extra orientation data structures can be needed.
+   if (Dim == 3)
+   {
+      // Populates face_nbr_el_to_face, always needed.
+      pmesh.BuildFaceNbrElementToFaceTable();
+
+      if (face_nbr_w_tri_faces)
+      {
+         // There are face neighbor elements with triangular faces, need to
+         // perform communication to ensure the orientation is valid.
+         using RankToOrientation = std::map<int, std::vector<std::array<int, 6>>>;
+         constexpr std::array<int, 6> unset_ori{{-1,-1,-1,-1,-1,-1}};
+         const int rank = pmesh.GetMyRank();
+
+         // Loop over send elems, compute the orientation and place in the buffer to
+         // send to each processor. Note elements are lexicographically sorted
+         // with rank and element number, and this ordering holds across processors.
+         RankToOrientation send_rank_to_face_neighbor_orientations;
+         Array<int> orientations, faces;
+
+         // send_elems goes from rank of the receiving processor, to the index
+         // of the face neighbor element on this processor.
+         for (const auto &se : send_elems)
+         {
+            const auto &true_rank = pmesh.face_nbr_group[se.from];
+            pmesh.GetElementFaces(se.to, faces, orientations);
+
+            // Place a new entry of unset orientations
+            send_rank_to_face_neighbor_orientations[true_rank].emplace_back(unset_ori);
+
+            // Copy the entries, any unset faces will remain -1.
+            std::copy(orientations.begin(), orientations.end(),
+                      send_rank_to_face_neighbor_orientations[true_rank].back().begin());
+         }
+
+         // Initialize the receive buffers and resize to match the expected
+         // number of elements coming in. The copy ensures the appropriate rank
+         // pairings are in place, and for a purely conformal interface, the
+         // resize is a no-op.
+         auto recv_rank_to_face_neighbor_orientations =
+            send_rank_to_face_neighbor_orientations;
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            kv.second.resize(recv_elems[kv.first].size());
+         }
+
+         // For asynchronous send/recv, will use arrays of requests to monitor the
+         // status of the connections.
+         std::vector<MPI_Request> send_requests, recv_requests;
+         std::vector<MPI_Status> status(nranks);
+
+         // NOTE: This is CRITICAL, to ensure the addresses of these requests
+         // do not change between the send/recv and the wait.
+         send_requests.reserve(nranks);
+         recv_requests.reserve(nranks);
+
+         // Shared face communication is bidirectional -> any rank to whom
+         // orientations must be sent, will need to send orientations back.
+         // The orientation data is contiguous because std::array<int,6> is an
+         // aggregate.
+
+         // Loop over each communication pairing, and dispatch the buffer loaded
+         // with  all the orientation data.
+         for (const auto &kv : send_rank_to_face_neighbor_orientations)
+         {
+            send_requests.emplace_back(); // instantiate a request for tracking.
+
+            // low rank sends on low, high rank sends on high.
+            const int send_tag = (rank < kv.first)
+                                 ? std::min(rank, kv.first)
+                                 : std::max(rank, kv.first);
+            MPI_Isend(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, send_tag, pmesh.MyComm, &send_requests.back());
+         }
+
+         // Loop over the communication pairing again, and receive the
+         // symmetric buffer from the other processor.
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            recv_requests.emplace_back(); // instantiate a request for tracking
+
+            // low rank receives on high, high rank receives on low.
+            const int recv_tag = (rank < kv.first)
+                                 ? std::max(rank, kv.first)
+                                 : std::min(rank, kv.first);
+            MPI_Irecv(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, recv_tag, pmesh.MyComm, &recv_requests.back());
+         }
+
+         // Wait until all receive buffers are full before beginning to process.
+         MPI_Waitall(int(recv_requests.size()), recv_requests.data(), status.data());
+
+         pmesh.face_nbr_el_ori.reset(new Table(pmesh.face_nbr_elements.Size(), 6));
+         int elem = 0;
+         for (const auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            // All elements associated to this face-neighbor rank
+            for (const auto &eo : kv.second)
+            {
+               std::copy(eo.begin(), eo.end(), pmesh.face_nbr_el_ori->GetRow(elem));
+               ++elem;
+            }
+         }
+         pmesh.face_nbr_el_ori->Finalize();
+
+         // Must wait for all send buffers to be released before the scope closes.
+         MPI_Waitall(int(send_requests.size()), send_requests.data(), status.data());
+      }
+   }
    // NOTE: this function skips ParMesh::send_face_nbr_vertices and
    // ParMesh::face_nbr_vertices_offset, these are not used outside of ParMesh
 }
 
+void ParNCMesh::ComputeGhostBoundaryElements(const ParMesh &mesh)
+{
+   // 1D cannot have ghost boundary elements
+   if (Dim == 1) { return; }
+
+   // ParNCMesh requires additional treatment of "ghost boundary elements" in
+   // the scenario where a parent face has only ghost children. A local mesh
+   // will fail to identify essential boundary conditions without the use of
+   // these ghost boundary elements, as they will not be added into the list of
+   // local boundary elements, whose masters will eventually be found.
+
+   ghost_boundary_elements.clear();
+   for (int n = NElements; n < NGhostElements + NElements; ++n)
+   {
+      const auto &nc_elem = elements[leaf_elements[n]];
+
+      const int * const node = nc_elem.node;
+      GeomInfo& gi = GI[(int) nc_elem.geom];
+
+      // Loop over faces and find those that are masters of internal boundaries
+      for (int k = 0; k < gi.nf; ++k)
+      {
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+
+         if (id >= 0 && faces[id].Boundary() && faces[id].index >= NFaces)
+         {
+            // Found a ghost face, and it is a boundary element.
+            // Need to check if it's a slave, and if it's internal.
+            const auto &face = faces[id];
+
+            // A conformal face
+            if (face.elem[0] >= 0 && face.elem[1] >= 0) { continue; }
+
+            // A ghost face not indexed by the mesh -> no useful information
+            if (face.index >= mesh.faces_info.Size()) { continue; }
+
+            MFEM_ASSERT(face.index >= 0, face.index);
+            const auto &finfo = mesh.faces_info[face.index];
+            if (mesh.IsSlaveFace(finfo)) // slave face
+            {
+               int master_face = mesh.GetNCMasterFaceIndex(finfo.NCFace);
+               if (master_face < mesh.GetNFaces())
+               {
+                  ghost_boundary_elements[face.attribute].insert(master_face);
+               }
+            }
+         }
+      }
+   }
+}
+
 void ParNCMesh::ClearAuxPM()
 {
    for (int i = 0; i < aux_pm_store.Size(); i++)
@@ -1819,10 +2005,9 @@ void ParNCMesh::RedistributeElements(Array<int> &new_ranks, int target_elements,
    NeighborElementRankMessage::RecvAll(recv_ghost_ranks, MyComm);
 
    // read new ranks for the ghost layer from messages received
-   NeighborElementRankMessage::Map::iterator it;
-   for (it = recv_ghost_ranks.begin(); it != recv_ghost_ranks.end(); ++it)
+   for (auto &kv : recv_ghost_ranks)
    {
-      NeighborElementRankMessage &msg = it->second;
+      NeighborElementRankMessage &msg = kv.second;
       for (int i = 0; i < msg.Size(); i++)
       {
          int ghost_index = elements[msg.elements[i]].index;
@@ -2349,9 +2534,8 @@ void ParNCMesh::AdjustMeshIds(Array<MeshId> ids[], int rank)
 
    // find vertices/edges of master faces shared with 'rank', and modify their
    // MeshIds so their element/local matches the element of the master face
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const MeshId &face_id : shared_faces.masters)
    {
-      const MeshId &face_id = shared_faces.masters[i];
       if (contains_rank[entity_pmat_group[2][face_id.index]])
       {
          int v[4], e[4], eo[4], pos, k;
diff --git a/mesh/pncmesh.hpp b/mesh/pncmesh.hpp
index 03689dfc4..9c425b631 100644
--- a/mesh/pncmesh.hpp
+++ b/mesh/pncmesh.hpp
@@ -108,9 +108,7 @@ public:
        passed. */
    void Rebalance(const Array<int> *custom_partition = NULL);
 
-
    // interface for ParFiniteElementSpace
-
    int GetNElements() const { return NElements; }
 
    int GetNGhostVertices() const { return NGhostVertices; }
@@ -141,8 +139,8 @@ public:
       return (index < NFaces) ? face_orient[index] : 0;
    }
 
-   typedef short GroupId;
-   typedef std::vector<int> CommGroup;
+   using GroupId = short;
+   using CommGroup = std::vector<int>;
 
    /// Return vertex/edge/face ('entity' == 0/1/2, resp.) owner.
    GroupId GetEntityOwnerId(int entity, int index)
@@ -248,6 +246,17 @@ public:
        The debug mesh will have element attributes set to element rank + 1. */
    void GetDebugMesh(Mesh &debug_mesh) const;
 
+   /**
+    * @brief Get the Ghost Boundary Elements object, explicitly behind a const
+    * interface to avoid external modification. See ComputeGhostBoundaryElements
+    * for information on ghost boundary elements and their importance.
+    *
+    * @return std::map<int, std::set<int>> Container from boundary attribute
+    * value to set of codimension 1 objects that are parents of ghost
+    * children with this attribute.
+    */
+   std::map<int, std::set<int>> GetGhostBoundaryElements() const { return ghost_boundary_elements; }
+
 protected: // interface for ParMesh
 
    friend class ParMesh;
@@ -261,6 +270,34 @@ protected: // interface for ParMesh
        communication. */
    void GetFaceNeighbors(class ParMesh &pmesh);
 
+   /**
+    * @brief Given a ParMesh with all FaceNbrData computed, populate the
+    * ghost_boundary_elements.
+    * @details The ghost_boundary_elements container is accessed via
+    * GetGhostBoundaryElements, and represents a collection of parent faces that
+    * are coincident to a given boundary element, but whose child faces are all
+    * ghosts. Boundary elements must be child faces or conformal faces, in
+    * order to calculate functionals and boundary condition integrals. However,
+    * essential boundary conditions, must be imposed via the parent faces, in
+    * order to correctly constrain all face internal DOFs. This is accomplished
+    * by traversing from child faces to parent faces, but these dofs cannot be
+    * constrained if the parent face is a ghost.
+    *
+    * The corollary to this is that a parent face with only ghost children, will
+    * never be marked as part of an internal boundary during the usual boundary
+    * element traversal. Consequently, the ghost boundary elements keep track of
+    * these ghost boundary elements, by collecting them once the face neighbor
+    * data has been exchanged. A ParFiniteElementSpace is then able to loop over
+    * these DOF additionally during GetEssentialVDofs.
+    *
+    * NOTE: Users do not need to call this method, it will be called during
+    * ExchangeFaceNbrData once the relevant predicate information has been
+    * established.
+    *
+    * @param mesh The mesh for whom the ghost boundary elements should be
+    * established.
+    */
+   void ComputeGhostBoundaryElements(const ParMesh &mesh);
 
 protected: // implementation
 
@@ -299,6 +336,13 @@ protected: // implementation
    Array<int> ghost_layer;    ///< list of elements whose 'element_type' == 2.
    Array<int> boundary_layer; ///< list of type 3 elements
 
+   /// Master face internal boundary elements that are attached to the processor
+   /// boundary which cannot be found by looping over the boundary elements alone.
+   /// This variable maps from boundary attributes, to a collection of boundary
+   /// faces (i.e. codimension 1 objects) that are parents of ghost child faces
+   /// with this attribute.
+   std::map<int, std::set<int>> ghost_boundary_elements;
+
    void Update() override;
 
    /// Return the processor number for a global element number.
diff --git a/mesh/point.cpp b/mesh/point.cpp
index ecf6a4dd0..473655b11 100644
--- a/mesh/point.cpp
+++ b/mesh/point.cpp
@@ -21,12 +21,24 @@ Point::Point( const int *ind, int attr ) : Element(Geometry::POINT)
    indices[0] = ind[0];
 }
 
-void Point::GetVertices( Array<int> &v ) const
+void Point::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 1 );
+   v.SetSize(1);
    v[0] = indices[0];
 }
 
+void Point::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 1, "!");
+   indices[0] = v[0];
+}
+
+
+void Point::SetVertices(const int *ind)
+{
+   indices[0] = ind[0];
+}
+
 PointFiniteElement PointFE;
 
 }
diff --git a/mesh/point.hpp b/mesh/point.hpp
index f154e205e..be00c9c84 100644
--- a/mesh/point.hpp
+++ b/mesh/point.hpp
@@ -33,33 +33,40 @@ public:
    Point( const int *ind, int attr = -1 );
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::POINT; }
+   Type GetType() const override { return Element::POINT; }
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices( Array<int> &v ) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
 
-   virtual int * GetVertices () { return indices; }
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int GetNVertices() const { return 1; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNEdges() const { return (0); }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   int GetNVertices() const override { return 1; }
+
+   int GetNEdges() const override { return (0); }
+
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Point (indices, attribute); }
 
-   virtual ~Point() { }
+   virtual ~Point() = default;
 };
 
 class PointFiniteElement;
diff --git a/mesh/pyramid.cpp b/mesh/pyramid.cpp
index d67841564..f64f2afe9 100644
--- a/mesh/pyramid.cpp
+++ b/mesh/pyramid.cpp
@@ -48,10 +48,13 @@ void Pyramid::SetVertices(const int *ind)
 void Pyramid::GetVertices(Array<int> &v) const
 {
    v.SetSize(5);
-   for (int i = 0; i < 5; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 5, v.begin());
+}
+
+void Pyramid::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 5, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Pyramid::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/pyramid.hpp b/mesh/pyramid.hpp
index 8e171a31d..adcc540ed 100644
--- a/mesh/pyramid.hpp
+++ b/mesh/pyramid.hpp
@@ -37,38 +37,42 @@ public:
            int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::PYRAMID; }
+   Type GetType() const override { return Element::PYRAMID; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 5; }
+   int GetNVertices() const override { return 5; }
 
-   virtual int GetNEdges() const { return 8; }
+   int GetNEdges() const override { return 8; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return ( ( fi < 1 ) ? 4 : 3); }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Pyramid(indices, attribute); }
 
-   virtual ~Pyramid() { }
+   virtual ~Pyramid() = default;
 };
 
 extern class LinearPyramidFiniteElement PyramidFE;
diff --git a/mesh/quadrilateral.cpp b/mesh/quadrilateral.cpp
index 1a69cf179..29fa3bbe1 100644
--- a/mesh/quadrilateral.cpp
+++ b/mesh/quadrilateral.cpp
@@ -37,19 +37,20 @@ Quadrilateral::Quadrilateral( int ind1, int ind2, int ind3, int ind4,
 
 void Quadrilateral::SetVertices(const int *ind)
 {
-   for (int i=0; i<4; i++)
-   {
-      indices[i] = ind[i];
-   }
+   std::copy(ind, ind + 4, indices);
 }
 
-void Quadrilateral::GetVertices( Array<int> &v ) const
+void Quadrilateral::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 4 );
-   for (int i=0; i<4; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(4);
+   std::copy(indices, indices + 4, v.begin());
+}
+
+
+void Quadrilateral::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/quadrilateral.hpp b/mesh/quadrilateral.hpp
index 9f6b9a442..70fcbfdcc 100644
--- a/mesh/quadrilateral.hpp
+++ b/mesh/quadrilateral.hpp
@@ -36,37 +36,41 @@ public:
    Quadrilateral(int ind1, int ind2, int ind3, int ind4, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::QUADRILATERAL; }
+   Type GetType() const override { return Element::QUADRILATERAL; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (4); }
+   int GetNEdges() const override { return (4); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Quadrilateral(indices, attribute); }
 
-   virtual ~Quadrilateral() { }
+   virtual ~Quadrilateral() = default;
 };
 
 extern MFEM_EXPORT class BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/segment.cpp b/mesh/segment.cpp
index 717245907..910614770 100644
--- a/mesh/segment.cpp
+++ b/mesh/segment.cpp
@@ -37,13 +37,16 @@ void Segment::SetVertices(const int *ind)
    indices[1] = ind[1];
 }
 
-void Segment::GetVertices( Array<int> &v ) const
+void Segment::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 2 );
-   for (int i=0; i<2; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(2);
+   std::copy(indices, indices + 2, v.begin());
+}
+
+void Segment::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 2, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Linear1DFiniteElement SegmentFE;
diff --git a/mesh/segment.hpp b/mesh/segment.hpp
index 6ca918758..aafc4909f 100644
--- a/mesh/segment.hpp
+++ b/mesh/segment.hpp
@@ -35,37 +35,41 @@ public:
    /// Constructs triangle by specifying the indices and the attribute.
    Segment(int ind1, int ind2, int attr = 1);
 
-   /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
-
    /// Return element's type.
-   virtual Type GetType() const { return Element::SEGMENT; }
+   Type GetType() const override { return Element::SEGMENT; }
+
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 2; }
+   int GetNVertices() const override { return 2; }
 
-   virtual int GetNEdges() const { return (0); }
+   int GetNEdges() const override { return 0; }
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Segment(indices, attribute); }
 
-   virtual ~Segment() { }
+   virtual ~Segment() = default;
 };
 
 class Linear1DFiniteElement;
diff --git a/mesh/tetrahedron.cpp b/mesh/tetrahedron.cpp
index 7c9c8de7a..22eecbd42 100644
--- a/mesh/tetrahedron.cpp
+++ b/mesh/tetrahedron.cpp
@@ -327,10 +327,13 @@ void Tetrahedron::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Tetrahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(4);
-   for (int i = 0; i < 4; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 4, v.begin());
+}
+
+void Tetrahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Element *Tetrahedron::Duplicate(Mesh *m) const
diff --git a/mesh/tetrahedron.hpp b/mesh/tetrahedron.hpp
index b72e5db55..8fc64481d 100644
--- a/mesh/tetrahedron.hpp
+++ b/mesh/tetrahedron.hpp
@@ -56,7 +56,7 @@ public:
              int ref_flag = 0);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TETRAHEDRON; }
+   Type GetType() const override { return Element::TETRAHEDRON; }
 
    void  ParseRefinementFlag(int refinement_edges[2], int &type,
                              int &flag) const;
@@ -69,52 +69,56 @@ public:
    void SetRefinementFlag(int rf) { refinement_flag = rf; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
-
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
        because the order may be used later for setting the edges. **/
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length);
+   void MarkEdge(const DSTable &v_to_v, const int *length) override;
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
+
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (6); }
+   int GetNEdges() const override { return (6); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 3; return 4; }
 
-   virtual int GetNFaces() const { return 4; }
+   int GetNFaces() const override { return 4; }
 
-   virtual int GetNFaceVertices(int) const { return 3; }
+   int GetNFaceVertices(int) const override { return 3; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const;
+   Element *Duplicate(Mesh *m) const override;
 
-   virtual ~Tetrahedron() { }
+   virtual ~Tetrahedron() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/triangle.cpp b/mesh/triangle.cpp
index 5ce32cb31..eb7493398 100644
--- a/mesh/triangle.cpp
+++ b/mesh/triangle.cpp
@@ -188,10 +188,13 @@ void Triangle::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Triangle::GetVertices(Array<int> &v) const
 {
    v.SetSize(3);
-   for (int i = 0; i < 3; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 3, v.begin());
+}
+
+void Triangle::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 3, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 } // namespace mfem
diff --git a/mesh/triangle.hpp b/mesh/triangle.hpp
index 363bd4503..0724c5082 100644
--- a/mesh/triangle.hpp
+++ b/mesh/triangle.hpp
@@ -39,13 +39,10 @@ public:
    Triangle(int ind1, int ind2, int ind3, int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TRIANGLE; }
+   Type GetType() const override { return Element::TRIANGLE; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
-
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
@@ -55,46 +52,54 @@ public:
    static void MarkEdge(int *indices, const DSTable &v_to_v, const int *length);
 
    /// Mark the longest edge by assuming/changing the order of the vertices.
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length)
+   void MarkEdge(const DSTable &v_to_v, const int *length) override
    { MarkEdge(indices, v_to_v, length); }
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
+
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
+
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int *GetVertices() { return indices; }
 
-   virtual int GetNVertices() const { return 3; }
+   int GetNVertices() const override { return 3; }
 
-   virtual int GetNEdges() const { return (3); }
+   int GetNEdges() const override { return (3); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { MFEM_ABORT("not implemented"); return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Triangle(indices, attribute); }
 
-   virtual ~Triangle() { }
+   virtual ~Triangle() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/wedge.cpp b/mesh/wedge.cpp
index 898da7653..b1aea933d 100644
--- a/mesh/wedge.cpp
+++ b/mesh/wedge.cpp
@@ -50,10 +50,13 @@ void Wedge::SetVertices(const int *ind)
 void Wedge::GetVertices(Array<int> &v) const
 {
    v.SetSize(6);
-   for (int i = 0; i < 6; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 6, v.begin());
+}
+
+void Wedge::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 6, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Wedge::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/wedge.hpp b/mesh/wedge.hpp
index fb8583f8e..2eae6d104 100644
--- a/mesh/wedge.hpp
+++ b/mesh/wedge.hpp
@@ -37,38 +37,42 @@ public:
          int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::WEDGE; }
+   Type GetType() const override { return Element::WEDGE; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 6; }
+   int GetNVertices() const override { return 6; }
 
-   virtual int GetNEdges() const { return 9; }
+   int GetNEdges() const override { return 9; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return (fi < 2) ? 3 : 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Wedge(indices, attribute); }
 
-   virtual ~Wedge() { }
+   virtual ~Wedge() = default;
 };
 
 extern MFEM_EXPORT class LinearWedgeFiniteElement WedgeFE;
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index dc0e9fea8..678abb706 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -43,6 +43,7 @@ set(UNIT_TESTS_SRCS
   linalg/test_operator.cpp
   linalg/test_vector.cpp
   mesh/test_face_orientations.cpp
+  mesh/mesh_test_utils.cpp
   mesh/test_fms.cpp
   mesh/test_mesh.cpp
   mesh/test_ncmesh.cpp
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index 673653596..1077d998a 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -385,17 +385,17 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    }
    int dim = mesh.Dimension();
 
-   FiniteElementCollection *fec;
+   std::unique_ptr<FiniteElementCollection> fec;
    if (prob)
    {
       auto basis = prob==3 ? BasisType::Positive : BasisType::GaussLobatto;
-      fec = new L2_FECollection(order, dim, basis);
+      fec.reset(new L2_FECollection(order, dim, basis));
    }
    else
    {
-      fec = new H1_FECollection(order, dim);
+      fec.reset(new H1_FECollection(order, dim));
    }
-   FiniteElementSpace fespace(&mesh, fec);
+   FiniteElementSpace fespace(&mesh, fec.get());
 
    L2_FECollection vel_fec(order, dim, BasisType::GaussLobatto);
    FiniteElementSpace vel_fespace(&mesh, &vel_fec, dim);
@@ -405,21 +405,21 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    BilinearForm k_pa(&fespace);
    BilinearForm k_fa(&fespace);
 
-   VectorCoefficient *vel_coeff;
-   Coefficient *rho;
+   std::unique_ptr<VectorCoefficient> vel_coeff;
+   std::unique_ptr<Coefficient> rho;
 
    // prob: 0: CG, 1: DG continuous coeff, 2: DG discontinuous coeff
    if (prob >= 2)
    {
       vel_gf.Randomize(1);
-      vel_coeff = new VectorGridFunctionCoefficient(&vel_gf);
+      vel_coeff.reset(new VectorGridFunctionCoefficient(&vel_gf));
       rho_gf.Randomize(1);
-      rho = new GridFunctionCoefficient(&rho_gf);
+      rho.reset(new GridFunctionCoefficient(&rho_gf));
    }
    else
    {
-      vel_coeff = new VectorFunctionCoefficient(dim, velocity_function);
-      rho = new ConstantCoefficient(1.0);
+      vel_coeff.reset(new VectorFunctionCoefficient(dim, velocity_function));
+      rho.reset(new ConstantCoefficient(1.0));
    }
 
 
@@ -451,10 +451,6 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    y_pa -= y_fa;
 
    REQUIRE(y_pa.Norml2() < 1.e-12);
-
-   delete vel_coeff;
-   delete rho;
-   delete fec;
 }
 
 // Basic unit tests for convection
@@ -468,7 +464,7 @@ TEST_CASE("PA Convection", "[PartialAssembly], [CUDA]")
    auto prob = GENERATE(0, 1, 2, 3);
    auto order = GENERATE(2);
    // refinement > 0 => Non-conforming mesh
-   auto refinement = GENERATE(0,1);
+   auto refinement = GENERATE(0, 1);
 
    SECTION("2D")
    {
diff --git a/tests/unit/mesh/mesh_test_utils.cpp b/tests/unit/mesh/mesh_test_utils.cpp
new file mode 100644
index 000000000..65fb2e01d
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.cpp
@@ -0,0 +1,207 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mesh_test_utils.hpp"
+
+namespace mfem
+{
+
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction sol(&fes);
+
+   ConstantCoefficient one(1.0);
+   BilinearForm a(&fes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+
+   LinearForm b(&fes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(mesh.bdr_attributes.Max() > 0);
+
+   // Mark all boundaries essential
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      bdr_attr_is_ess[mesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   fes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   REQUIRE(ess_tdof_list.Size() > 0);
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B);
+
+   // Solve the system
+   CG(*A, B, X, 2, 1000, 1e-20, 0.0);
+
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   bool satisfy_bc = true;
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+   return ess_tdof_list.Size();
+};
+
+#ifdef MFEM_USE_MPI
+
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   ParFiniteElementSpace pfes(&pmesh, &fec);
+
+   ParGridFunction sol(&pfes);
+
+   ConstantCoefficient one(1.0);
+   ParBilinearForm a(&pfes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+   ParLinearForm b(&pfes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(pmesh.bdr_attributes.Max() > 0);
+
+   Array<int> bdr_attr_is_ess(pmesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      CAPTURE(disabled_boundary_attribute);
+      bdr_attr_is_ess[pmesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   int num_ess_dof = ess_tdof_list.Size();
+   MPI_Allreduce(MPI_IN_PLACE, &num_ess_dof, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   REQUIRE(num_ess_dof > 0);
+
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   const bool copy_interior = true; // interior(sol) --> interior(X)
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B, copy_interior);
+
+   // Solve the system
+   CGSolver cg(MPI_COMM_WORLD);
+   // HypreBoomerAMG preconditioner;
+   cg.SetMaxIter(2000);
+   cg.SetRelTol(1e-12);
+   cg.SetPrintLevel(0);
+   cg.SetOperator(*A);
+   // cg.SetPreconditioner(preconditioner);
+   cg.Mult(B, X);
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   // Initialize the bdr_dof to be checked
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   bool satisfy_bc = true;
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+};
+
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition)
+{
+   auto pmesh = std::unique_ptr<ParMesh>(new ParMesh(MPI_COMM_WORLD, smesh,
+                                                     partition.get()));
+
+   int nbe = pmesh->GetNBE();
+   MPI_Allreduce(MPI_IN_PLACE, &nbe, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(nbe == smesh.GetNBE());
+   return pmesh;
+};
+
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared)
+{
+   int e1, e2;
+   pmesh.GetFaceElements(f, &e1, &e2);
+   int inf1, inf2, ncface;
+   pmesh.GetFaceInfos(f, &inf1, &inf2, &ncface);
+
+   if (e2 < 0 && inf2 >=0)
+   {
+      // Shared face on processor boundary -> Need to discover the neighbor
+      // attributes
+      auto FET = pmesh.GetSharedFaceTransformations(local_to_shared.at(f));
+
+      if (FET->Elem1->Attribute != FET->Elem2->Attribute && f < pmesh.GetNumFaces())
+      {
+         // shared face on domain attribute boundary, which this rank owns
+         return true;
+      }
+   }
+
+   if (e2 >= 0 && pmesh.GetAttribute(e1) != pmesh.GetAttribute(e2))
+   {
+      // local face on domain attribute boundary
+      return true;
+   }
+   return false;
+};
+
+#endif
+
+} // namespace mfem
diff --git a/tests/unit/mesh/mesh_test_utils.hpp b/tests/unit/mesh/mesh_test_utils.hpp
new file mode 100644
index 000000000..e4088a788
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.hpp
@@ -0,0 +1,78 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_MESH_TEST_UTILS
+#define MFEM_MESH_TEST_UTILS
+
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+namespace mfem
+{
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a serial mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The SERIAL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute = -1);
+
+#ifdef MFEM_USE_MPI
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a parallel mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The PARALLEL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute = -1);
+
+/**
+ * @brief Check that a Parmesh generates the same number of boundary elements as
+ * the serial mesh.
+ *
+ * @param smesh Serial mesh to be built from and compared against
+ * @param partition Optional partition
+ * @return std::unique_ptr<ParMesh> Pointer to the mesh in question.
+ */
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition = nullptr);
+
+/**
+ * @brief Helper function to track if a face index is internal
+ *
+ * @param pmesh The mesh containing the face
+ * @param f The face index
+ * @param local_to_shared A map from local faces to shared faces
+ * @return true the face is between domain attributes (and owned by this rank)
+ * @return false the face is not between domain attributes or not owned by this rank
+ */
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared);
+
+#endif
+
+} // namespace mfem
+
+#endif // MFEM_MESH_TEST_UTILS
\ No newline at end of file
diff --git a/tests/unit/mesh/test_ncmesh.cpp b/tests/unit/mesh/test_ncmesh.cpp
index dba0b4507..88b428d0b 100644
--- a/tests/unit/mesh/test_ncmesh.cpp
+++ b/tests/unit/mesh/test_ncmesh.cpp
@@ -10,6 +10,7 @@
 // CONTRIBUTING.md for details.
 
 #include "mfem.hpp"
+#include "mesh_test_utils.hpp"
 #include "unit_tests.hpp"
 
 namespace mfem
@@ -113,7 +114,6 @@ TEST_CASE("NCMesh PA diagonal", "[NCMesh]")
 
 } // test case
 
-
 TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -145,7 +145,6 @@ TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
    REQUIRE(summed_volume == MFEM_Approx(original_volume));
 } // test case
 
-
 TEST_CASE("NCMesh 3D Derefined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -368,7 +367,6 @@ void CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
       x = 0.0;
 
       double pnorm = x.ComputeL2Error(rhs_coef);
-
       b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
       b.Assemble();
 
@@ -397,7 +395,6 @@ void CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
    CHECK(std::abs(serror - perror) < test_tol);
 };
 
-
 TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
 {
    constexpr int refining_rank = 0;
@@ -764,6 +761,1298 @@ TEST_CASE("PNQ2PureTetHexPri",  "[Parallel], [NCMesh]")
    }
 } // test case
 
+/**
+ * @brief Test GetVectorValue on face neighbor elements for nonconformal meshes
+ *
+ * @param smesh The serial mesh to start from
+ * @param nc_level Depth of refinement on processor boundaries
+ * @param skip Refine every "skip" processor boundary element
+ * @param use_ND Whether to use Nedelec elements (which are sensitive to orientation)
+ */
+void TestVectorValueInVolume(Mesh &smesh, int nc_level, int skip, bool use_ND)
+{
+   auto vector_exact_soln = [](const Vector& x, Vector& v)
+   {
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      v = (d -= x);
+   };
+
+   smesh.Finalize();
+   smesh.EnsureNCMesh(true); // uncomment this to trigger the failure
+
+   auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+   // Apply refinement on face neighbors to achieve a given nc level mismatch.
+   for (int i = 0; i < nc_level; ++i)
+   {
+      // To refine the face neighbors, need to know where they are.
+      pmesh.ExchangeFaceNbrData();
+      Array<int> elem_to_refine;
+      // Refine only on odd ranks.
+      if ((Mpi::WorldRank() + 1) % 2 == 0)
+      {
+         // Refine a subset of all shared faces. Using a subset helps to
+         // mix in conformal faces with nonconformal faces.
+         for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+         {
+            if (n % skip != 0) { continue; }
+            const int local_face = pmesh.GetSharedFace(n);
+            const auto &face_info = pmesh.GetFaceInformation(local_face);
+            REQUIRE(face_info.IsShared());
+            REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+            elem_to_refine.Append(face_info.element[0].index);
+         }
+      }
+      pmesh.GeneralRefinement(elem_to_refine);
+   }
+
+   // Do not rebalance again! The test is also checking for nc refinements
+   // along the processor boundary.
+
+   // Create a grid function of the mesh coordinates
+   pmesh.ExchangeFaceNbrData();
+   pmesh.EnsureNodes();
+   REQUIRE(pmesh.OwnsNodes());
+   GridFunction * const coords = pmesh.GetNodes();
+   dynamic_cast<ParGridFunction *>(pmesh.GetNodes())->ExchangeFaceNbrData();
+
+   // Project the linear function onto the mesh. Quadratic ND tetrahedral
+   // elements are the first to require face orientations.
+   const int order = 2, dim = 3;
+   std::unique_ptr<FiniteElementCollection> fec;
+   if (use_ND)
+   {
+      fec = std::unique_ptr<ND_FECollection>(new ND_FECollection(order, dim));
+   }
+   else
+   {
+      fec = std::unique_ptr<RT_FECollection>(new RT_FECollection(order, dim));
+   }
+   ParFiniteElementSpace pnd_fes(&pmesh, fec.get());
+
+   ParGridFunction psol(&pnd_fes);
+
+   VectorFunctionCoefficient func(3, vector_exact_soln);
+   psol.ProjectCoefficient(func);
+   psol.ExchangeFaceNbrData();
+
+   mfem::Vector value(3), exact(3), position(3);
+   const IntegrationRule &ir = mfem::IntRules.Get(Geometry::Type::TETRAHEDRON,
+                                                  order + 1);
+
+   // Check that non-ghost elements match up on the serial and parallel spaces.
+   for (int n = 0; n < pmesh.GetNE(); ++n)
+   {
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         coords->GetVectorValue(n, ip, position);
+         psol.GetVectorValue(n, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+
+   // Loop over face neighbor elements and check the vector values match in the
+   // face neighbor elements.
+   for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+   {
+      const int local_face = pmesh.GetSharedFace(n);
+      const auto &face_info = pmesh.GetFaceInformation(local_face);
+      REQUIRE(face_info.IsShared());
+      REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+
+      auto &T = *pmesh.GetFaceNbrElementTransformation(face_info.element[1].index);
+
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         T.SetIntPoint(&ip);
+         coords->GetVectorValue(T, ip, position);
+         psol.GetVectorValue(T, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+}
+
+TEST_CASE("GetVectorValueInFaceNeighborElement", "[Parallel], [NCMesh]")
+{
+   // The aim of this test is to verify the correct behaviour of the
+   // GetVectorValue method when called on face neighbor elements in a non
+   // conforming mesh.
+   auto smesh = Mesh("../../data/beam-tet.mesh");
+
+   for (int nc_level : {0,1,2,3})
+   {
+      for (int skip : {1,2})
+      {
+         for (bool use_ND : {false, true})
+         {
+            TestVectorValueInVolume(smesh, nc_level, skip, use_ND);
+         }
+      }
+   }
+}
+
+TEST_CASE("InteriorBoundaryReferenceTets", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNBE() == 4);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Nonconforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 3 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rank 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineTetRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-tet.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   smesh.EnsureNCMesh(true);
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+TEST_CASE("InteriorBoundaryReferenceCubes", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+
+   REQUIRE(smesh.GetNBE() == 6);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   // Throw away the NCMesh, will restart NC later.
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 5 + 1);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Conforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 5 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (5 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rank 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineHexRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-hex.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
 #endif // MFEM_USE_MPI
 
+TEST_CASE("ReferenceCubeInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+
+   CheckPoisson(smesh, p);
+
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   int without_internal, with_internal;
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 1); break;
+      case 3:
+         CHECK(with_internal == without_internal + 4); break;
+   }
+
+   auto ref_type = char(GENERATE(//Refinement::Y, Refinement::Z, Refinement::YZ,
+                           Refinement::XYZ));
+
+   for (auto ref : {0,1})
+   {
+      refs[0].index = ref;
+
+      auto ssmesh = Mesh(smesh);
+
+      CAPTURE(ref_type);
+
+      // Now NC refine one of the attached elements, this should result in 2
+      // internal boundary elements.
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      if (ref_type == 2 /* Y */ || ref_type == 4 /* Z */)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 2 /* internal boundaries */
+               + (2 * 4) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 6)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 7)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3 + 4 * 2) /* external boundaries of refined elements */);
+      }
+      else
+      {
+         MFEM_ABORT("!");
+      }
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == (ref_type <= 4 ? 2 : 4));
+
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      without_internal = CheckPoisson(ssmesh, p,
+                                      ssmesh.bdr_attributes.Max()); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      // All slaves dofs that are introduced on the face are constrained by
+      // the master dofs, thus the additional constraints on the internal
+      // boundary are purely on the master face, which matches the initial
+      // unrefined case.
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal + 1); break;
+         case 3:
+            CHECK(with_internal == without_internal + 4); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedCubesInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.UniformRefinement();
+
+   // Introduce four internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   int without_internal = CheckPoisson(smesh, p,
+                                       7); // Exclude the internal boundary
+   int with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // There should now be 16 internal boundary elements, where there were 4 before
+
+   CHECK(smesh.GetNBE() == 5 * 4 /* external boundaries of unrefined domain  */
+         + 4 * 4 /* internal boundaries */
+         + 5 * 16 /* external boundaries of refined elements */);
+
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 16);
+
+
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+}
+
+TEST_CASE("ReferenceTetInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal); break;
+      case 3:
+         CHECK(with_internal == without_internal + 1); break;
+   }
+
+   // Now NC refine one of the attached elements, this should result in 2
+   // internal boundary elements.
+   for (int ref : {0, 1})
+   {
+      refs[0].index = ref;
+      refs[0].ref_type = Refinement::XYZ;
+      auto ssmesh = Mesh(smesh);
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(ssmesh.GetNBE() == 3 /* external boundaries of unrefined element  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined element */);
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == 4);
+
+      without_internal = CheckPoisson(ssmesh, p, 5); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal); break;
+         case 3:
+            CHECK(with_internal == without_internal + 1); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedTetsInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.UniformRefinement();
+
+   CHECK(smesh.GetNBE() == 2 * 3 * 4);
+
+   // Introduce internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+
+   // Now NC refine all elements with the 2 attribute.
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   // There should now be four internal boundary elements, where there was one
+   // before.
+   CHECK(smesh.GetNBE() == 3 * 4 /* external boundaries of unrefined elements  */
+         + 4 * 4 /* internal boundaries */
+         + (3 * 4 * 4) /* external boundaries of refined elements */);
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 4 * 4);
+
+   without_internal = CheckPoisson(smesh, p, 5); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+}
+
+TEST_CASE("PoissonOnReferenceCubeNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   // Check that Poisson can be solved on the domain
+   CheckPoisson(smesh, p);
+
+   auto ref_type = char(GENERATE(Refinement::X, Refinement::Y, Refinement::Z,
+                                 Refinement::XY, Refinement::XZ, Refinement::YZ,
+                                 Refinement::XYZ));
+   CAPTURE(ref_type);
+   for (auto refined_elem : {0}) // The left or the right element
+   {
+      refs[0].index = refined_elem;
+      auto ssmesh = Mesh(smesh);
+
+      // Now NC refine one of the attached elements
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("PoissonOnReferenceTetNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   CheckPoisson(smesh, p);
+
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Check that Poisson can be solved on the pair of tets
+   CheckPoisson(smesh, p);
+
+   auto nc = GENERATE(false, true);
+   CAPTURE(nc);
+
+   smesh.EnsureNCMesh(GENERATE(false, true));
+
+   for (auto refined_elem : {0, 1})
+   {
+      auto ssmesh = Mesh(smesh);
+
+      refs[0].index = refined_elem;
+      refs[0].ref_type = Refinement::XYZ;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("TetBoundaryRefinement", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+
+   smesh.FinalizeTopology();
+   smesh.Finalize(true);
+   smesh.UniformRefinement();
+
+   smesh.EnsureNCMesh(true);
+
+   CHECK(smesh.GetNBE() == 4 * 4);
+
+   // Loop over elements and mark for refinement if any vertices match the
+   // original
+   Array<int> vertices, elements;
+   // reference vertices of (0,0,0), (1,0,0), (0,1,0), (0,0,1) are [0,3]
+   auto original_vert = [](int i) { return i >= 0 && i <= 3; };
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      smesh.GetElementVertices(n, vertices);
+      if (std::any_of(vertices.begin(), vertices.end(), original_vert))
+      {
+         elements.Append(n);
+      }
+   }
+
+   smesh.GeneralRefinement(elements);
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Each side of the tetrahedron should now have 1 original face, and then 3 *
+   // 4 nonconformally generated faces.
+   CHECK(smesh.GetNBE() == 4 * (1 + 3 * 4));
+}
+
 } // namespace mfem
