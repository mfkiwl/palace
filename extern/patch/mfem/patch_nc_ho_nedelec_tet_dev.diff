diff --git a/.gitignore b/.gitignore
index 22e3e548b..9969c4142 100644
--- a/.gitignore
+++ b/.gitignore
@@ -213,6 +213,7 @@ miniapps/meshing/twist
 miniapps/meshing/mesh-explorer
 miniapps/meshing/shaper
 miniapps/meshing/extruder
+miniapps/meshing/fit-node-position
 miniapps/meshing/trimmer
 miniapps/meshing/reflector
 miniapps/meshing/mesh-optimizer
diff --git a/CHANGELOG b/CHANGELOG
index b68e7b053..9bbee3ee8 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -21,7 +21,10 @@ New and updated examples and miniapps
   skewness, and aspect-ratio computed from the Jacobian of the transformation.
 
 - Added a new miniapp for interface and boundary fitting to implicit domains
-  defined using level-set functions. See miniapps/meshing/pmesh-fitting.cpp
+  defined using level-set functions. See miniapps/meshing/pmesh-fitting.cpp.
+
+- Added a new miniapp for fitting of selected mesh nodes to specified positions,
+  while maintaining mesh quality. See miniapps/meshing/fit-node-position.cpp.
 
 - Added new Discontinuous Petrov-Galerkin (DPG) miniapp which includes serial
   and parallel examples for diffusion, convection-diffusion, acoustics and
@@ -54,7 +57,7 @@ Meshing improvements
 - Added support for free connectivity of NURBS patches allowing for more complex
   patch configurations such as C-meshes. This is demonstrated in a new NURBS
   miniapp.
-  
+
 - The edge to knot map for NURBS meshes can be determined automatically. It is no
   longer needed to specify this in the NURBS mesh. A mesh in the NURBS miniapp
   demonstrates this.
@@ -83,6 +86,9 @@ Discretization improvements
 - Support for parallel transfer of H1 fields using the low-order refined (LOR)
   transfer operators in L2ProjectionGridTransfer
 
+- Introduced support for higher order non conformal Nedelec elements on
+  simplices in ParMesh.
+
 Linear and nonlinear solvers
 ----------------------------
 - Updated interface to MUMPS direct solver to support multiple right-hand
@@ -108,6 +114,8 @@ Miscellaneous
 - Reorganized files for bilinear form, linear form, and nonlinear form integrators
   in the fem/integ/ subdirectory.
 
+- FiniteElementSpace::GetFE has been updated to abort instead of returning NULL for
+  an empty partition.
 
 Version 4.5.2, released on March 23, 2023
 =========================================
diff --git a/examples/ex13p.cpp b/examples/ex13p.cpp
index da3a7cdba..af3cbc696 100644
--- a/examples/ex13p.cpp
+++ b/examples/ex13p.cpp
@@ -54,6 +54,7 @@ int main(int argc, char *argv[])
    int par_ref_levels = 1;
    int order = 1;
    int nev = 5;
+   bool nc = false;
    bool visualization = 1;
    const char *device_config = "cpu";
 
@@ -69,6 +70,9 @@ int main(int argc, char *argv[])
                   " isoparametric space.");
    args.AddOption(&nev, "-n", "--num-eigs",
                   "Number of desired eigenmodes.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-c",
+                  "--conforming",
+                  "Mark the mesh as nonconforming before partitioning.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -107,6 +111,11 @@ int main(int argc, char *argv[])
       mesh->UniformRefinement();
    }
 
+   if (nc)
+   {
+      mesh->EnsureNCMesh(true);
+   }
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution (1 time by
    //    default, or specified on the command line with -rp). Once the parallel
diff --git a/examples/ex3.cpp b/examples/ex3.cpp
index edbfdac7d..19673a451 100644
--- a/examples/ex3.cpp
+++ b/examples/ex3.cpp
@@ -63,6 +63,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = 1;
 
@@ -77,6 +78,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -103,10 +106,18 @@ int main(int argc, char *argv[])
    dim = mesh->Dimension();
    int sdim = mesh->SpaceDimension();
 
+
    // 4. Refine the mesh to increase the resolution. In this example we do
    //    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
    //    largest number that gives a final mesh with no more than 50,000
    //    elements.
+
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+   mesh->UniformRefinement();
    {
       int ref_levels =
          (int)floor(log(50000./mesh->GetNE())/log(2.)/dim);
@@ -115,7 +126,6 @@ int main(int argc, char *argv[])
          mesh->UniformRefinement();
       }
    }
-
    // 5. Define a finite element space on the mesh. Here we use the Nedelec
    //    finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/examples/ex3p.cpp b/examples/ex3p.cpp
index e24c52809..f48ec91fe 100644
--- a/examples/ex3p.cpp
+++ b/examples/ex3p.cpp
@@ -70,6 +70,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = true;
 #ifdef MFEM_USE_AMGX
@@ -87,6 +88,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -129,6 +132,12 @@ int main(int argc, char *argv[])
    //    this example we do 'ref_levels' of uniform refinement. We choose
    //    'ref_levels' to be the largest number that gives a final mesh with no
    //    more than 1,000 elements.
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+
    {
       int ref_levels = (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
@@ -149,7 +158,6 @@ int main(int argc, char *argv[])
          pmesh->UniformRefinement();
       }
    }
-
    // 7. Define a parallel finite element space on the parallel mesh. Here we
    //    use the Nedelec finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index b0bf84145..7d36985de 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -488,6 +488,7 @@ int IsoparametricTransformation::OrderGrad(const FiniteElement *fe) const
 void IsoparametricTransformation::Transform (const IntegrationPoint &ip,
                                              Vector &trans)
 {
+   MFEM_ASSERT(FElem != nullptr, "!");
    shape.SetSize(FElem->GetDof());
    trans.SetSize(PointMat.Height());
 
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 9afa756f5..d8184eac6 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -1112,7 +1112,9 @@ public:
    int GetLocalDofForDof(int i) const { return dof_ldof_array[i]; }
 
    /** @brief Returns pointer to the FiniteElement in the FiniteElementCollection
-        associated with i'th element in the mesh object. */
+        associated with i'th element in the mesh object.
+        Note: The method has been updated to abort instead of returning NULL for
+        an empty partition. */
    virtual const FiniteElement *GetFE(int i) const;
 
    /** @brief Returns pointer to the FiniteElement in the FiniteElementCollection
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index cb58b6033..fc55af976 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -836,6 +836,9 @@ double GridFunction::GetValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -975,6 +978,9 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -999,6 +1005,8 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
          FaceElementTransformations * FET =
             dynamic_cast<FaceElementTransformations *>(&T);
 
+         MFEM_ASSERT(FET != nullptr,
+                     "FaceElementTransformation must be valid for a boundary element");
          // Evaluate in neighboring element for both continuous and
          // discontinuous fields (the integration point in T1 should have
          // already been set).
@@ -1116,11 +1124,10 @@ int GridFunction::GetFaceVectorValues(
    int i, int side, const IntegrationRule &ir,
    DenseMatrix &vals, DenseMatrix &tr) const
 {
-   int n, di;
+   int di;
    FaceElementTransformations *Transf;
 
-   n = ir.GetNPoints();
-   IntegrationRule eir(n);  // ---
+   IntegrationRule eir(ir.GetNPoints());  // ---
    Transf = fes->GetMesh()->GetFaceElementTransformations(i, 0);
    if (side == 2)
    {
@@ -1142,12 +1149,14 @@ int GridFunction::GetFaceVectorValues(
    if (di == 0)
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 5);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc1.Transform(ir, eir);
       GetVectorValues(*Transf->Elem1, eir, vals, &tr);
    }
    else
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 10);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc2.Transform(ir, eir);
       GetVectorValues(*Transf->Elem2, eir, vals, &tr);
    }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index fb0c7cf9f..ef3e7437b 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -1261,6 +1261,7 @@ void ParFiniteElementSpace::ExchangeFaceNbrData()
    // element)
    face_nbr_element_dof.MakeI(recv_el_off[num_face_nbrs]);
 
+
    int *send_I = send_nbr_elem_dof.GetI();
    int *recv_I = face_nbr_element_dof.GetI();
    for (int fn = 0; fn < num_face_nbrs; fn++)
@@ -1923,9 +1924,8 @@ struct PMatrixRow
    void AddRow(const PMatrixRow &other, double coef)
    {
       elems.reserve(elems.size() + other.elems.size());
-      for (unsigned i = 0; i < other.elems.size(); i++)
+      for (const PMatrixElement &oei : other.elems)
       {
-         const PMatrixElement &oei = other.elems[i];
          elems.push_back(
             PMatrixElement(oei.column, oei.stride, coef * oei.value));
       }
@@ -2059,6 +2059,7 @@ void NeighborRowMessage::Encode(int rank)
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+
          const RowInfo &ri = rows[row_idx[ent][i]];
          MFEM_ASSERT(ent == ri.entity, "");
 
@@ -2110,24 +2111,36 @@ void NeighborRowMessage::Decode(int rank)
    rows.reserve(nrows);
 
    // read rows
+   // ent = {0,1,2} means vertex, edge and face entity
    for (int ent = 0, gi = 0; ent < 3; ent++)
    {
+      // extract the vertex list, edge list or face list.
       const Array<MeshId> &ids = ent_ids[ent];
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+         // read the particular element dof value off the stream.
          int edof = bin_io::read<int>(stream);
 
-         // handle orientation and sign change
-         const int *ind = NULL;
+         // Handle orientation and sign change.
+         // This flips the sign on dofs where necessary, and for edges and faces
+         // also reorders if flipped, i.e. an edge with
+         //    1 -> 2 -> 3 -> 4
+         // might become
+         //    -4 -> -3 -> -2 -> -1
+         // This cannot treat all face dofs, as they can have rotations and
+         // reflections.
+         const int *ind = nullptr;
+         Geometry::Type geom = Geometry::Type::INVALID;
          if (ent == 1)
          {
+            // edge NC orientation is element defined.
             int eo = pncmesh->GetEdgeNCOrientation(id);
             ind = fec->DofOrderForOrientation(Geometry::SEGMENT, eo);
          }
          else if (ent == 2)
          {
-            Geometry::Type geom = pncmesh->GetFaceGeometry(id.index);
+            geom = pncmesh->GetFaceGeometry(id.index);
             int fo = pncmesh->GetFaceOrientation(id.index);
             ind = fec->DofOrderForOrientation(geom, fo);
          }
@@ -2149,6 +2162,7 @@ void NeighborRowMessage::Decode(int rank)
             s *= -1.0;
          }
 
+         // Create a row for this entity, recording the index of the mesh element
          rows.push_back(RowInfo(ent, id.index, edof, group_ids[gi++]));
          rows.back().row.read(stream, s);
 
@@ -2158,6 +2172,65 @@ void NeighborRowMessage::Decode(int rank)
                    << rows.back().index << ", edof " << rows.back().edof
                    << std::endl;
 #endif
+
+         if (ent == 2 && fec->GetContType() == FiniteElementCollection::TANGENTIAL
+             && !Geometry::IsTensorProduct(geom))
+         {
+            // ND face dofs need to be processed together, as the transformation
+            // is given by a 2x2 matrix, so we manually apply an extra increment
+            // to the loop counter and add in a new row. Once these rows are placed, they
+            // represent the Identity transformation. To map across the
+            // processor boundary, we also need to apply a Primal Transformation
+            // (see doftrans.hpp) to a notional "global dof" orientation.
+            // For simplicity we perform the action of these 2x2 matrices
+            // manually using the AddRow capability, followed by a Collapse.
+
+            // To perform the operations, we add and subtract initial versions
+            // of the rows, that represent [1 0; 0 1] in row major notation.
+            // The first row represents the 1 at (0,0) in [1 0; 0 1]
+            // The second row represents the 1 at (1,1) in [1 0; 0 1]
+
+            // We can safely bind this reference as rows was reserved above so
+            // there is no hidden copying that could result in a dangling reference.
+            auto &first_row = rows.back().row;
+            // This is the first "fundamental unit" used in the transformation.
+            const auto initial_first_row = first_row;
+            // Extract the next dof too, and apply any dof order transformation expected.
+            const MeshId &next_id = ids[++i];
+            int fo = pncmesh->GetFaceOrientation(next_id.index);
+            ind = fec->DofOrderForOrientation(geom, fo);
+
+            s = 1.0;
+            edof = bin_io::read<int>(stream);
+            if (ind && (edof = ind[edof]) < 0)
+            {
+               edof = -1 - edof;
+               s = -1.0;
+            }
+            rows.push_back(RowInfo(ent, next_id.index, edof, group_ids[gi++]));
+            rows.back().row.read(stream, s);
+
+            auto &second_row = rows.back().row;
+
+            // This is the second "fundamental unit" used in the transformation.
+            const auto initial_second_row = second_row;
+
+            const auto T = [&fo]()
+            {
+               auto T = ND_DofTransformation::GetFaceTransform(fo);
+               T(0,0) -= 1;
+               T(1,1) -= 1;
+               return T;
+            }();
+
+            first_row.AddRow(initial_first_row, T(0,0));
+            first_row.AddRow(initial_second_row, T(0,1));
+            second_row.AddRow(initial_first_row, T(1,0));
+            second_row.AddRow(initial_second_row, T(1,1));
+
+            first_row.Collapse();
+            second_row.Collapse();
+         }
       }
    }
 }
@@ -2285,12 +2358,6 @@ int ParFiniteElementSpace
                                        Array<int> *dof_tdof,
                                        bool partial) const
 {
-   // TODO: general face DOF transformations in NeighborRowMessage::Decode()
-   MFEM_VERIFY(!(fec->GetOrder() >= 2
-                 && pmesh->HasGeometry(Geometry::TETRAHEDRON)
-                 && fec->GetContType() == FiniteElementCollection::TANGENTIAL),
-               "Nedelec NC tets of order >= 2 are not supported yet.");
-
    const bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
 
 #ifdef MFEM_PMATRIX_STATS
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index 0a58530c1..50ee18668 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -469,17 +469,17 @@ void ParGridFunction::GetVectorValue(ElementTransformation &T,
    }
 
    Array<int> vdofs;
-   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no,
-                                                               vdofs);
-   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
-
-   int dof = fe->GetDof();
+   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no, vdofs);
    Vector loc_data;
    face_nbr_data.GetSubVector(vdofs, loc_data);
    if (doftrans)
    {
       doftrans->InvTransformPrimal(loc_data);
    }
+
+   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
+   int dof = fe->GetDof();
+
    if (fe->GetRangeType() == FiniteElement::SCALAR)
    {
       Vector shape(dof);
diff --git a/fem/tmop.cpp b/fem/tmop.cpp
index 10f96f4af..053224dfd 100644
--- a/fem/tmop.cpp
+++ b/fem/tmop.cpp
@@ -2838,6 +2838,7 @@ TMOP_Integrator::~TMOP_Integrator()
    delete lim_func;
    delete adapt_lim_gf;
    delete surf_fit_gf;
+   delete surf_fit_limiter;
    delete surf_fit_grad;
    delete surf_fit_hess;
    for (int i = 0; i < ElemDer.Size(); i++)
@@ -2912,6 +2913,10 @@ void TMOP_Integrator::EnableSurfaceFitting(const GridFunction &s0,
                                            Coefficient &coeff,
                                            AdaptivityEvaluator &ae)
 {
+   // To have both we must duplicate the markers.
+   MFEM_VERIFY(surf_fit_pos == NULL,
+               "Using both fitting approaches is not supported.");
+
    delete surf_fit_gf;
    surf_fit_gf = new GridFunction(s0);
    surf_fit_gf->CountElementsPerVDof(surf_fit_dof_count);
@@ -2925,12 +2930,37 @@ void TMOP_Integrator::EnableSurfaceFitting(const GridFunction &s0,
    (*surf_fit_gf->FESpace()->GetMesh()->GetNodes(), *surf_fit_gf);
 }
 
+void TMOP_Integrator::EnableSurfaceFitting(const GridFunction &pos,
+                                           const Array<bool> &smarker,
+                                           Coefficient &coeff)
+{
+   // To have both we must duplicate the markers.
+   MFEM_VERIFY(surf_fit_gf == NULL,
+               "Using both fitting approaches is not supported.");
+   MFEM_VERIFY(pos.FESpace()->GetMesh()->GetNodes(),
+               "Positions on a mesh without Nodes is not supported.");
+   MFEM_VERIFY(pos.FESpace()->GetOrdering() ==
+               pos.FESpace()->GetMesh()->GetNodes()->FESpace()->GetOrdering(),
+               "Incompatible ordering of spaces!");
+
+   surf_fit_pos     = &pos;
+   pos.CountElementsPerVDof(surf_fit_dof_count);
+   surf_fit_marker  = &smarker;
+   surf_fit_coeff   = &coeff;
+   delete surf_fit_limiter;
+   surf_fit_limiter = new TMOP_QuadraticLimiter;
+}
+
 #ifdef MFEM_USE_MPI
 void TMOP_Integrator::EnableSurfaceFitting(const ParGridFunction &s0,
                                            const Array<bool> &smarker,
                                            Coefficient &coeff,
                                            AdaptivityEvaluator &ae)
 {
+   // To have both we must duplicate the markers.
+   MFEM_VERIFY(surf_fit_pos == NULL,
+               "Using both fitting approaches is not supported.");
+
    delete surf_fit_gf;
    surf_fit_gf = new GridFunction(s0);
    s0.CountElementsPerVDof(surf_fit_dof_count);
@@ -3014,31 +3044,53 @@ void TMOP_Integrator::EnableSurfaceFittingFromSource(
 }
 #endif
 
-void TMOP_Integrator::GetSurfaceFittingErrors(double &err_avg, double &err_max)
+void TMOP_Integrator::GetSurfaceFittingErrors(const Vector &pos,
+                                              double &err_avg, double &err_max)
 {
-   MFEM_VERIFY(surf_fit_gf, "Surface fitting has not been enabled.");
+   MFEM_VERIFY(surf_fit_marker, "Surface fitting has not been enabled.");
 
+   const FiniteElementSpace *fes =
+      (surf_fit_gf) ? surf_fit_gf->FESpace() : surf_fit_pos->FESpace();
 #ifdef MFEM_USE_MPI
-   auto pfes =
-      dynamic_cast<const ParFiniteElementSpace *>(surf_fit_gf->FESpace());
+   auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes);
    bool parallel = (pfes) ? true : false;
 #endif
 
+   int dim = fes->GetMesh()->Dimension();
+   const int node_cnt = surf_fit_marker->Size();
    err_max = 0.0;
    int dof_cnt = 0;
    double err_sum = 0.0;
-   for (int i = 0; i < surf_fit_marker->Size(); i++)
+   for (int i = 0; i < node_cnt; i++)
    {
-      if ((*surf_fit_marker)[i] == true)
-      {
+      if ((*surf_fit_marker)[i] == false) { continue; }
+
 #ifdef MFEM_USE_MPI
-         // Don't count the overlapping DOFs in parallel.
-         if (parallel && pfes->GetLocalTDofNumber(i) < 0) { continue; }
+      // Don't count the overlapping DOFs in parallel.
+      // The pfes might be ordered byVDIM, while the loop goes consecutively.
+      const int dof_i = pfes->DofToVDof(i, 0);
+      if (parallel && pfes->GetLocalTDofNumber(dof_i) < 0) { continue; }
 #endif
-         dof_cnt++;
-         err_max  = fmax(err_max, fabs((*surf_fit_gf)(i)));
-         err_sum += fabs((*surf_fit_gf)(i));
+
+      dof_cnt++;
+      double sigma_s = 0.0;
+      if (surf_fit_gf) { sigma_s = fabs((*surf_fit_gf)(i)); }
+      if (surf_fit_pos)
+      {
+         Vector pos_s(dim), pos_s_target(dim);
+         for (int d = 0; d < dim; d++)
+         {
+            pos_s(d) = (fes->GetOrdering() == Ordering::byNODES) ?
+                       pos(d*node_cnt + i) : pos(i*dim + d);
+            pos_s_target(d) = (fes->GetOrdering() == Ordering::byNODES)
+                              ? (*surf_fit_pos)(d*node_cnt + i)
+                              : (*surf_fit_pos)(i*dim + d);
+         }
+         sigma_s = pos_s.DistanceTo(pos_s_target);
       }
+
+      err_max  = fmax(err_max, sigma_s);
+      err_sum += sigma_s;
    }
 
 #ifdef MFEM_USE_MPI
@@ -3092,7 +3144,7 @@ double TMOP_Integrator::GetElementEnergy(const FiniteElement &el,
    // as part of a FD derivative computation (because we include the exact
    // derivatives of these terms in FD computations).
    const bool adaptive_limiting = (adapt_lim_gf && fd_call_flag == false);
-   const bool surface_fit = (surf_fit_gf && fd_call_flag == false);
+   const bool surface_fit = (surf_fit_marker && fd_call_flag == false);
 
    DSh.SetSize(dof, dim);
    Jrt.SetSize(dim);
@@ -3195,21 +3247,42 @@ double TMOP_Integrator::GetElementEnergy(const FiniteElement &el,
    // Contribution from the surface fitting term.
    if (surface_fit)
    {
-      const IntegrationRule &ir_s =
-         surf_fit_gf->FESpace()->GetFE(el_id)->GetNodes();
-      Array<int> dofs;
-      Vector sigma_e;
-      surf_fit_gf->FESpace()->GetElementDofs(el_id, dofs);
-      surf_fit_gf->GetSubVector(dofs, sigma_e);
-      for (int s = 0; s < dofs.Size(); s++)
+      // Scalar for surf_fit_gf, vector for surf_fit_pos, but that's ok.
+      const FiniteElementSpace *fes_fit =
+         (surf_fit_gf) ? surf_fit_gf->FESpace() : surf_fit_pos->FESpace();
+      const IntegrationRule *ir_s = &fes_fit->GetFE(el_id)->GetNodes();
+      Array<int> vdofs;
+      fes_fit->GetElementVDofs(el_id, vdofs);
+
+      Vector sigma_e(dof);
+      if (surf_fit_gf) { surf_fit_gf->GetSubVector(vdofs, sigma_e); }
+
+      for (int s = 0; s < dof; s++)
       {
-         if ((*surf_fit_marker)[dofs[s]] == true)
+         // Because surf_fit_pos.fes might be ordered byVDIM.
+         const int scalar_dof_id = fes_fit->VDofToDof(vdofs[s]);
+         if ((*surf_fit_marker)[scalar_dof_id] == false) { continue; }
+
+         const IntegrationPoint &ip_s = ir_s->IntPoint(s);
+         Tpr->SetIntPoint(&ip_s);
+
+         if (surf_fit_gf)
          {
-            const IntegrationPoint &ip_s = ir_s.IntPoint(s);
-            Tpr->SetIntPoint(&ip_s);
             energy += surf_fit_coeff->Eval(*Tpr, ip_s) * surf_fit_normal *
                       sigma_e(s) * sigma_e(s);
          }
+         if (surf_fit_pos)
+         {
+            // Fitting to exact positions.
+            Vector pos(dim), pos_target(dim);
+            for (int d = 0; d < dim; d++)
+            {
+               pos(d) = PMatI(s, d);
+               pos_target(d) = (*surf_fit_pos)(vdofs[d*dof + s]);
+            }
+            energy += surf_fit_coeff->Eval(*Tpr, ip_s) * surf_fit_normal *
+                      surf_fit_limiter->Eval(pos, pos_target, 1.0);
+         }
       }
    }
 
@@ -3437,7 +3510,8 @@ void TMOP_Integrator::AssembleElementVectorExact(const FiniteElement &el,
 
    // Define ref->physical transformation, when a Coefficient is specified.
    IsoparametricTransformation *Tpr = NULL;
-   if (metric_coeff || lim_coeff || adapt_lim_gf || surf_fit_gf || exact_action)
+   if (metric_coeff || lim_coeff || adapt_lim_gf ||
+       surf_fit_gf || surf_fit_pos || exact_action)
    {
       Tpr = new IsoparametricTransformation;
       Tpr->SetFE(&el);
@@ -3519,7 +3593,7 @@ void TMOP_Integrator::AssembleElementVectorExact(const FiniteElement &el,
    }
 
    if (adapt_lim_gf) { AssembleElemVecAdaptLim(el, *Tpr, ir, weights, PMatO); }
-   if (surf_fit_gf) { AssembleElemVecSurfFit(el, *Tpr, PMatO); }
+   if (surf_fit_gf || surf_fit_pos) { AssembleElemVecSurfFit(el, *Tpr, PMatO); }
 
    delete Tpr;
 }
@@ -3571,7 +3645,7 @@ void TMOP_Integrator::AssembleElementGradExact(const FiniteElement &el,
 
    // Define ref->physical transformation, when a Coefficient is specified.
    IsoparametricTransformation *Tpr = NULL;
-   if (metric_coeff || lim_coeff || adapt_lim_gf || surf_fit_gf)
+   if (metric_coeff || lim_coeff || adapt_lim_gf || surf_fit_gf || surf_fit_pos)
    {
       Tpr = new IsoparametricTransformation;
       Tpr->SetFE(&el);
@@ -3627,7 +3701,7 @@ void TMOP_Integrator::AssembleElementGradExact(const FiniteElement &el,
    }
 
    if (adapt_lim_gf) { AssembleElemGradAdaptLim(el, *Tpr, ir, weights, elmat); }
-   if (surf_fit_gf) { AssembleElemGradSurfFit(el, *Tpr, elmat); }
+   if (surf_fit_gf || surf_fit_pos) { AssembleElemGradSurfFit(el, *Tpr, elmat);}
 
    delete Tpr;
 }
@@ -3734,49 +3808,75 @@ void TMOP_Integrator::AssembleElemVecSurfFit(const FiniteElement &el_x,
                                              DenseMatrix &mat)
 {
    const int el_id = Tpr.ElementNo;
+
+   // Scalar for surf_fit_gf, vector for surf_fit_pos, but that's ok.
+   const FiniteElementSpace *fes_fit =
+      (surf_fit_gf) ? surf_fit_gf->FESpace() : surf_fit_pos->FESpace();
+   const FiniteElement &el_s = *fes_fit->GetFE(el_id);
+   const int dof_s = el_s.GetDof(), dim = el_x.GetDim();
+
    // Check if the element has any DOFs marked for surface fitting.
-   Array<int> sdofs, dofs;
-   surf_fit_gf->FESpace()->GetElementDofs(el_id, sdofs);
+   Array<int> dofs, vdofs;
+   fes_fit->GetElementVDofs(el_id, vdofs);
    int count = 0;
-   for (int s = 0; s < sdofs.Size(); s++)
+   for (int s = 0; s < dof_s; s++)
    {
-      count += ((*surf_fit_marker)[sdofs[s]]) ? 1 : 0;
+      // Because surf_fit_pos.fes might be ordered byVDIM.
+      const int scalar_dof_id = fes_fit->VDofToDof(vdofs[s]);
+      count += ((*surf_fit_marker)[scalar_dof_id]) ? 1 : 0;
    }
    if (count == 0) { return; }
 
-   const FiniteElement &el_s = *surf_fit_gf->FESpace()->GetFE(el_id);
-
-   const int dof_s = el_s.GetDof(), dim = el_x.GetDim();
-
-   Vector sigma_e;
-   surf_fit_gf->GetSubVector(sdofs, sigma_e);
-
-   // Project the gradient of sigma in the same space.
-   // The FE coefficients of the gradient go in surf_fit_grad_e.
+   Vector sigma_e(dof_s);
    DenseMatrix surf_fit_grad_e(dof_s, dim);
-   Vector grad_ptr(surf_fit_grad_e.GetData(), dof_s * dim);
-   DenseMatrix grad_phys; // This will be (dof x dim, dof).
-   if (surf_fit_gf_bg)
+   if (surf_fit_gf || surf_fit_gf_bg)
    {
-      surf_fit_grad->FESpace()->GetElementVDofs(el_id, dofs);
-      surf_fit_grad->GetSubVector(dofs, grad_ptr);
-   }
-   else
-   {
-      el_s.ProjectGrad(el_s, Tpr, grad_phys);
-      grad_phys.Mult(sigma_e, grad_ptr);
+      surf_fit_gf->GetSubVector(vdofs, sigma_e);
+
+      // Project the gradient of sigma in the same space.
+      // The FE coefficients of the gradient go in surf_fit_grad_e.
+      Vector grad_ptr(surf_fit_grad_e.GetData(), dof_s * dim);
+      DenseMatrix grad_phys; // This will be (dof x dim, dof).
+      if (surf_fit_gf_bg)
+      {
+         surf_fit_grad->FESpace()->GetElementVDofs(el_id, dofs);
+         surf_fit_grad->GetSubVector(dofs, grad_ptr);
+      }
+      else
+      {
+         el_s.ProjectGrad(el_s, Tpr, grad_phys);
+         grad_phys.Mult(sigma_e, grad_ptr);
+      }
    }
+   else { Tpr.GetPointMat().Transpose(PMatI); }
 
    const IntegrationRule &ir = el_s.GetNodes();
+
    for (int s = 0; s < dof_s; s++)
    {
-      if ((*surf_fit_marker)[sdofs[s]] == false) { continue; }
+      // Because surf_fit_pos.fes might be ordered byVDIM.
+      const int scalar_dof_id = fes_fit->VDofToDof(vdofs[s]);
+      if ((*surf_fit_marker)[scalar_dof_id] == false) { continue; }
 
       const IntegrationPoint &ip = ir.IntPoint(s);
       Tpr.SetIntPoint(&ip);
-      const double w = 2.0 * surf_fit_normal *
-                       surf_fit_coeff->Eval(Tpr, ip) * sigma_e(s) *
-                       1.0/surf_fit_dof_count[sdofs[s]];
+      double w = surf_fit_normal * surf_fit_coeff->Eval(Tpr, ip) *
+                 1.0 / surf_fit_dof_count[vdofs[s]];
+
+      if (surf_fit_gf) { w *= 2.0 * sigma_e(s); }
+      if (surf_fit_pos)
+      {
+         Vector pos(dim), pos_target(dim);
+         for (int d = 0; d < dim; d++)
+         {
+            pos(d) = PMatI(s, d);
+            pos_target(d) = (*surf_fit_pos)(vdofs[d*dof_s + s]);
+         }
+         Vector grad_s(dim);
+         surf_fit_limiter->Eval_d1(pos, pos_target, 1.0, grad_s);
+         for (int d = 0; d < dim; d++) { surf_fit_grad_e(s, d) = grad_s(d); }
+      }
+
       for (int d = 0; d < dim; d++)
       {
          mat(s, d) += w * surf_fit_grad_e(s, d);
@@ -3789,79 +3889,109 @@ void TMOP_Integrator::AssembleElemGradSurfFit(const FiniteElement &el_x,
                                               DenseMatrix &mat)
 {
    const int el_id = Tpr.ElementNo;
+
+   // Scalar for surf_fit_gf, vector for surf_fit_pos, but that's ok.
+   const FiniteElementSpace *fes_fit =
+      (surf_fit_gf) ? surf_fit_gf->FESpace() : surf_fit_pos->FESpace();
+   const FiniteElement &el_s = *fes_fit->GetFE(el_id);
+   const int dof_s = el_s.GetDof(), dim = el_x.GetDim();
+
    // Check if the element has any DOFs marked for surface fitting.
-   Array<int> dofs, sdofs;
-   surf_fit_gf->FESpace()->GetElementDofs(el_id, sdofs);
-   int ndofs = sdofs.Size();
+   Array<int> dofs, vdofs;
+   fes_fit->GetElementVDofs(el_id, vdofs);
    int count = 0;
-   for (int s = 0; s < ndofs; s++)
+   for (int s = 0; s < dof_s; s++)
    {
-      count += ((*surf_fit_marker)[sdofs[s]]) ? 1 : 0;
+      // Because surf_fit_pos.fes might be ordered byVDIM.
+      const int scalar_dof_id = fes_fit->VDofToDof(vdofs[s]);
+      count += ((*surf_fit_marker)[scalar_dof_id]) ? 1 : 0;
    }
    if (count == 0) { return; }
 
-   const FiniteElement &el_s = *surf_fit_gf->FESpace()->GetFE(el_id);
-
-   const int dof_s = el_s.GetDof(), dim = el_x.GetDim();
-
-   Vector sigma_e;
-   surf_fit_gf->GetSubVector(sdofs, sigma_e);
-
+   Vector sigma_e(dof_s);
    DenseMatrix surf_fit_grad_e(dof_s, dim);
-   Vector grad_ptr(surf_fit_grad_e.GetData(), dof_s * dim);
-   DenseMatrix grad_phys;
-   if (surf_fit_gf_bg)
-   {
-      surf_fit_grad->FESpace()->GetElementVDofs(el_id, dofs);
-      surf_fit_grad->GetSubVector(dofs, grad_ptr);
-   }
-   else
-   {
-      el_s.ProjectGrad(el_s, Tpr, grad_phys);
-      grad_phys.Mult(sigma_e, grad_ptr);
-   }
-
    DenseMatrix surf_fit_hess_e(dof_s, dim*dim);
-   Vector hess_ptr(surf_fit_hess_e.GetData(), dof_s*dim*dim);
-   if (surf_fit_gf_bg)
-   {
-      surf_fit_hess->FESpace()->GetElementVDofs(el_id, dofs);
-      surf_fit_hess->GetSubVector(dofs, hess_ptr);
-   }
-   else
+   if (surf_fit_gf || surf_fit_gf_bg)
    {
-      surf_fit_hess_e.SetSize(dof_s*dim, dim);
-      Mult(grad_phys, surf_fit_grad_e, surf_fit_hess_e);
-      surf_fit_hess_e.SetSize(dof_s, dim * dim);
+      surf_fit_gf->GetSubVector(vdofs, sigma_e);
+
+      // Project the gradient of sigma in the same space.
+      // The FE coefficients of the gradient go in surf_fit_grad_e.
+      Vector grad_ptr(surf_fit_grad_e.GetData(), dof_s * dim);
+      DenseMatrix grad_phys; // This will be (dof x dim, dof).
+      if (surf_fit_gf_bg)
+      {
+         surf_fit_grad->FESpace()->GetElementVDofs(el_id, dofs);
+         surf_fit_grad->GetSubVector(dofs, grad_ptr);
+      }
+      else
+      {
+         el_s.ProjectGrad(el_s, Tpr, grad_phys);
+         grad_phys.Mult(sigma_e, grad_ptr);
+      }
+
+      // Project the Hessian of sigma in the same space.
+      // The FE coefficients of the Hessian go in surf_fit_hess_e.
+      Vector hess_ptr(surf_fit_hess_e.GetData(), dof_s*dim*dim);
+      if (surf_fit_gf_bg)
+      {
+         surf_fit_hess->FESpace()->GetElementVDofs(el_id, dofs);
+         surf_fit_hess->GetSubVector(dofs, hess_ptr);
+      }
+      else
+      {
+         surf_fit_hess_e.SetSize(dof_s*dim, dim);
+         Mult(grad_phys, surf_fit_grad_e, surf_fit_hess_e);
+         surf_fit_hess_e.SetSize(dof_s, dim * dim);
+      }
    }
+   else { Tpr.GetPointMat().Transpose(PMatI); }
 
    const IntegrationRule &ir = el_s.GetNodes();
 
-   Vector surf_fit_grad_s(dim);
    DenseMatrix surf_fit_hess_s(dim, dim);
-
    for (int s = 0; s < dof_s; s++)
    {
-      if ((*surf_fit_marker)[sdofs[s]] == false) { continue; }
+      // Because surf_fit_pos.fes might be ordered byVDIM.
+      const int scalar_dof_id = fes_fit->VDofToDof(vdofs[s]);
+      if ((*surf_fit_marker)[scalar_dof_id] == false) { continue; }
 
       const IntegrationPoint &ip = ir.IntPoint(s);
       Tpr.SetIntPoint(&ip);
+      double w = surf_fit_normal * surf_fit_coeff->Eval(Tpr, ip);
 
-      Vector gg_ptr(surf_fit_hess_s.GetData(), dim * dim);
-      surf_fit_hess_e.GetRow(s, gg_ptr);
+      if (surf_fit_gf || surf_fit_gf_bg)
+      {
+         Vector gg_ptr(surf_fit_hess_s.GetData(), dim * dim);
+         surf_fit_hess_e.GetRow(s, gg_ptr);
+         w *= 2.0;
+      }
+      if (surf_fit_pos)
+      {
+         Vector pos(dim), pos_target(dim);
+         for (int d = 0; d < dim; d++)
+         {
+            pos(d) = PMatI(s, d);
+            pos_target(d) = (*surf_fit_pos)(vdofs[d*dof_s + s]);
+         }
+         // Eval_d2 returns the full Hessian, but we still use the general
+         // computation that's in the dim x dim loop below.
+         sigma_e(s) = 1.0;
+         for (int d = 0; d < dim; d++) { surf_fit_grad_e(s, d) = 0.0; }
+         surf_fit_limiter->Eval_d2(pos, pos_target, 1.0, surf_fit_hess_s);
+      }
 
       // Loops over the local matrix.
-      const double w = surf_fit_normal * surf_fit_coeff->Eval(Tpr, ip);
       for (int idim = 0; idim < dim; idim++)
       {
          for (int jdim = 0; jdim <= idim; jdim++)
          {
-            double entry = w * ( 2.0 * surf_fit_grad_e(s, idim) *
-                                 /* */ surf_fit_grad_e(s, jdim) +
-                                 2.0 * sigma_e(s) * surf_fit_hess_s(idim, jdim));
-            entry *= 1.0/surf_fit_dof_count[sdofs[s]];
-            int idx = s + idim*ndofs;
-            int jdx = s + jdim*ndofs;
+            double entry = w * ( surf_fit_grad_e(s, idim) *
+                                 surf_fit_grad_e(s, jdim) +
+                                 sigma_e(s) * surf_fit_hess_s(idim, jdim));
+            entry *= 1.0 / surf_fit_dof_count[vdofs[s]];
+            int idx = s + idim*dof_s;
+            int jdx = s + jdim*dof_s;
             mat(idx, jdx) += entry;
             if (idx != jdx) { mat(jdx, idx) += entry; }
          }
@@ -3930,7 +4060,7 @@ void TMOP_Integrator::AssembleElementVectorFD(const FiniteElement &el,
    fd_call_flag = false;
 
    // Contributions from adaptive limiting, surface fitting (exact derivatives).
-   if (adapt_lim_gf || surf_fit_gf)
+   if (adapt_lim_gf || surf_fit_gf || surf_fit_pos)
    {
       const IntegrationRule &ir = ActionIntegrationRule(el);
       const int nqp = ir.GetNPoints();
@@ -3955,7 +4085,7 @@ void TMOP_Integrator::AssembleElementVectorFD(const FiniteElement &el,
 
       PMatO.UseExternalData(elvect.GetData(), dof, dim);
       if (adapt_lim_gf) { AssembleElemVecAdaptLim(el, Tpr, ir, weights, PMatO); }
-      if (surf_fit_gf) { AssembleElemVecSurfFit(el, Tpr, PMatO); }
+      if (surf_fit_gf || surf_fit_pos) { AssembleElemVecSurfFit(el, Tpr, PMatO); }
    }
 }
 
@@ -4030,7 +4160,7 @@ void TMOP_Integrator::AssembleElementGradFD(const FiniteElement &el,
    fd_call_flag = false;
 
    // Contributions from adaptive limiting.
-   if (adapt_lim_gf || surf_fit_gf)
+   if (adapt_lim_gf || surf_fit_gf || surf_fit_pos)
    {
       const IntegrationRule &ir = GradientIntegrationRule(el);
       const int nqp = ir.GetNPoints();
@@ -4054,7 +4184,7 @@ void TMOP_Integrator::AssembleElementGradFD(const FiniteElement &el,
       }
 
       if (adapt_lim_gf) { AssembleElemGradAdaptLim(el, Tpr, ir, weights, elmat); }
-      if (surf_fit_gf) { AssembleElemGradSurfFit(el, Tpr, elmat); }
+      if (surf_fit_gf || surf_fit_pos) { AssembleElemGradSurfFit(el, Tpr, elmat); }
    }
 }
 
@@ -4087,7 +4217,7 @@ void TMOP_Integrator::EnableNormalization(const GridFunction &x)
    metric_normal = 1.0 / metric_normal;
    lim_normal = 1.0 / lim_normal;
    //if (surf_fit_gf) { surf_fit_normal = 1.0 / surf_fit_normal; }
-   if (surf_fit_gf) { surf_fit_normal = lim_normal; }
+   if (surf_fit_gf || surf_fit_pos) { surf_fit_normal = lim_normal; }
 }
 
 #ifdef MFEM_USE_MPI
@@ -4100,7 +4230,7 @@ void TMOP_Integrator::ParEnableNormalization(const ParGridFunction &x)
    metric_normal = 1.0 / rdc[0];
    lim_normal    = 1.0 / rdc[1];
    // if (surf_fit_gf) { surf_fit_normal = 1.0 / rdc[2]; }
-   if (surf_fit_gf) { surf_fit_normal = lim_normal; }
+   if (surf_fit_gf || surf_fit_pos) { surf_fit_normal = lim_normal; }
 }
 #endif
 
diff --git a/fem/tmop.hpp b/fem/tmop.hpp
index 0b017fb8d..c5391c58a 100644
--- a/fem/tmop.hpp
+++ b/fem/tmop.hpp
@@ -1772,10 +1772,14 @@ protected:
    AdaptivityEvaluator *adapt_lim_eval;  // Not owned.
 
    // Surface fitting.
-   GridFunction *surf_fit_gf;           // Owned, Updated by surf_fit_eval.
-   const Array<bool> *surf_fit_marker;  // Not owned.
-   Coefficient *surf_fit_coeff;         // Not owned.
-   AdaptivityEvaluator *surf_fit_eval;  // Not owned.
+   const Array<bool> *surf_fit_marker;      // Not owned. Nodes to fit.
+   Coefficient *surf_fit_coeff;             // Not owned. Fitting term scaling.
+   // Fitting to a discrete level set.
+   GridFunction *surf_fit_gf;               // Owned. Updated by surf_fit_eval.
+   AdaptivityEvaluator *surf_fit_eval;      // Not owned.
+   // Fitting to given physical positions.
+   TMOP_QuadraticLimiter *surf_fit_limiter; // Owned. Created internally.
+   const GridFunction *surf_fit_pos;        // Not owned. Positions to fit.
    double surf_fit_normal;
    bool surf_fit_gf_bg;
    GridFunction *surf_fit_grad, *surf_fit_hess;
@@ -1976,9 +1980,10 @@ public:
         lim_dist(NULL), lim_func(NULL), lim_normal(1.0),
         adapt_lim_gf0(NULL), adapt_lim_gf(NULL), adapt_lim_coeff(NULL),
         adapt_lim_eval(NULL),
-        surf_fit_gf(NULL), surf_fit_marker(NULL),
-        surf_fit_coeff(NULL),
-        surf_fit_eval(NULL), surf_fit_normal(1.0),
+        surf_fit_marker(NULL), surf_fit_coeff(NULL),
+        surf_fit_gf(NULL), surf_fit_eval(NULL),
+        surf_fit_limiter(NULL), surf_fit_pos(NULL),
+        surf_fit_normal(1.0),
         surf_fit_gf_bg(false), surf_fit_grad(NULL), surf_fit_hess(NULL),
         surf_fit_eval_bg_grad(NULL), surf_fit_eval_bg_hess(NULL),
         discr_tc(dynamic_cast<DiscreteAdaptTC *>(tc)),
@@ -2080,7 +2085,7 @@ public:
                              AdaptivityEvaluator &ae);
 
 #ifdef MFEM_USE_MPI
-   /// Parallel support for surface fitting.
+   /// Parallel support for surface fitting to the zero level set of a function.
    void EnableSurfaceFitting(const ParGridFunction &s0,
                              const Array<bool> &smarker, Coefficient &coeff,
                              AdaptivityEvaluator &ae);
@@ -2118,8 +2123,27 @@ public:
                                        ParGridFunction &s0_hess,
                                        AdaptivityEvaluator &ahe);
 #endif
-   void GetSurfaceFittingErrors(double &err_avg, double &err_max);
-   bool IsSurfaceFittingEnabled() { return (surf_fit_gf != NULL); }
+   /** @brief Fitting of certain DOFs to given positions in physical space.
+
+       Having a set S of marked nodes (or DOFs) and their target positions in
+       physical space x_t, we move these nodes to the target positions during
+       the optimization process.
+       This function adds to the TMOP functional the term
+       @f$ \sum_{i \in S} c \frac{1}{2} (x_i - x_{t,i})^2 @f$,
+       where @f$c@f$ corresponds to @a coeff below and is evaluated at the
+       DOF locations.
+
+       @param[in] pos     The desired positions for the mesh nodes.
+       @param[in] smarker Indicates which DOFs will be aligned.
+       @param[in] coeff   Coefficient c for the above integral. */
+   void EnableSurfaceFitting(const GridFunction &pos,
+                             const Array<bool> &smarker, Coefficient &coeff);
+   void GetSurfaceFittingErrors(const Vector &pos,
+                                double &err_avg, double &err_max);
+   bool IsSurfaceFittingEnabled()
+   {
+      return surf_fit_gf != NULL || surf_fit_pos != NULL;
+   }
 
    /// Update the original/reference nodes used for limiting.
    void SetLimitingNodes(const GridFunction &n0) { lim_nodes0 = &n0; }
diff --git a/fem/tmop_tools.cpp b/fem/tmop_tools.cpp
index 139d3b397..2ee2e1c03 100644
--- a/fem/tmop_tools.cpp
+++ b/fem/tmop_tools.cpp
@@ -419,7 +419,7 @@ double TMOPNewtonSolver::ComputeScalingFactor(const Vector &x,
    double avg_surf_fit_err, max_surf_fit_err = 0.0;
    if (surf_fit_max_threshold > 0.0)
    {
-      GetSurfaceFittingError(avg_surf_fit_err, max_surf_fit_err);
+      GetSurfaceFittingError(x_out_loc, avg_surf_fit_err, max_surf_fit_err);
       if (max_surf_fit_err < surf_fit_max_threshold)
       {
          if (print_options.iterations)
@@ -519,7 +519,7 @@ double TMOPNewtonSolver::ComputeScalingFactor(const Vector &x,
       double avg_fit_err, max_fit_err = 0.0;
       if (surf_fit_max_threshold > 0.0)
       {
-         GetSurfaceFittingError(avg_fit_err, max_fit_err);
+         GetSurfaceFittingError(x_out_loc, avg_fit_err, max_fit_err);
       }
       if (surf_fit_max_threshold > 0.0 && max_fit_err >= 1.2*max_surf_fit_err)
       {
@@ -662,7 +662,8 @@ void TMOPNewtonSolver::GetSurfaceFittingWeight(Array<double> &weights) const
    }
 }
 
-void TMOPNewtonSolver::GetSurfaceFittingError(double &err_avg,
+void TMOPNewtonSolver::GetSurfaceFittingError(const Vector &x_loc,
+                                              double &err_avg,
                                               double &err_max) const
 {
    const NonlinearForm *nlf = dynamic_cast<const NonlinearForm *>(oper);
@@ -680,7 +681,7 @@ void TMOPNewtonSolver::GetSurfaceFittingError(double &err_avg,
       {
          if (ti->IsSurfaceFittingEnabled())
          {
-            ti->GetSurfaceFittingErrors(err_avg_loc, err_max_loc);
+            ti->GetSurfaceFittingErrors(x_loc, err_avg_loc, err_max_loc);
             err_avg = std::fmax(err_avg_loc, err_avg);
             err_max = std::fmax(err_max_loc, err_max);
          }
@@ -693,7 +694,7 @@ void TMOPNewtonSolver::GetSurfaceFittingError(double &err_avg,
          {
             if (ati[j]->IsSurfaceFittingEnabled())
             {
-               ati[j]->GetSurfaceFittingErrors(err_avg_loc, err_max_loc);
+               ati[j]->GetSurfaceFittingErrors(x_loc, err_avg_loc, err_max_loc);
                err_avg = std::fmax(err_avg_loc, err_avg);
                err_max = std::fmax(err_max_loc, err_max);
             }
@@ -739,6 +740,7 @@ void TMOPNewtonSolver::ProcessNewState(const Vector &x) const
 #ifdef MFEM_USE_MPI
       const ParNonlinearForm *pnlf =
          dynamic_cast<const ParNonlinearForm *>(oper);
+
       x_fes = pnlf->ParFESpace();
       x_loc.SetSize(x_fes->GetVSize());
       x_fes->GetProlongationMatrix()->Mult(x, x_loc);
@@ -789,7 +791,7 @@ void TMOPNewtonSolver::ProcessNewState(const Vector &x) const
    if (update_surf_fit_coeff)
    {
       // Get surface fitting errors.
-      GetSurfaceFittingError(surf_fit_err_avg, surf_fit_err_max);
+      GetSurfaceFittingError(x_loc, surf_fit_err_avg, surf_fit_err_max);
       // Get array with surface fitting weights.
       Array<double> weights;
       GetSurfaceFittingWeight(weights);
diff --git a/fem/tmop_tools.hpp b/fem/tmop_tools.hpp
index 347d55710..062be361b 100644
--- a/fem/tmop_tools.hpp
+++ b/fem/tmop_tools.hpp
@@ -181,7 +181,8 @@ protected:
    /// Get the average and maximum surface fitting error at the marked nodes.
    /// If there is more than 1 TMOP integrator, we get the maximum of the
    /// average and maximum error over all integrators.
-   virtual void GetSurfaceFittingError(double &err_avg, double &err_max) const;
+   virtual void GetSurfaceFittingError(const Vector &x_loc,
+                                       double &err_avg, double &err_max) const;
 
    /// Update surface fitting weight as surf_fit_weight *= factor.
    void UpdateSurfaceFittingWeight(double factor) const;
diff --git a/general/table.cpp b/general/table.cpp
index 4c0bb68ee..da4c0187b 100644
--- a/general/table.cpp
+++ b/general/table.cpp
@@ -218,7 +218,8 @@ void Table::SetIJ(int *newI, int *newJ, int newsize)
 
 int Table::Push(int i, int j)
 {
-   MFEM_ASSERT( i >=0 && i<size, "Index out of bounds.  i = "<<i);
+   MFEM_ASSERT( i >=0 &&
+                i<size, "Index out of bounds.  i = " << i << " size " << size);
 
    for (int k = I[i], end = I[i+1]; k < end; k++)
    {
diff --git a/linalg/hiop.cpp b/linalg/hiop.cpp
index 60db916b5..411d91dde 100644
--- a/linalg/hiop.cpp
+++ b/linalg/hiop.cpp
@@ -193,6 +193,48 @@ bool HiopOptimizationProblem::get_vecdistrib_info(size_type global_n,
 #endif
 }
 
+void HiopOptimizationProblem::solution_callback(hiop::hiopSolveStatus status,
+                                                hiop::size_type n,
+                                                const double *x,
+                                                const double *z_L,
+                                                const double *z_U,
+                                                hiop::size_type m,
+                                                const double *g,
+                                                const double *lambda,
+                                                double obj_value)
+{
+   auto hp = dynamic_cast<const HiOpProblem *>(&problem);
+   if (!hp) { return; }
+   hp->SolutionCallback(status, n, x, z_L, z_U, m, g, lambda, obj_value);
+}
+
+bool HiopOptimizationProblem::iterate_callback(int iter,
+                                               double obj_value,
+                                               double logbar_obj_value,
+                                               int n,
+                                               const double *x,
+                                               const double *z_L,
+                                               const double *z_U,
+                                               int m_ineq,
+                                               const double *s,
+                                               int m,
+                                               const double *g,
+                                               const double *lambda,
+                                               double inf_pr,
+                                               double inf_du,
+                                               double onenorm_pr_,
+                                               double mu,
+                                               double alpha_du,
+                                               double alpha_pr,
+                                               int ls_trials)
+{
+   auto hp = dynamic_cast<const HiOpProblem *>(&problem);
+   if (!hp) { return true; }
+   return hp->IterateCallback(iter, obj_value, logbar_obj_value, n, x, z_L, z_U,
+                              m_ineq, s, m, g, lambda, inf_pr, inf_du,
+                              onenorm_pr_, mu, alpha_du, alpha_pr, ls_trials);
+}
+
 void HiopOptimizationProblem::UpdateConstrValsGrads(const Vector x)
 {
    if (constr_info_is_current) { return; }
diff --git a/linalg/hiop.hpp b/linalg/hiop.hpp
index 674c8221d..476361a93 100644
--- a/linalg/hiop.hpp
+++ b/linalg/hiop.hpp
@@ -167,6 +167,36 @@ public:
    virtual bool get_vecdistrib_info(hiop::size_type global_n,
                                     hiop::index_type *cols);
 
+   virtual void solution_callback(hiop::hiopSolveStatus status,
+                                  hiop::size_type n,
+                                  const double *x,
+                                  const double *z_L,
+                                  const double *z_U,
+                                  hiop::size_type m,
+                                  const double *g,
+                                  const double *lambda,
+                                  double obj_value);
+
+   virtual bool iterate_callback(int iter,
+                                 double obj_value,
+                                 double logbar_obj_value,
+                                 int n,
+                                 const double *x,
+                                 const double *z_L,
+                                 const double *z_U,
+                                 int m_ineq,
+                                 const double *s,
+                                 int m,
+                                 const double *g,
+                                 const double *lambda,
+                                 double inf_pr,
+                                 double inf_du,
+                                 double onenorm_pr_,
+                                 double mu,
+                                 double alpha_du,
+                                 double alpha_pr,
+                                 int ls_trials);
+
 #ifdef MFEM_USE_MPI
    virtual bool get_MPI_comm(MPI_Comm &comm_out)
    {
@@ -176,6 +206,48 @@ public:
 #endif
 };
 
+/// Users can inherit this class to access to HiOp-specific functionality.
+class HiOpProblem : public OptimizationProblem
+{
+public:
+   HiOpProblem(int insize, const Operator *C_, const Operator *D_)
+      : OptimizationProblem(insize, C_, D_) { }
+
+   /// See hiopInterfaceBase::solution_callback(...).
+   virtual void SolutionCallback(hiop::hiopSolveStatus status,
+                                 hiop::size_type n,
+                                 const double *x,
+                                 const double *z_L,
+                                 const double *z_U,
+                                 hiop::size_type m,
+                                 const double *g,
+                                 const double *lambda,
+                                 double obj_value) const
+   { }
+
+   /// See hiopInterfaceBase::iterate_callback(...).
+   virtual bool IterateCallback(int iter,
+                                double obj_value,
+                                double logbar_obj_value,
+                                int n,
+                                const double *x,
+                                const double *z_L,
+                                const double *z_U,
+                                int m_ineq,
+                                const double *s,
+                                int m,
+                                const double *g,
+                                const double *lambda,
+                                double inf_pr,
+                                double inf_du,
+                                double onenorm_pr_,
+                                double mu,
+                                double alpha_du,
+                                double alpha_pr,
+                                int ls_trials) const
+   { return true; }
+};
+
 /// Adapts the HiOp functionality to the MFEM OptimizationSolver interface.
 class HiopNlpOptimizer : public OptimizationSolver
 {
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index ab2cc5a22..d7e562362 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -1110,6 +1110,7 @@ FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
    {
       return NULL;
    }
+
    tr = GetFaceElementTransformations(fn, 21);
    tr->Attribute = boundary[BdrElemNo]->GetAttribute();
    tr->ElementNo = BdrElemNo;
@@ -1445,7 +1446,7 @@ Element::Type Mesh::GetFaceElementType(int Face) const
 
 Array<int> Mesh::GetFaceToBdrElMap() const
 {
-   Array<int> face_to_be(GetNumFaces());
+   Array<int> face_to_be(Dim == 2 ? NumOfEdges : NumOfFaces);
    face_to_be = -1;
    for (int i = 0; i < NumOfBdrElements; i++)
    {
@@ -7162,7 +7163,7 @@ STable3D *Mesh::GetFacesTable()
             break;
          }
          default:
-            MFEM_ABORT("Unexpected type of Element.");
+            MFEM_ABORT("Unexpected type of Element: " << GetElementType(i));
       }
    }
    return faces_tbl;
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index acfbc8c06..c9c9ad104 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -35,7 +35,6 @@ ParMesh::ParMesh(const ParMesh &pmesh, bool copy_nodes)
      group_sedge(pmesh.group_sedge),
      group_stria(pmesh.group_stria),
      group_squad(pmesh.group_squad),
-     face_nbr_el_to_face(NULL),
      glob_elem_offset(-1),
      glob_offset_sequence(-1),
      gtopo(pmesh.gtopo)
@@ -107,8 +106,7 @@ ParMesh& ParMesh::operator=(ParMesh &&mesh)
 
 ParMesh::ParMesh(MPI_Comm comm, Mesh &mesh, int *partitioning_,
                  int part_method)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -857,7 +855,6 @@ ParMesh::ParMesh(const ParNCMesh &pncmesh)
    : MyComm(pncmesh.MyComm)
    , NRanks(pncmesh.NRanks)
    , MyRank(pncmesh.MyRank)
-   , face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(MyComm)
@@ -909,7 +906,7 @@ void ParMesh::FinalizeParTopo()
    sface_lface.SetSize(nst + shared_quads.Size());
    if (sface_lface.Size())
    {
-      STable3D *faces_tbl = GetFacesTable();
+      auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
       for (int st = 0; st < nst; st++)
       {
          const int *v = shared_trias[st].v;
@@ -920,14 +917,12 @@ void ParMesh::FinalizeParTopo()
          const int *v = shared_quads[sq].v;
          sface_lface[nst+sq] = (*faces_tbl)(v[0], v[1], v[2], v[3]);
       }
-      delete faces_tbl;
    }
 }
 
 ParMesh::ParMesh(MPI_Comm comm, istream &input, int generate_edges,
                  int refine, bool fix_orientation)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
    , pncmesh(NULL)
@@ -1136,7 +1131,7 @@ void ParMesh::MakeRefined_(ParMesh &orig_mesh, int ref_factor, int ref_type)
    MyComm = orig_mesh.GetComm();
    NRanks = orig_mesh.GetNRanks();
    MyRank = orig_mesh.GetMyRank();
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
    glob_elem_offset = -1;
    glob_offset_sequence = -1;
    gtopo = orig_mesh.gtopo;
@@ -2084,7 +2079,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Nonconforming())
    {
-      // with ParNCMesh we can set up face neighbors without communication
+      // with ParNCMesh we can set up face neighbors mostly without communication
       pncmesh->GetFaceNeighbors(*this);
       have_face_nbr_data = true;
 
@@ -2153,7 +2148,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Dim == 3)
    {
-      GetFaceNbrElementToFaceTable();
+      BuildFaceNbrElementToFaceTable();
    }
 
    if (del_tables) { delete gr_sface; }
@@ -2281,6 +2276,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
    el_marker = -1;
    vertex_marker = -1;
    const int nst = shared_trias.Size();
+
    for (int fn = 0; fn < num_face_nbrs; fn++)
    {
       int nbr_group = face_nbr_group[fn];
@@ -2418,8 +2414,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
 
    // convert the element data into face_nbr_elements
    face_nbr_elements.SetSize(face_nbr_elements_offset[num_face_nbrs]);
-   face_nbr_el_ori.Clear();
-   face_nbr_el_ori.SetSize(face_nbr_elements_offset[num_face_nbrs], 6);
+   face_nbr_el_ori.reset(new Table(face_nbr_elements_offset[num_face_nbrs], 6));
    while (true)
    {
       int fn;
@@ -2450,7 +2445,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          if (Dim == 3)
          {
             int nf = el->GetNFaces();
-            int * fn_ori = face_nbr_el_ori.GetRow(elem_off);
+            int * fn_ori = face_nbr_el_ori->GetRow(elem_off);
             for (int j = 0; j < nf; j++)
             {
                fn_ori[j] = recv_elemdata[j];
@@ -2460,7 +2455,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          face_nbr_elements[elem_off++] = el;
       }
    }
-   face_nbr_el_ori.Finalize();
+   face_nbr_el_ori->Finalize();
 
    MPI_Waitall(num_face_nbrs, send_requests, statuses);
 
@@ -2682,191 +2677,118 @@ STable3D *ParMesh::GetSharedFacesTable()
    return sfaces_tbl;
 }
 
-STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
+template <int N>
+void
+ParMesh::AddTriFaces(const Array<int> &elem_vertices,
+                     const std::unique_ptr<STable3D> &faces,
+                     const std::unique_ptr<STable3D> &shared_faces,
+                     int elem, int start, int end, const int fverts[][N])
 {
-   int i, *v;
-   STable3D * faces_tbl = GetFacesTable();
-   STable3D * sfaces_tbl = GetSharedFacesTable();
-
-   if (face_nbr_el_to_face != NULL)
+   for (int i = start; i < end; ++i)
    {
-      delete face_nbr_el_to_face;
+      // Reference face vertices.
+      const auto fv = fverts[i];
+      // Element specific face vertices.
+      const Vert3 elem_fv(elem_vertices[fv[0]], elem_vertices[fv[1]],
+                          elem_vertices[fv[2]]);
+
+      // Check amongst the faces of elements local to this rank for this set of vertices
+      const int lf = faces->Index(elem_fv.v[0], elem_fv.v[1], elem_fv.v[2]);
+
+      // If the face wasn't found amonst processor local elements, search the
+      // ghosts for this set of vertices.
+      const int sf = lf < 0 ? shared_faces->Index(elem_fv.v[0], elem_fv.v[1],
+                                                  elem_fv.v[2]) : -1;
+      // If find local face -> use that
+      //    else if find shared face -> shift and use that
+      //       else no face found -> set to -1
+      const int face_to_add = lf < 0 ? (sf >= 0 ? sf + NumOfFaces : -1) : lf;
+
+      MFEM_ASSERT(sf >= 0 ||
+                  lf >= 0, "Face must be from a local or a face neighbor element");
+
+      // Add this discovered face to the list of faces of this face neighbor element
+      face_nbr_el_to_face->Push(elem, face_to_add);
    }
-   face_nbr_el_to_face = new Table(face_nbr_elements.Size(), 6);
-   for (i = 0; i < face_nbr_elements.Size(); i++)
+}
+
+void ParMesh::BuildFaceNbrElementToFaceTable()
+{
+   const auto faces = std::unique_ptr<STable3D>(GetFacesTable());
+   const auto shared_faces = std::unique_ptr<STable3D>(GetSharedFacesTable());
+
+   face_nbr_el_to_face.reset(new Table(face_nbr_elements.Size(), 6));
+
+   mfem::Array<int> v;
+
+   // Helper for adding quadrilateral faces.
+   auto add_quad_faces = [&faces, &shared_faces, &v, this]
+                         (int elem, int start, int end, const int fverts[][4])
    {
-      v = face_nbr_elements[i]->GetVertices();
-      switch (face_nbr_elements[i]->GetType())
+      for (int i = start; i < end; ++i)
       {
-         case Element::TETRAHEDRON:
+         const int * const fv = fverts[i];
+         int k = 0;
+         int max = v[fv[0]];
+
+         if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
+         if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
+         if (max < v[fv[3]]) { k = 3; }
+
+         int v0 = -1, v1 = -1, v2 = -1;
+         switch (k)
          {
-            for (int j = 0; j < 4; j++)
+            case 0:
+               v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 1:
+               v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 2:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
+               break;
+            case 3:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
+               break;
+         }
+         int lf = faces->Index(v0, v1, v2);
+         if (lf < 0)
+         {
+            lf = shared_faces->Index(v0, v1, v2);
+            if (lf >= 0)
             {
-               const int *fv = tet_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
+               lf += NumOfFaces;
             }
+         }
+         face_nbr_el_to_face->Push(elem, lf);
+      }
+   };
+
+   for (int i = 0; i < face_nbr_elements.Size(); i++)
+   {
+      face_nbr_elements[i]->GetVertices(v);
+      switch (face_nbr_elements[i]->GetType())
+      {
+         case Element::TETRAHEDRON:
+         {
+            AddTriFaces(v, faces, shared_faces, i, 0, 4, tet_t::FaceVert);
             break;
          }
          case Element::WEDGE:
          {
-            for (int j = 0; j < 2; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 2; j < 5; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            AddTriFaces(v, faces, shared_faces, i, 0, 2, pri_t::FaceVert);
+            add_quad_faces(i, 2, 5, pri_t::FaceVert);
             break;
          }
          case Element::PYRAMID:
          {
-            for (int j = 0; j < 1; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 1; j < 5; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 1, pyr_t::FaceVert);
+            AddTriFaces(v, faces, shared_faces, i, 1, 5, pyr_t::FaceVert);
             break;
          }
          case Element::HEXAHEDRON:
          {
-            // find the face by the vertices with the smallest 3 numbers
-            // z = 0, y = 0, x = 1, y = 1, x = 0, z = 1
-            for (int j = 0; j < 6; j++)
-            {
-               const int *fv = hex_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 6, hex_t::FaceVert);
             break;
          }
          default:
@@ -2874,14 +2796,6 @@ STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
       }
    }
    face_nbr_el_to_face->Finalize();
-
-   delete sfaces_tbl;
-   if (ret_ftbl)
-   {
-      return faces_tbl;
-   }
-   delete faces_tbl;
-   return NULL;
 }
 
 int ParMesh::GetFaceNbrRank(int fn) const
@@ -2902,33 +2816,28 @@ int ParMesh::GetFaceNbrRank(int fn) const
 }
 
 void
-ParMesh::GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const
+ParMesh::GetFaceNbrElementFaces(int i, Array<int> &faces,
+                                Array<int> &orientations) const
 {
-   int n, j;
    int el_nbr = i - GetNE();
-   if (face_nbr_el_to_face)
+   if (face_nbr_el_to_face != nullptr && el_nbr < face_nbr_el_to_face->Size())
    {
-      face_nbr_el_to_face->GetRow(el_nbr, fcs);
+      face_nbr_el_to_face->GetRow(el_nbr, faces);
    }
    else
    {
       MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
-                 "face_nbr_el_to_face not generated.");
+                 "face_nbr_el_to_face not generated correctly.");
    }
-   if (el_nbr < face_nbr_el_ori.Size())
+
+   if (face_nbr_el_ori != nullptr && el_nbr < face_nbr_el_ori->Size())
    {
-      const int * row = face_nbr_el_ori.GetRow(el_nbr);
-      n = fcs.Size();
-      cor.SetSize(n);
-      for (j=0; j<n; j++)
-      {
-         cor[j] = row[j];
-      }
+      face_nbr_el_ori->GetRow(el_nbr, orientations);
    }
    else
    {
       MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
-                 "face_nbr_el_to_face not generated.");
+                 "face_nbr_el_ori not generated correctly.");
    }
 }
 
@@ -3188,7 +3097,7 @@ int ParMesh::GetSharedFace(int sface) const
    {
       MFEM_ASSERT(Dim > 1, "");
       const NCMesh::NCList &shared = pncmesh->GetSharedList(Dim-1);
-      int csize = (int) shared.conforming.Size();
+      int csize = shared.conforming.Size();
       return sface < csize
              ? shared.conforming[sface].index
              : shared.slaves[sface - csize].index;
@@ -4538,7 +4447,7 @@ void ParMesh::UniformRefinement3D()
 
    DSTable v_to_v(NumOfVertices);
    GetVertexToVertexTable(v_to_v);
-   STable3D *faces_tbl = GetFacesTable();
+   auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
 
    // call Mesh::UniformRefinement3D_base so that it won't update the nodes
    Array<int> f2qf;
@@ -4553,7 +4462,6 @@ void ParMesh::UniformRefinement3D()
    // update the groups
    UniformRefineGroups3D(old_nv, old_nedges, v_to_v, *faces_tbl,
                          f2qf.Size() ? &f2qf : NULL);
-   delete faces_tbl;
 
    UpdateNodes();
 }
@@ -6655,6 +6563,8 @@ void ParMesh::Swap(ParMesh &other)
    mfem::Swap(face_nbr_vertices, other.face_nbr_vertices);
    mfem::Swap(send_face_nbr_elements, other.send_face_nbr_elements);
    mfem::Swap(send_face_nbr_vertices, other.send_face_nbr_vertices);
+   std::swap(face_nbr_el_ori, other.face_nbr_el_ori);
+   std::swap(face_nbr_el_to_face, other.face_nbr_el_to_face);
 
    // Nodes, NCMesh, and NURBSExtension are taken care of by Mesh::Swap
    mfem::Swap(pncmesh, other.pncmesh);
@@ -6675,8 +6585,7 @@ void ParMesh::Destroy()
    }
    shared_edges.DeleteAll();
 
-   delete face_nbr_el_to_face;
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
 }
 
 ParMesh::~ParMesh()
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index 2ed8b00ec..ce0846c09 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -85,8 +85,11 @@ protected:
    // sface ids: all triangles first, then all quads
    Array<int> sface_lface;
 
-   Table *face_nbr_el_to_face;
-   Table  face_nbr_el_ori; // orientations for each face (from nbr processor)
+   /// Table that maps from face neighbor element number, to the face numbers of
+   /// that element.
+   std::unique_ptr<Table> face_nbr_el_to_face;
+   /// orientations for each face (from nbr processor)
+   std::unique_ptr<Table> face_nbr_el_ori;
 
    IsoparametricTransformation FaceNbrTransformation;
 
@@ -123,7 +126,32 @@ protected:
    bool DecodeFaceSplittings(HashTable<Hashed2> &v_to_v, const int *v,
                              const Array<unsigned> &codes, int &pos);
 
-   STable3D *GetFaceNbrElementToFaceTable(int ret_ftbl = 0);
+   // Given a completed FacesTable and SharedFacesTable, construct a table that
+   // maps from face neighbor element number, to the set of faces of that
+   // element. Store the resulting data in the member variable
+   // face_nbr_el_to_face. If the mesh is nonconforming, this also builds the
+   // the face_nbr_el_ori variable from the faces_info.
+   void BuildFaceNbrElementToFaceTable();
+
+   /**
+    * @brief Helper function for adding triangle face neighbor element to face
+    * table entries. Have to use a template here rather than lambda capture
+    * because the FaceVert entries in Geometry have inner size of 3 for tets and
+    * 4 for everything else.
+    *
+    * @tparam N Inner dimension on the fvert variable, 3 for tet, 4 otherwise
+    * @param v Set of vertices for this element
+    * @param faces Table of faces interior to this rank
+    * @param shared_faces Table of faces shared by this rank and another
+    * @param elem The face neighbor element
+    * @param start Starting index into fverts
+    * @param end End index into fverts
+    * @param fverts Array of face vertices for this particular geometry.
+    */
+   template <int N>
+   void AddTriFaces(const Array<int> &v, const std::unique_ptr<STable3D> &faces,
+                    const std::unique_ptr<STable3D> &shared_faces,
+                    int elem, int start, int end, const int fverts[][N]);
 
    void GetFaceNbrElementTransformation(
       int i, IsoparametricTransformation *ElTr);
@@ -297,7 +325,7 @@ protected:
 
 public:
    /// Default constructor. Create an empty @a ParMesh.
-   ParMesh() : MyComm(0), NRanks(0), MyRank(-1), face_nbr_el_to_face(NULL),
+   ParMesh() : MyComm(0), NRanks(0), MyRank(-1),
       glob_elem_offset(-1), glob_offset_sequence(-1),
       have_face_nbr_data(false), pncmesh(NULL) { }
 
@@ -476,7 +504,8 @@ public:
    int GetFaceNbrRank(int fn) const;
 
    /** Similar to Mesh::GetElementFaces */
-   void GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const;
+   void GetFaceNbrElementFaces(int i, Array<int> &faces,
+                               Array<int> &orientation) const;
 
    /** Similar to Mesh::GetFaceToElementTable with added face-neighbor elements
        with indices offset by the local number of elements. */
diff --git a/mesh/pncmesh.cpp b/mesh/pncmesh.cpp
index 96501a82c..3cf2a3a47 100644
--- a/mesh/pncmesh.cpp
+++ b/mesh/pncmesh.cpp
@@ -16,10 +16,12 @@
 #include "mesh_headers.hpp"
 #include "pncmesh.hpp"
 #include "../general/binaryio.hpp"
+#include "../general/communication.hpp"
 
 #include <numeric> // std::accumulate
 #include <map>
 #include <climits> // INT_MIN, INT_MAX
+#include <array>
 
 namespace mfem
 {
@@ -887,6 +889,7 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
 
    Array<Element*> fnbr;
    Array<Connection> send_elems;
+   std::map<int, std::vector<int>> recv_elems;
 
    // Counts the number of slave faces of a master. This may be larger than the
    // number of shared slaves if there exist degenerate slave-faces from face-edge constraints.
@@ -901,6 +904,11 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    fnbr.Reserve(bound);
    send_elems.Reserve(bound);
 
+   // If there are face neighbor elements with triangular faces, the
+   // `face_nbr_el_ori` structure will need to be built. This requires
+   // communication so we attempt to avoid it by checking first.
+   bool face_nbr_w_tri_faces = false;
+
    // go over all shared faces and collect face neighbor elements
    for (int i = 0; i < shared.conforming.Size(); i++)
    {
@@ -914,8 +922,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       if (e[0]->rank == MyRank) { std::swap(e[0], e[1]); }
       MFEM_ASSERT(e[0]->rank != MyRank && e[1]->rank == MyRank, "");
 
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
       fnbr.Append(e[0]);
       send_elems.Append(Connection(e[0]->rank, e[1]->index));
+      recv_elems[e[0]->rank].push_back(e[0]->index);
    }
 
    for (int i = 0; i < shared.masters.Size(); i++)
@@ -938,8 +950,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
          }
          if (loc0) { std::swap(e[0], e[1]); }
 
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
          fnbr.Append(e[0]);
          send_elems.Append(Connection(e[0]->rank, e[1]->index));
+         recv_elems[e[0]->rank].push_back(e[0]->index);
       }
    }
 
@@ -1022,6 +1038,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    send_elems.Sort();
    send_elems.Unique();
 
+   for (auto &kv : recv_elems)
+   {
+      std::sort(kv.second.begin(), kv.second.end());
+      kv.second.erase(std::unique(kv.second.begin(), kv.second.end()),
+                      kv.second.end());
+   }
+
    for (int i = 0, last_rank = -1; i < send_elems.Size(); i++)
    {
       Connection &c = send_elems[i];
@@ -1175,6 +1198,118 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       }
    }
 
+
+   // In 3D some extra orientation data structures can be needed.
+   if (Dim == 3)
+   {
+      // Populates face_nbr_el_to_face, always needed.
+      pmesh.BuildFaceNbrElementToFaceTable();
+
+      if (face_nbr_w_tri_faces)
+      {
+         // There are face neighbor elements with triangular faces, need to
+         // perform communication to ensure the orientation is valid.
+         using RankToOrientation = std::map<int, std::vector<std::array<int, 6>>>;
+         constexpr std::array<int, 6> unset_ori{{-1,-1,-1,-1,-1,-1}};
+         const int rank = pmesh.GetMyRank();
+
+         // Loop over send elems, compute the orientation and place in the buffer to
+         // send to each processor. Note elements are lexicographically sorted
+         // with rank and element number, and this ordering holds across processors.
+         RankToOrientation send_rank_to_face_neighbor_orientations;
+         Array<int> orientations, faces;
+
+         // send_elems goes from rank of the receiving processor, to the index
+         // of the face neighbor element on this processor.
+         for (const auto &se : send_elems)
+         {
+            const auto &true_rank = pmesh.face_nbr_group[se.from];
+            pmesh.GetElementFaces(se.to, faces, orientations);
+
+            // Place a new entry of unset orientations
+            send_rank_to_face_neighbor_orientations[true_rank].emplace_back(unset_ori);
+
+            // Copy the entries, any unset faces will remain -1.
+            std::copy(orientations.begin(), orientations.end(),
+                      send_rank_to_face_neighbor_orientations[true_rank].back().begin());
+         }
+
+         // Initialize the receive buffers and resize to match the expected
+         // number of elements coming in. The copy ensures the appropriate rank
+         // pairings are in place, and for a purely conformal interface, the
+         // resize is a no-op.
+         auto recv_rank_to_face_neighbor_orientations =
+            send_rank_to_face_neighbor_orientations;
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            kv.second.resize(recv_elems[kv.first].size());
+         }
+
+         // For asynchronous send/recv, will use arrays of requests to monitor the
+         // status of the connections.
+         std::vector<MPI_Request> send_requests, recv_requests;
+         std::vector<MPI_Status> status(nranks);
+
+         // NOTE: This is CRITICAL, to ensure the addresses of these requests
+         // do not change between the send/recv and the wait.
+         send_requests.reserve(nranks);
+         recv_requests.reserve(nranks);
+
+         // Shared face communication is bidirectional -> any rank to whom
+         // orientations must be sent, will need to send orientations back.
+         // The orientation data is contiguous because std::array<int,6> is an
+         // aggregate.
+
+         // Loop over each communication pairing, and dispatch the buffer loaded
+         // with  all the orientation data.
+         for (const auto &kv : send_rank_to_face_neighbor_orientations)
+         {
+            send_requests.emplace_back(); // instantiate a request for tracking.
+
+            // low rank sends on low, high rank sends on high.
+            const int send_tag = (rank < kv.first)
+                                 ? std::min(rank, kv.first)
+                                 : std::max(rank, kv.first);
+            MPI_Isend(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, send_tag, pmesh.MyComm, &send_requests.back());
+         }
+
+         // Loop over the communication pairing again, and receive the
+         // symmetric buffer from the other processor.
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            recv_requests.emplace_back(); // instantiate a request for tracking
+
+            // low rank receives on high, high rank receives on low.
+            const int recv_tag = (rank < kv.first)
+                                 ? std::max(rank, kv.first)
+                                 : std::min(rank, kv.first);
+            MPI_Irecv(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, recv_tag, pmesh.MyComm, &recv_requests.back());
+         }
+
+         // Wait until all receive buffers are full before beginning to process.
+         MPI_Waitall(int(recv_requests.size()), recv_requests.data(), status.data());
+
+         pmesh.face_nbr_el_ori.reset(new Table(pmesh.face_nbr_elements.Size(), 6));
+         int elem = 0;
+         for (const auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            // All elements associated to this face-neighbor rank
+            for (const auto &eo : kv.second)
+            {
+               std::copy(eo.begin(), eo.end(), pmesh.face_nbr_el_ori->GetRow(elem));
+               ++elem;
+            }
+         }
+         pmesh.face_nbr_el_ori->Finalize();
+
+         // Must wait for all send buffers to be released before the scope closes.
+         MPI_Waitall(int(send_requests.size()), send_requests.data(), status.data());
+      }
+   }
+
+
    // NOTE: this function skips ParMesh::send_face_nbr_vertices and
    // ParMesh::face_nbr_vertices_offset, these are not used outside of ParMesh
 }
diff --git a/mesh/pncmesh.hpp b/mesh/pncmesh.hpp
index 03689dfc4..df5fb929e 100644
--- a/mesh/pncmesh.hpp
+++ b/mesh/pncmesh.hpp
@@ -108,9 +108,7 @@ public:
        passed. */
    void Rebalance(const Array<int> *custom_partition = NULL);
 
-
    // interface for ParFiniteElementSpace
-
    int GetNElements() const { return NElements; }
 
    int GetNGhostVertices() const { return NGhostVertices; }
@@ -141,8 +139,8 @@ public:
       return (index < NFaces) ? face_orient[index] : 0;
    }
 
-   typedef short GroupId;
-   typedef std::vector<int> CommGroup;
+   using GroupId = short;
+   using CommGroup = std::vector<int>;
 
    /// Return vertex/edge/face ('entity' == 0/1/2, resp.) owner.
    GroupId GetEntityOwnerId(int entity, int index)
diff --git a/mesh/submesh/psubmesh.cpp b/mesh/submesh/psubmesh.cpp
index 017564545..a7e5a772f 100644
--- a/mesh/submesh/psubmesh.cpp
+++ b/mesh/submesh/psubmesh.cpp
@@ -259,22 +259,17 @@ ParSubMesh::ParSubMesh(const ParMesh &parent, SubMesh::From from,
 
       boundary.SetSize(NumOfBdrElements);
       be2face.SetSize(NumOfBdrElements);
-      Array<int> parent_face_to_be;
-      int max_bdr_attr = -1;
-      if (Dim == 3)
-      {
-         parent_face_to_be = parent.GetFaceToBdrElMap();
-         max_bdr_attr = parent.bdr_attributes.Max();
-      }
+      Array<int> parent_face_to_be = parent.GetFaceToBdrElMap();
+      int max_bdr_attr = parent.bdr_attributes.Max();
       for (int i = 0, j = 0; i < num_of_faces_or_edges; i++)
       {
          if (GetFaceInformation(i).IsBoundary())
          {
             boundary[j] = faces[i]->Duplicate(this);
-
-            if (Dim == 3)
+            if (from == SubMesh::From::Domain && Dim >= 2)
             {
-               int pbeid = parent_face_to_be[parent_face_ids_[i]];
+               int pbeid = Dim == 3 ? parent_face_to_be[parent_face_ids_[i]] :
+                           parent_face_to_be[parent_edge_ids_[i]];
                if (pbeid != -1)
                {
                   boundary[j]->SetAttribute(parent.GetBdrAttribute(pbeid));
diff --git a/mesh/submesh/submesh.cpp b/mesh/submesh/submesh.cpp
index c9f0b8508..b094d67fe 100644
--- a/mesh/submesh/submesh.cpp
+++ b/mesh/submesh/submesh.cpp
@@ -108,6 +108,31 @@ SubMesh::SubMesh(const Mesh &parent, From from,
    }
    else if (Dim == 2)
    {
+      if (from == From::Domain)
+      {
+         parent_edge_ids_ = SubMeshUtils::BuildFaceMap(parent, *this,
+                                                       parent_element_ids_);
+         Array<int> parent_face_to_be = parent.GetFaceToBdrElMap();
+         int max_bdr_attr = parent.bdr_attributes.Max();
+
+         for (int i = 0; i < NumOfBdrElements; i++)
+         {
+            int pbeid = parent_face_to_be[parent_edge_ids_[GetBdrFace(i)]];
+            if (pbeid != -1)
+            {
+               int attr = parent.GetBdrElement(pbeid)->GetAttribute();
+               GetBdrElement(i)->SetAttribute(attr);
+            }
+            else
+            {
+               // This case happens when a domain is extracted, but the root parent
+               // mesh didn't have a boundary element on the surface that defined
+               // it's boundary. It still creates a valid mesh, so we allow it.
+               GetBdrElement(i)->SetAttribute(max_bdr_attr + 1);
+            }
+         }
+      }
+
       parent_face_ori_.SetSize(NumOfElements);
 
       for (int i = 0; i < NumOfElements; i++)
diff --git a/mesh/submesh/submesh.hpp b/mesh/submesh/submesh.hpp
index 050111f7f..33ca72ea1 100644
--- a/mesh/submesh/submesh.hpp
+++ b/mesh/submesh/submesh.hpp
@@ -199,6 +199,10 @@ private:
    /// vertex ids.
    Array<int> parent_vertex_ids_;
 
+   /// Mapping from SubMesh edge ids (index of the array), to the parent Mesh
+   /// face ids.
+   Array<int> parent_edge_ids_;
+
    /// Mapping from SubMesh face ids (index of the array), to the parent Mesh
    /// face ids.
    Array<int> parent_face_ids_;
diff --git a/mesh/submesh/submesh_utils.cpp b/mesh/submesh/submesh_utils.cpp
index 3a8098727..c9a021dfe 100644
--- a/mesh/submesh/submesh_utils.cpp
+++ b/mesh/submesh/submesh_utils.cpp
@@ -191,15 +191,23 @@ Array<int> BuildFaceMap(const Mesh& pm, const Mesh& sm,
 {
    // TODO: Check if parent is really a parent of mesh
 
-   Array<int> pfids(sm.GetNFaces());
+   Array<int> pfids(sm.GetNumFaces());
    pfids = -1;
    for (int i = 0; i < sm.GetNE(); i++)
    {
       int peid = parent_element_ids[i];
 
       Array<int> sel_faces, pel_faces, o;
-      sm.GetElementFaces(i, sel_faces, o);
-      pm.GetElementFaces(peid, pel_faces, o);
+      if (pm.Dimension() == 2)
+      {
+         sm.GetElementEdges(i, sel_faces, o);
+         pm.GetElementEdges(peid, pel_faces, o);
+      }
+      else
+      {
+         sm.GetElementFaces(i, sel_faces, o);
+         pm.GetElementFaces(peid, pel_faces, o);
+      }
 
       MFEM_ASSERT(sel_faces.Size() == pel_faces.Size(), "internal error");
 
diff --git a/miniapps/meshing/CMakeLists.txt b/miniapps/meshing/CMakeLists.txt
index 50ae7139d..1f242b8a4 100644
--- a/miniapps/meshing/CMakeLists.txt
+++ b/miniapps/meshing/CMakeLists.txt
@@ -13,9 +13,11 @@ set(MESH_FILES
   amr-quad-q2.mesh
   blade.mesh
   cube.mesh
+  cube-tet.mesh
   icf.mesh
   jagged.mesh
   square01.mesh
+  square01-tri.mesh
   stretched2D.mesh
 )
 
@@ -109,6 +111,12 @@ if (MFEM_USE_MPI)
     LIBRARIES mfem mfem-common)
   add_dependencies(pmesh-fitting copy_miniapps_meshing_data)
 
+  add_mfem_miniapp(fit-node-position
+    MAIN fit-node-position.cpp
+    ${MFEM_MINIAPPS_COMMON_HEADERS}
+    LIBRARIES mfem mfem-common)
+  add_dependencies(fit-node-position copy_miniapps_meshing_data)
+
   add_mfem_miniapp(pminimal-surface
     MAIN pminimal-surface.cpp
     LIBRARIES mfem)
diff --git a/miniapps/meshing/cube-tet.mesh b/miniapps/meshing/cube-tet.mesh
new file mode 100644
index 000000000..90d52e042
--- /dev/null
+++ b/miniapps/meshing/cube-tet.mesh
@@ -0,0 +1,2375 @@
+MFEM mesh v1.0
+
+#
+# MFEM Geometry Types (see mesh/geom.hpp):
+#
+# POINT       = 0
+# SEGMENT     = 1
+# TRIANGLE    = 2
+# SQUARE      = 3
+# TETRAHEDRON = 4
+# CUBE        = 5
+# PRISM       = 6
+#
+
+dimension
+3
+
+elements
+1536
+1 4 0 1 189 125
+1 4 5 0 189 125
+1 4 6 5 189 125
+1 4 1 6 189 125
+1 4 1 26 190 125
+1 4 6 1 190 125
+1 4 31 6 190 125
+1 4 26 31 190 125
+1 4 25 26 125 191
+1 4 30 25 125 191
+1 4 31 30 125 191
+1 4 26 31 125 191
+1 4 0 25 125 192
+1 4 5 0 125 192
+1 4 30 5 125 192
+1 4 25 30 125 192
+1 4 30 31 125 193
+1 4 5 30 125 193
+1 4 6 5 125 193
+1 4 31 6 125 193
+1 4 25 26 194 125
+1 4 0 25 194 125
+1 4 1 0 194 125
+1 4 26 1 194 125
+1 4 1 2 195 126
+1 4 6 1 195 126
+1 4 7 6 195 126
+1 4 2 7 195 126
+1 4 2 27 196 126
+1 4 7 2 196 126
+1 4 32 7 196 126
+1 4 27 32 196 126
+1 4 26 27 126 197
+1 4 31 26 126 197
+1 4 32 31 126 197
+1 4 27 32 126 197
+1 4 1 26 126 190
+1 4 6 1 126 190
+1 4 31 6 126 190
+1 4 26 31 126 190
+1 4 31 32 126 198
+1 4 6 31 126 198
+1 4 7 6 126 198
+1 4 32 7 126 198
+1 4 26 27 199 126
+1 4 1 26 199 126
+1 4 2 1 199 126
+1 4 27 2 199 126
+1 4 2 3 200 127
+1 4 7 2 200 127
+1 4 8 7 200 127
+1 4 3 8 200 127
+1 4 3 28 201 127
+1 4 8 3 201 127
+1 4 33 8 201 127
+1 4 28 33 201 127
+1 4 27 28 127 202
+1 4 32 27 127 202
+1 4 33 32 127 202
+1 4 28 33 127 202
+1 4 2 27 127 196
+1 4 7 2 127 196
+1 4 32 7 127 196
+1 4 27 32 127 196
+1 4 32 33 127 203
+1 4 7 32 127 203
+1 4 8 7 127 203
+1 4 33 8 127 203
+1 4 27 28 204 127
+1 4 2 27 204 127
+1 4 3 2 204 127
+1 4 28 3 204 127
+1 4 3 4 205 128
+1 4 8 3 205 128
+1 4 9 8 205 128
+1 4 4 9 205 128
+1 4 4 29 206 128
+1 4 9 4 206 128
+1 4 34 9 206 128
+1 4 29 34 206 128
+1 4 28 29 128 207
+1 4 33 28 128 207
+1 4 34 33 128 207
+1 4 29 34 128 207
+1 4 3 28 128 201
+1 4 8 3 128 201
+1 4 33 8 128 201
+1 4 28 33 128 201
+1 4 33 34 128 208
+1 4 8 33 128 208
+1 4 9 8 128 208
+1 4 34 9 128 208
+1 4 28 29 209 128
+1 4 3 28 209 128
+1 4 4 3 209 128
+1 4 29 4 209 128
+1 4 5 6 210 129
+1 4 10 5 210 129
+1 4 11 10 210 129
+1 4 6 11 210 129
+1 4 6 31 211 129
+1 4 11 6 211 129
+1 4 36 11 211 129
+1 4 31 36 211 129
+1 4 30 31 129 212
+1 4 35 30 129 212
+1 4 36 35 129 212
+1 4 31 36 129 212
+1 4 5 30 129 213
+1 4 10 5 129 213
+1 4 35 10 129 213
+1 4 30 35 129 213
+1 4 35 36 129 214
+1 4 10 35 129 214
+1 4 11 10 129 214
+1 4 36 11 129 214
+1 4 30 31 193 129
+1 4 5 30 193 129
+1 4 6 5 193 129
+1 4 31 6 193 129
+1 4 6 7 215 130
+1 4 11 6 215 130
+1 4 12 11 215 130
+1 4 7 12 215 130
+1 4 7 32 216 130
+1 4 12 7 216 130
+1 4 37 12 216 130
+1 4 32 37 216 130
+1 4 31 32 130 217
+1 4 36 31 130 217
+1 4 37 36 130 217
+1 4 32 37 130 217
+1 4 6 31 130 211
+1 4 11 6 130 211
+1 4 36 11 130 211
+1 4 31 36 130 211
+1 4 36 37 130 218
+1 4 11 36 130 218
+1 4 12 11 130 218
+1 4 37 12 130 218
+1 4 31 32 198 130
+1 4 6 31 198 130
+1 4 7 6 198 130
+1 4 32 7 198 130
+1 4 7 8 219 131
+1 4 12 7 219 131
+1 4 13 12 219 131
+1 4 8 13 219 131
+1 4 8 33 220 131
+1 4 13 8 220 131
+1 4 38 13 220 131
+1 4 33 38 220 131
+1 4 32 33 131 221
+1 4 37 32 131 221
+1 4 38 37 131 221
+1 4 33 38 131 221
+1 4 7 32 131 216
+1 4 12 7 131 216
+1 4 37 12 131 216
+1 4 32 37 131 216
+1 4 37 38 131 222
+1 4 12 37 131 222
+1 4 13 12 131 222
+1 4 38 13 131 222
+1 4 32 33 203 131
+1 4 7 32 203 131
+1 4 8 7 203 131
+1 4 33 8 203 131
+1 4 8 9 223 132
+1 4 13 8 223 132
+1 4 14 13 223 132
+1 4 9 14 223 132
+1 4 9 34 224 132
+1 4 14 9 224 132
+1 4 39 14 224 132
+1 4 34 39 224 132
+1 4 33 34 132 225
+1 4 38 33 132 225
+1 4 39 38 132 225
+1 4 34 39 132 225
+1 4 8 33 132 220
+1 4 13 8 132 220
+1 4 38 13 132 220
+1 4 33 38 132 220
+1 4 38 39 132 226
+1 4 13 38 132 226
+1 4 14 13 132 226
+1 4 39 14 132 226
+1 4 33 34 208 132
+1 4 8 33 208 132
+1 4 9 8 208 132
+1 4 34 9 208 132
+1 4 10 11 227 133
+1 4 15 10 227 133
+1 4 16 15 227 133
+1 4 11 16 227 133
+1 4 11 36 228 133
+1 4 16 11 228 133
+1 4 41 16 228 133
+1 4 36 41 228 133
+1 4 35 36 133 229
+1 4 40 35 133 229
+1 4 41 40 133 229
+1 4 36 41 133 229
+1 4 10 35 133 230
+1 4 15 10 133 230
+1 4 40 15 133 230
+1 4 35 40 133 230
+1 4 40 41 133 231
+1 4 15 40 133 231
+1 4 16 15 133 231
+1 4 41 16 133 231
+1 4 35 36 214 133
+1 4 10 35 214 133
+1 4 11 10 214 133
+1 4 36 11 214 133
+1 4 11 12 232 134
+1 4 16 11 232 134
+1 4 17 16 232 134
+1 4 12 17 232 134
+1 4 12 37 233 134
+1 4 17 12 233 134
+1 4 42 17 233 134
+1 4 37 42 233 134
+1 4 36 37 134 234
+1 4 41 36 134 234
+1 4 42 41 134 234
+1 4 37 42 134 234
+1 4 11 36 134 228
+1 4 16 11 134 228
+1 4 41 16 134 228
+1 4 36 41 134 228
+1 4 41 42 134 235
+1 4 16 41 134 235
+1 4 17 16 134 235
+1 4 42 17 134 235
+1 4 36 37 218 134
+1 4 11 36 218 134
+1 4 12 11 218 134
+1 4 37 12 218 134
+1 4 12 13 236 135
+1 4 17 12 236 135
+1 4 18 17 236 135
+1 4 13 18 236 135
+1 4 13 38 237 135
+1 4 18 13 237 135
+1 4 43 18 237 135
+1 4 38 43 237 135
+1 4 37 38 135 238
+1 4 42 37 135 238
+1 4 43 42 135 238
+1 4 38 43 135 238
+1 4 12 37 135 233
+1 4 17 12 135 233
+1 4 42 17 135 233
+1 4 37 42 135 233
+1 4 42 43 135 239
+1 4 17 42 135 239
+1 4 18 17 135 239
+1 4 43 18 135 239
+1 4 37 38 222 135
+1 4 12 37 222 135
+1 4 13 12 222 135
+1 4 38 13 222 135
+1 4 13 14 240 136
+1 4 18 13 240 136
+1 4 19 18 240 136
+1 4 14 19 240 136
+1 4 14 39 241 136
+1 4 19 14 241 136
+1 4 44 19 241 136
+1 4 39 44 241 136
+1 4 38 39 136 242
+1 4 43 38 136 242
+1 4 44 43 136 242
+1 4 39 44 136 242
+1 4 13 38 136 237
+1 4 18 13 136 237
+1 4 43 18 136 237
+1 4 38 43 136 237
+1 4 43 44 136 243
+1 4 18 43 136 243
+1 4 19 18 136 243
+1 4 44 19 136 243
+1 4 38 39 226 136
+1 4 13 38 226 136
+1 4 14 13 226 136
+1 4 39 14 226 136
+1 4 15 16 244 137
+1 4 20 15 244 137
+1 4 21 20 244 137
+1 4 16 21 244 137
+1 4 16 41 245 137
+1 4 21 16 245 137
+1 4 46 21 245 137
+1 4 41 46 245 137
+1 4 40 41 137 246
+1 4 45 40 137 246
+1 4 46 45 137 246
+1 4 41 46 137 246
+1 4 15 40 137 247
+1 4 20 15 137 247
+1 4 45 20 137 247
+1 4 40 45 137 247
+1 4 45 46 137 248
+1 4 20 45 137 248
+1 4 21 20 137 248
+1 4 46 21 137 248
+1 4 40 41 231 137
+1 4 15 40 231 137
+1 4 16 15 231 137
+1 4 41 16 231 137
+1 4 16 17 249 138
+1 4 21 16 249 138
+1 4 22 21 249 138
+1 4 17 22 249 138
+1 4 17 42 250 138
+1 4 22 17 250 138
+1 4 47 22 250 138
+1 4 42 47 250 138
+1 4 41 42 138 251
+1 4 46 41 138 251
+1 4 47 46 138 251
+1 4 42 47 138 251
+1 4 16 41 138 245
+1 4 21 16 138 245
+1 4 46 21 138 245
+1 4 41 46 138 245
+1 4 46 47 138 252
+1 4 21 46 138 252
+1 4 22 21 138 252
+1 4 47 22 138 252
+1 4 41 42 235 138
+1 4 16 41 235 138
+1 4 17 16 235 138
+1 4 42 17 235 138
+1 4 17 18 253 139
+1 4 22 17 253 139
+1 4 23 22 253 139
+1 4 18 23 253 139
+1 4 18 43 254 139
+1 4 23 18 254 139
+1 4 48 23 254 139
+1 4 43 48 254 139
+1 4 42 43 139 255
+1 4 47 42 139 255
+1 4 48 47 139 255
+1 4 43 48 139 255
+1 4 17 42 139 250
+1 4 22 17 139 250
+1 4 47 22 139 250
+1 4 42 47 139 250
+1 4 47 48 139 256
+1 4 22 47 139 256
+1 4 23 22 139 256
+1 4 48 23 139 256
+1 4 42 43 239 139
+1 4 17 42 239 139
+1 4 18 17 239 139
+1 4 43 18 239 139
+1 4 18 19 257 140
+1 4 23 18 257 140
+1 4 24 23 257 140
+1 4 19 24 257 140
+1 4 19 44 258 140
+1 4 24 19 258 140
+1 4 49 24 258 140
+1 4 44 49 258 140
+1 4 43 44 140 259
+1 4 48 43 140 259
+1 4 49 48 140 259
+1 4 44 49 140 259
+1 4 18 43 140 254
+1 4 23 18 140 254
+1 4 48 23 140 254
+1 4 43 48 140 254
+1 4 48 49 140 260
+1 4 23 48 140 260
+1 4 24 23 140 260
+1 4 49 24 140 260
+1 4 43 44 243 140
+1 4 18 43 243 140
+1 4 19 18 243 140
+1 4 44 19 243 140
+1 4 25 26 191 141
+1 4 30 25 191 141
+1 4 31 30 191 141
+1 4 26 31 191 141
+1 4 26 51 261 141
+1 4 31 26 261 141
+1 4 56 31 261 141
+1 4 51 56 261 141
+1 4 50 51 141 262
+1 4 55 50 141 262
+1 4 56 55 141 262
+1 4 51 56 141 262
+1 4 25 50 141 263
+1 4 30 25 141 263
+1 4 55 30 141 263
+1 4 50 55 141 263
+1 4 55 56 141 264
+1 4 30 55 141 264
+1 4 31 30 141 264
+1 4 56 31 141 264
+1 4 50 51 265 141
+1 4 25 50 265 141
+1 4 26 25 265 141
+1 4 51 26 265 141
+1 4 26 27 197 142
+1 4 31 26 197 142
+1 4 32 31 197 142
+1 4 27 32 197 142
+1 4 27 52 266 142
+1 4 32 27 266 142
+1 4 57 32 266 142
+1 4 52 57 266 142
+1 4 51 52 142 267
+1 4 56 51 142 267
+1 4 57 56 142 267
+1 4 52 57 142 267
+1 4 26 51 142 261
+1 4 31 26 142 261
+1 4 56 31 142 261
+1 4 51 56 142 261
+1 4 56 57 142 268
+1 4 31 56 142 268
+1 4 32 31 142 268
+1 4 57 32 142 268
+1 4 51 52 269 142
+1 4 26 51 269 142
+1 4 27 26 269 142
+1 4 52 27 269 142
+1 4 27 28 202 143
+1 4 32 27 202 143
+1 4 33 32 202 143
+1 4 28 33 202 143
+1 4 28 53 270 143
+1 4 33 28 270 143
+1 4 58 33 270 143
+1 4 53 58 270 143
+1 4 52 53 143 271
+1 4 57 52 143 271
+1 4 58 57 143 271
+1 4 53 58 143 271
+1 4 27 52 143 266
+1 4 32 27 143 266
+1 4 57 32 143 266
+1 4 52 57 143 266
+1 4 57 58 143 272
+1 4 32 57 143 272
+1 4 33 32 143 272
+1 4 58 33 143 272
+1 4 52 53 273 143
+1 4 27 52 273 143
+1 4 28 27 273 143
+1 4 53 28 273 143
+1 4 28 29 207 144
+1 4 33 28 207 144
+1 4 34 33 207 144
+1 4 29 34 207 144
+1 4 29 54 274 144
+1 4 34 29 274 144
+1 4 59 34 274 144
+1 4 54 59 274 144
+1 4 53 54 144 275
+1 4 58 53 144 275
+1 4 59 58 144 275
+1 4 54 59 144 275
+1 4 28 53 144 270
+1 4 33 28 144 270
+1 4 58 33 144 270
+1 4 53 58 144 270
+1 4 58 59 144 276
+1 4 33 58 144 276
+1 4 34 33 144 276
+1 4 59 34 144 276
+1 4 53 54 277 144
+1 4 28 53 277 144
+1 4 29 28 277 144
+1 4 54 29 277 144
+1 4 30 31 212 145
+1 4 35 30 212 145
+1 4 36 35 212 145
+1 4 31 36 212 145
+1 4 31 56 278 145
+1 4 36 31 278 145
+1 4 61 36 278 145
+1 4 56 61 278 145
+1 4 55 56 145 279
+1 4 60 55 145 279
+1 4 61 60 145 279
+1 4 56 61 145 279
+1 4 30 55 145 280
+1 4 35 30 145 280
+1 4 60 35 145 280
+1 4 55 60 145 280
+1 4 60 61 145 281
+1 4 35 60 145 281
+1 4 36 35 145 281
+1 4 61 36 145 281
+1 4 55 56 264 145
+1 4 30 55 264 145
+1 4 31 30 264 145
+1 4 56 31 264 145
+1 4 31 32 217 146
+1 4 36 31 217 146
+1 4 37 36 217 146
+1 4 32 37 217 146
+1 4 32 57 282 146
+1 4 37 32 282 146
+1 4 62 37 282 146
+1 4 57 62 282 146
+1 4 56 57 146 283
+1 4 61 56 146 283
+1 4 62 61 146 283
+1 4 57 62 146 283
+1 4 31 56 146 278
+1 4 36 31 146 278
+1 4 61 36 146 278
+1 4 56 61 146 278
+1 4 61 62 146 284
+1 4 36 61 146 284
+1 4 37 36 146 284
+1 4 62 37 146 284
+1 4 56 57 268 146
+1 4 31 56 268 146
+1 4 32 31 268 146
+1 4 57 32 268 146
+1 4 32 33 221 147
+1 4 37 32 221 147
+1 4 38 37 221 147
+1 4 33 38 221 147
+1 4 33 58 285 147
+1 4 38 33 285 147
+1 4 63 38 285 147
+1 4 58 63 285 147
+1 4 57 58 147 286
+1 4 62 57 147 286
+1 4 63 62 147 286
+1 4 58 63 147 286
+1 4 32 57 147 282
+1 4 37 32 147 282
+1 4 62 37 147 282
+1 4 57 62 147 282
+1 4 62 63 147 287
+1 4 37 62 147 287
+1 4 38 37 147 287
+1 4 63 38 147 287
+1 4 57 58 272 147
+1 4 32 57 272 147
+1 4 33 32 272 147
+1 4 58 33 272 147
+1 4 33 34 225 148
+1 4 38 33 225 148
+1 4 39 38 225 148
+1 4 34 39 225 148
+1 4 34 59 288 148
+1 4 39 34 288 148
+1 4 64 39 288 148
+1 4 59 64 288 148
+1 4 58 59 148 289
+1 4 63 58 148 289
+1 4 64 63 148 289
+1 4 59 64 148 289
+1 4 33 58 148 285
+1 4 38 33 148 285
+1 4 63 38 148 285
+1 4 58 63 148 285
+1 4 63 64 148 290
+1 4 38 63 148 290
+1 4 39 38 148 290
+1 4 64 39 148 290
+1 4 58 59 276 148
+1 4 33 58 276 148
+1 4 34 33 276 148
+1 4 59 34 276 148
+1 4 35 36 229 149
+1 4 40 35 229 149
+1 4 41 40 229 149
+1 4 36 41 229 149
+1 4 36 61 291 149
+1 4 41 36 291 149
+1 4 66 41 291 149
+1 4 61 66 291 149
+1 4 60 61 149 292
+1 4 65 60 149 292
+1 4 66 65 149 292
+1 4 61 66 149 292
+1 4 35 60 149 293
+1 4 40 35 149 293
+1 4 65 40 149 293
+1 4 60 65 149 293
+1 4 65 66 149 294
+1 4 40 65 149 294
+1 4 41 40 149 294
+1 4 66 41 149 294
+1 4 60 61 281 149
+1 4 35 60 281 149
+1 4 36 35 281 149
+1 4 61 36 281 149
+1 4 36 37 234 150
+1 4 41 36 234 150
+1 4 42 41 234 150
+1 4 37 42 234 150
+1 4 37 62 295 150
+1 4 42 37 295 150
+1 4 67 42 295 150
+1 4 62 67 295 150
+1 4 61 62 150 296
+1 4 66 61 150 296
+1 4 67 66 150 296
+1 4 62 67 150 296
+1 4 36 61 150 291
+1 4 41 36 150 291
+1 4 66 41 150 291
+1 4 61 66 150 291
+1 4 66 67 150 297
+1 4 41 66 150 297
+1 4 42 41 150 297
+1 4 67 42 150 297
+1 4 61 62 284 150
+1 4 36 61 284 150
+1 4 37 36 284 150
+1 4 62 37 284 150
+1 4 37 38 238 151
+1 4 42 37 238 151
+1 4 43 42 238 151
+1 4 38 43 238 151
+1 4 38 63 298 151
+1 4 43 38 298 151
+1 4 68 43 298 151
+1 4 63 68 298 151
+1 4 62 63 151 299
+1 4 67 62 151 299
+1 4 68 67 151 299
+1 4 63 68 151 299
+1 4 37 62 151 295
+1 4 42 37 151 295
+1 4 67 42 151 295
+1 4 62 67 151 295
+1 4 67 68 151 300
+1 4 42 67 151 300
+1 4 43 42 151 300
+1 4 68 43 151 300
+1 4 62 63 287 151
+1 4 37 62 287 151
+1 4 38 37 287 151
+1 4 63 38 287 151
+1 4 38 39 242 152
+1 4 43 38 242 152
+1 4 44 43 242 152
+1 4 39 44 242 152
+1 4 39 64 301 152
+1 4 44 39 301 152
+1 4 69 44 301 152
+1 4 64 69 301 152
+1 4 63 64 152 302
+1 4 68 63 152 302
+1 4 69 68 152 302
+1 4 64 69 152 302
+1 4 38 63 152 298
+1 4 43 38 152 298
+1 4 68 43 152 298
+1 4 63 68 152 298
+1 4 68 69 152 303
+1 4 43 68 152 303
+1 4 44 43 152 303
+1 4 69 44 152 303
+1 4 63 64 290 152
+1 4 38 63 290 152
+1 4 39 38 290 152
+1 4 64 39 290 152
+1 4 40 41 246 153
+1 4 45 40 246 153
+1 4 46 45 246 153
+1 4 41 46 246 153
+1 4 41 66 304 153
+1 4 46 41 304 153
+1 4 71 46 304 153
+1 4 66 71 304 153
+1 4 65 66 153 305
+1 4 70 65 153 305
+1 4 71 70 153 305
+1 4 66 71 153 305
+1 4 40 65 153 306
+1 4 45 40 153 306
+1 4 70 45 153 306
+1 4 65 70 153 306
+1 4 70 71 153 307
+1 4 45 70 153 307
+1 4 46 45 153 307
+1 4 71 46 153 307
+1 4 65 66 294 153
+1 4 40 65 294 153
+1 4 41 40 294 153
+1 4 66 41 294 153
+1 4 41 42 251 154
+1 4 46 41 251 154
+1 4 47 46 251 154
+1 4 42 47 251 154
+1 4 42 67 308 154
+1 4 47 42 308 154
+1 4 72 47 308 154
+1 4 67 72 308 154
+1 4 66 67 154 309
+1 4 71 66 154 309
+1 4 72 71 154 309
+1 4 67 72 154 309
+1 4 41 66 154 304
+1 4 46 41 154 304
+1 4 71 46 154 304
+1 4 66 71 154 304
+1 4 71 72 154 310
+1 4 46 71 154 310
+1 4 47 46 154 310
+1 4 72 47 154 310
+1 4 66 67 297 154
+1 4 41 66 297 154
+1 4 42 41 297 154
+1 4 67 42 297 154
+1 4 42 43 255 155
+1 4 47 42 255 155
+1 4 48 47 255 155
+1 4 43 48 255 155
+1 4 43 68 311 155
+1 4 48 43 311 155
+1 4 73 48 311 155
+1 4 68 73 311 155
+1 4 67 68 155 312
+1 4 72 67 155 312
+1 4 73 72 155 312
+1 4 68 73 155 312
+1 4 42 67 155 308
+1 4 47 42 155 308
+1 4 72 47 155 308
+1 4 67 72 155 308
+1 4 72 73 155 313
+1 4 47 72 155 313
+1 4 48 47 155 313
+1 4 73 48 155 313
+1 4 67 68 300 155
+1 4 42 67 300 155
+1 4 43 42 300 155
+1 4 68 43 300 155
+1 4 43 44 259 156
+1 4 48 43 259 156
+1 4 49 48 259 156
+1 4 44 49 259 156
+1 4 44 69 314 156
+1 4 49 44 314 156
+1 4 74 49 314 156
+1 4 69 74 314 156
+1 4 68 69 156 315
+1 4 73 68 156 315
+1 4 74 73 156 315
+1 4 69 74 156 315
+1 4 43 68 156 311
+1 4 48 43 156 311
+1 4 73 48 156 311
+1 4 68 73 156 311
+1 4 73 74 156 316
+1 4 48 73 156 316
+1 4 49 48 156 316
+1 4 74 49 156 316
+1 4 68 69 303 156
+1 4 43 68 303 156
+1 4 44 43 303 156
+1 4 69 44 303 156
+1 4 50 51 262 157
+1 4 55 50 262 157
+1 4 56 55 262 157
+1 4 51 56 262 157
+1 4 51 76 317 157
+1 4 56 51 317 157
+1 4 81 56 317 157
+1 4 76 81 317 157
+1 4 75 76 157 318
+1 4 80 75 157 318
+1 4 81 80 157 318
+1 4 76 81 157 318
+1 4 50 75 157 319
+1 4 55 50 157 319
+1 4 80 55 157 319
+1 4 75 80 157 319
+1 4 80 81 157 320
+1 4 55 80 157 320
+1 4 56 55 157 320
+1 4 81 56 157 320
+1 4 75 76 321 157
+1 4 50 75 321 157
+1 4 51 50 321 157
+1 4 76 51 321 157
+1 4 51 52 267 158
+1 4 56 51 267 158
+1 4 57 56 267 158
+1 4 52 57 267 158
+1 4 52 77 322 158
+1 4 57 52 322 158
+1 4 82 57 322 158
+1 4 77 82 322 158
+1 4 76 77 158 323
+1 4 81 76 158 323
+1 4 82 81 158 323
+1 4 77 82 158 323
+1 4 51 76 158 317
+1 4 56 51 158 317
+1 4 81 56 158 317
+1 4 76 81 158 317
+1 4 81 82 158 324
+1 4 56 81 158 324
+1 4 57 56 158 324
+1 4 82 57 158 324
+1 4 76 77 325 158
+1 4 51 76 325 158
+1 4 52 51 325 158
+1 4 77 52 325 158
+1 4 52 53 271 159
+1 4 57 52 271 159
+1 4 58 57 271 159
+1 4 53 58 271 159
+1 4 53 78 326 159
+1 4 58 53 326 159
+1 4 83 58 326 159
+1 4 78 83 326 159
+1 4 77 78 159 327
+1 4 82 77 159 327
+1 4 83 82 159 327
+1 4 78 83 159 327
+1 4 52 77 159 322
+1 4 57 52 159 322
+1 4 82 57 159 322
+1 4 77 82 159 322
+1 4 82 83 159 328
+1 4 57 82 159 328
+1 4 58 57 159 328
+1 4 83 58 159 328
+1 4 77 78 329 159
+1 4 52 77 329 159
+1 4 53 52 329 159
+1 4 78 53 329 159
+1 4 53 54 275 160
+1 4 58 53 275 160
+1 4 59 58 275 160
+1 4 54 59 275 160
+1 4 54 79 330 160
+1 4 59 54 330 160
+1 4 84 59 330 160
+1 4 79 84 330 160
+1 4 78 79 160 331
+1 4 83 78 160 331
+1 4 84 83 160 331
+1 4 79 84 160 331
+1 4 53 78 160 326
+1 4 58 53 160 326
+1 4 83 58 160 326
+1 4 78 83 160 326
+1 4 83 84 160 332
+1 4 58 83 160 332
+1 4 59 58 160 332
+1 4 84 59 160 332
+1 4 78 79 333 160
+1 4 53 78 333 160
+1 4 54 53 333 160
+1 4 79 54 333 160
+1 4 55 56 279 161
+1 4 60 55 279 161
+1 4 61 60 279 161
+1 4 56 61 279 161
+1 4 56 81 334 161
+1 4 61 56 334 161
+1 4 86 61 334 161
+1 4 81 86 334 161
+1 4 80 81 161 335
+1 4 85 80 161 335
+1 4 86 85 161 335
+1 4 81 86 161 335
+1 4 55 80 161 336
+1 4 60 55 161 336
+1 4 85 60 161 336
+1 4 80 85 161 336
+1 4 85 86 161 337
+1 4 60 85 161 337
+1 4 61 60 161 337
+1 4 86 61 161 337
+1 4 80 81 320 161
+1 4 55 80 320 161
+1 4 56 55 320 161
+1 4 81 56 320 161
+1 4 56 57 283 162
+1 4 61 56 283 162
+1 4 62 61 283 162
+1 4 57 62 283 162
+1 4 57 82 338 162
+1 4 62 57 338 162
+1 4 87 62 338 162
+1 4 82 87 338 162
+1 4 81 82 162 339
+1 4 86 81 162 339
+1 4 87 86 162 339
+1 4 82 87 162 339
+1 4 56 81 162 334
+1 4 61 56 162 334
+1 4 86 61 162 334
+1 4 81 86 162 334
+1 4 86 87 162 340
+1 4 61 86 162 340
+1 4 62 61 162 340
+1 4 87 62 162 340
+1 4 81 82 324 162
+1 4 56 81 324 162
+1 4 57 56 324 162
+1 4 82 57 324 162
+1 4 57 58 286 163
+1 4 62 57 286 163
+1 4 63 62 286 163
+1 4 58 63 286 163
+1 4 58 83 341 163
+1 4 63 58 341 163
+1 4 88 63 341 163
+1 4 83 88 341 163
+1 4 82 83 163 342
+1 4 87 82 163 342
+1 4 88 87 163 342
+1 4 83 88 163 342
+1 4 57 82 163 338
+1 4 62 57 163 338
+1 4 87 62 163 338
+1 4 82 87 163 338
+1 4 87 88 163 343
+1 4 62 87 163 343
+1 4 63 62 163 343
+1 4 88 63 163 343
+1 4 82 83 328 163
+1 4 57 82 328 163
+1 4 58 57 328 163
+1 4 83 58 328 163
+1 4 58 59 289 164
+1 4 63 58 289 164
+1 4 64 63 289 164
+1 4 59 64 289 164
+1 4 59 84 344 164
+1 4 64 59 344 164
+1 4 89 64 344 164
+1 4 84 89 344 164
+1 4 83 84 164 345
+1 4 88 83 164 345
+1 4 89 88 164 345
+1 4 84 89 164 345
+1 4 58 83 164 341
+1 4 63 58 164 341
+1 4 88 63 164 341
+1 4 83 88 164 341
+1 4 88 89 164 346
+1 4 63 88 164 346
+1 4 64 63 164 346
+1 4 89 64 164 346
+1 4 83 84 332 164
+1 4 58 83 332 164
+1 4 59 58 332 164
+1 4 84 59 332 164
+1 4 60 61 292 165
+1 4 65 60 292 165
+1 4 66 65 292 165
+1 4 61 66 292 165
+1 4 61 86 347 165
+1 4 66 61 347 165
+1 4 91 66 347 165
+1 4 86 91 347 165
+1 4 85 86 165 348
+1 4 90 85 165 348
+1 4 91 90 165 348
+1 4 86 91 165 348
+1 4 60 85 165 349
+1 4 65 60 165 349
+1 4 90 65 165 349
+1 4 85 90 165 349
+1 4 90 91 165 350
+1 4 65 90 165 350
+1 4 66 65 165 350
+1 4 91 66 165 350
+1 4 85 86 337 165
+1 4 60 85 337 165
+1 4 61 60 337 165
+1 4 86 61 337 165
+1 4 61 62 296 166
+1 4 66 61 296 166
+1 4 67 66 296 166
+1 4 62 67 296 166
+1 4 62 87 351 166
+1 4 67 62 351 166
+1 4 92 67 351 166
+1 4 87 92 351 166
+1 4 86 87 166 352
+1 4 91 86 166 352
+1 4 92 91 166 352
+1 4 87 92 166 352
+1 4 61 86 166 347
+1 4 66 61 166 347
+1 4 91 66 166 347
+1 4 86 91 166 347
+1 4 91 92 166 353
+1 4 66 91 166 353
+1 4 67 66 166 353
+1 4 92 67 166 353
+1 4 86 87 340 166
+1 4 61 86 340 166
+1 4 62 61 340 166
+1 4 87 62 340 166
+1 4 62 63 299 167
+1 4 67 62 299 167
+1 4 68 67 299 167
+1 4 63 68 299 167
+1 4 63 88 354 167
+1 4 68 63 354 167
+1 4 93 68 354 167
+1 4 88 93 354 167
+1 4 87 88 167 355
+1 4 92 87 167 355
+1 4 93 92 167 355
+1 4 88 93 167 355
+1 4 62 87 167 351
+1 4 67 62 167 351
+1 4 92 67 167 351
+1 4 87 92 167 351
+1 4 92 93 167 356
+1 4 67 92 167 356
+1 4 68 67 167 356
+1 4 93 68 167 356
+1 4 87 88 343 167
+1 4 62 87 343 167
+1 4 63 62 343 167
+1 4 88 63 343 167
+1 4 63 64 302 168
+1 4 68 63 302 168
+1 4 69 68 302 168
+1 4 64 69 302 168
+1 4 64 89 357 168
+1 4 69 64 357 168
+1 4 94 69 357 168
+1 4 89 94 357 168
+1 4 88 89 168 358
+1 4 93 88 168 358
+1 4 94 93 168 358
+1 4 89 94 168 358
+1 4 63 88 168 354
+1 4 68 63 168 354
+1 4 93 68 168 354
+1 4 88 93 168 354
+1 4 93 94 168 359
+1 4 68 93 168 359
+1 4 69 68 168 359
+1 4 94 69 168 359
+1 4 88 89 346 168
+1 4 63 88 346 168
+1 4 64 63 346 168
+1 4 89 64 346 168
+1 4 65 66 305 169
+1 4 70 65 305 169
+1 4 71 70 305 169
+1 4 66 71 305 169
+1 4 66 91 360 169
+1 4 71 66 360 169
+1 4 96 71 360 169
+1 4 91 96 360 169
+1 4 90 91 169 361
+1 4 95 90 169 361
+1 4 96 95 169 361
+1 4 91 96 169 361
+1 4 65 90 169 362
+1 4 70 65 169 362
+1 4 95 70 169 362
+1 4 90 95 169 362
+1 4 95 96 169 363
+1 4 70 95 169 363
+1 4 71 70 169 363
+1 4 96 71 169 363
+1 4 90 91 350 169
+1 4 65 90 350 169
+1 4 66 65 350 169
+1 4 91 66 350 169
+1 4 66 67 309 170
+1 4 71 66 309 170
+1 4 72 71 309 170
+1 4 67 72 309 170
+1 4 67 92 364 170
+1 4 72 67 364 170
+1 4 97 72 364 170
+1 4 92 97 364 170
+1 4 91 92 170 365
+1 4 96 91 170 365
+1 4 97 96 170 365
+1 4 92 97 170 365
+1 4 66 91 170 360
+1 4 71 66 170 360
+1 4 96 71 170 360
+1 4 91 96 170 360
+1 4 96 97 170 366
+1 4 71 96 170 366
+1 4 72 71 170 366
+1 4 97 72 170 366
+1 4 91 92 353 170
+1 4 66 91 353 170
+1 4 67 66 353 170
+1 4 92 67 353 170
+1 4 67 68 312 171
+1 4 72 67 312 171
+1 4 73 72 312 171
+1 4 68 73 312 171
+1 4 68 93 367 171
+1 4 73 68 367 171
+1 4 98 73 367 171
+1 4 93 98 367 171
+1 4 92 93 171 368
+1 4 97 92 171 368
+1 4 98 97 171 368
+1 4 93 98 171 368
+1 4 67 92 171 364
+1 4 72 67 171 364
+1 4 97 72 171 364
+1 4 92 97 171 364
+1 4 97 98 171 369
+1 4 72 97 171 369
+1 4 73 72 171 369
+1 4 98 73 171 369
+1 4 92 93 356 171
+1 4 67 92 356 171
+1 4 68 67 356 171
+1 4 93 68 356 171
+1 4 68 69 315 172
+1 4 73 68 315 172
+1 4 74 73 315 172
+1 4 69 74 315 172
+1 4 69 94 370 172
+1 4 74 69 370 172
+1 4 99 74 370 172
+1 4 94 99 370 172
+1 4 93 94 172 371
+1 4 98 93 172 371
+1 4 99 98 172 371
+1 4 94 99 172 371
+1 4 68 93 172 367
+1 4 73 68 172 367
+1 4 98 73 172 367
+1 4 93 98 172 367
+1 4 98 99 172 372
+1 4 73 98 172 372
+1 4 74 73 172 372
+1 4 99 74 172 372
+1 4 93 94 359 172
+1 4 68 93 359 172
+1 4 69 68 359 172
+1 4 94 69 359 172
+1 4 75 76 318 173
+1 4 80 75 318 173
+1 4 81 80 318 173
+1 4 76 81 318 173
+1 4 76 101 373 173
+1 4 81 76 373 173
+1 4 106 81 373 173
+1 4 101 106 373 173
+1 4 100 101 173 374
+1 4 105 100 173 374
+1 4 106 105 173 374
+1 4 101 106 173 374
+1 4 75 100 173 375
+1 4 80 75 173 375
+1 4 105 80 173 375
+1 4 100 105 173 375
+1 4 105 106 173 376
+1 4 80 105 173 376
+1 4 81 80 173 376
+1 4 106 81 173 376
+1 4 100 101 377 173
+1 4 75 100 377 173
+1 4 76 75 377 173
+1 4 101 76 377 173
+1 4 76 77 323 174
+1 4 81 76 323 174
+1 4 82 81 323 174
+1 4 77 82 323 174
+1 4 77 102 378 174
+1 4 82 77 378 174
+1 4 107 82 378 174
+1 4 102 107 378 174
+1 4 101 102 174 379
+1 4 106 101 174 379
+1 4 107 106 174 379
+1 4 102 107 174 379
+1 4 76 101 174 373
+1 4 81 76 174 373
+1 4 106 81 174 373
+1 4 101 106 174 373
+1 4 106 107 174 380
+1 4 81 106 174 380
+1 4 82 81 174 380
+1 4 107 82 174 380
+1 4 101 102 381 174
+1 4 76 101 381 174
+1 4 77 76 381 174
+1 4 102 77 381 174
+1 4 77 78 327 175
+1 4 82 77 327 175
+1 4 83 82 327 175
+1 4 78 83 327 175
+1 4 78 103 382 175
+1 4 83 78 382 175
+1 4 108 83 382 175
+1 4 103 108 382 175
+1 4 102 103 175 383
+1 4 107 102 175 383
+1 4 108 107 175 383
+1 4 103 108 175 383
+1 4 77 102 175 378
+1 4 82 77 175 378
+1 4 107 82 175 378
+1 4 102 107 175 378
+1 4 107 108 175 384
+1 4 82 107 175 384
+1 4 83 82 175 384
+1 4 108 83 175 384
+1 4 102 103 385 175
+1 4 77 102 385 175
+1 4 78 77 385 175
+1 4 103 78 385 175
+1 4 78 79 331 176
+1 4 83 78 331 176
+1 4 84 83 331 176
+1 4 79 84 331 176
+1 4 79 104 386 176
+1 4 84 79 386 176
+1 4 109 84 386 176
+1 4 104 109 386 176
+1 4 103 104 176 387
+1 4 108 103 176 387
+1 4 109 108 176 387
+1 4 104 109 176 387
+1 4 78 103 176 382
+1 4 83 78 176 382
+1 4 108 83 176 382
+1 4 103 108 176 382
+1 4 108 109 176 388
+1 4 83 108 176 388
+1 4 84 83 176 388
+1 4 109 84 176 388
+1 4 103 104 389 176
+1 4 78 103 389 176
+1 4 79 78 389 176
+1 4 104 79 389 176
+1 4 80 81 335 177
+1 4 85 80 335 177
+1 4 86 85 335 177
+1 4 81 86 335 177
+1 4 81 106 390 177
+1 4 86 81 390 177
+1 4 111 86 390 177
+1 4 106 111 390 177
+1 4 105 106 177 391
+1 4 110 105 177 391
+1 4 111 110 177 391
+1 4 106 111 177 391
+1 4 80 105 177 392
+1 4 85 80 177 392
+1 4 110 85 177 392
+1 4 105 110 177 392
+1 4 110 111 177 393
+1 4 85 110 177 393
+1 4 86 85 177 393
+1 4 111 86 177 393
+1 4 105 106 376 177
+1 4 80 105 376 177
+1 4 81 80 376 177
+1 4 106 81 376 177
+1 4 81 82 339 178
+1 4 86 81 339 178
+1 4 87 86 339 178
+1 4 82 87 339 178
+1 4 82 107 394 178
+1 4 87 82 394 178
+1 4 112 87 394 178
+1 4 107 112 394 178
+1 4 106 107 178 395
+1 4 111 106 178 395
+1 4 112 111 178 395
+1 4 107 112 178 395
+1 4 81 106 178 390
+1 4 86 81 178 390
+1 4 111 86 178 390
+1 4 106 111 178 390
+1 4 111 112 178 396
+1 4 86 111 178 396
+1 4 87 86 178 396
+1 4 112 87 178 396
+1 4 106 107 380 178
+1 4 81 106 380 178
+1 4 82 81 380 178
+1 4 107 82 380 178
+1 4 82 83 342 179
+1 4 87 82 342 179
+1 4 88 87 342 179
+1 4 83 88 342 179
+1 4 83 108 397 179
+1 4 88 83 397 179
+1 4 113 88 397 179
+1 4 108 113 397 179
+1 4 107 108 179 398
+1 4 112 107 179 398
+1 4 113 112 179 398
+1 4 108 113 179 398
+1 4 82 107 179 394
+1 4 87 82 179 394
+1 4 112 87 179 394
+1 4 107 112 179 394
+1 4 112 113 179 399
+1 4 87 112 179 399
+1 4 88 87 179 399
+1 4 113 88 179 399
+1 4 107 108 384 179
+1 4 82 107 384 179
+1 4 83 82 384 179
+1 4 108 83 384 179
+1 4 83 84 345 180
+1 4 88 83 345 180
+1 4 89 88 345 180
+1 4 84 89 345 180
+1 4 84 109 400 180
+1 4 89 84 400 180
+1 4 114 89 400 180
+1 4 109 114 400 180
+1 4 108 109 180 401
+1 4 113 108 180 401
+1 4 114 113 180 401
+1 4 109 114 180 401
+1 4 83 108 180 397
+1 4 88 83 180 397
+1 4 113 88 180 397
+1 4 108 113 180 397
+1 4 113 114 180 402
+1 4 88 113 180 402
+1 4 89 88 180 402
+1 4 114 89 180 402
+1 4 108 109 388 180
+1 4 83 108 388 180
+1 4 84 83 388 180
+1 4 109 84 388 180
+1 4 85 86 348 181
+1 4 90 85 348 181
+1 4 91 90 348 181
+1 4 86 91 348 181
+1 4 86 111 403 181
+1 4 91 86 403 181
+1 4 116 91 403 181
+1 4 111 116 403 181
+1 4 110 111 181 404
+1 4 115 110 181 404
+1 4 116 115 181 404
+1 4 111 116 181 404
+1 4 85 110 181 405
+1 4 90 85 181 405
+1 4 115 90 181 405
+1 4 110 115 181 405
+1 4 115 116 181 406
+1 4 90 115 181 406
+1 4 91 90 181 406
+1 4 116 91 181 406
+1 4 110 111 393 181
+1 4 85 110 393 181
+1 4 86 85 393 181
+1 4 111 86 393 181
+1 4 86 87 352 182
+1 4 91 86 352 182
+1 4 92 91 352 182
+1 4 87 92 352 182
+1 4 87 112 407 182
+1 4 92 87 407 182
+1 4 117 92 407 182
+1 4 112 117 407 182
+1 4 111 112 182 408
+1 4 116 111 182 408
+1 4 117 116 182 408
+1 4 112 117 182 408
+1 4 86 111 182 403
+1 4 91 86 182 403
+1 4 116 91 182 403
+1 4 111 116 182 403
+1 4 116 117 182 409
+1 4 91 116 182 409
+1 4 92 91 182 409
+1 4 117 92 182 409
+1 4 111 112 396 182
+1 4 86 111 396 182
+1 4 87 86 396 182
+1 4 112 87 396 182
+1 4 87 88 355 183
+1 4 92 87 355 183
+1 4 93 92 355 183
+1 4 88 93 355 183
+1 4 88 113 410 183
+1 4 93 88 410 183
+1 4 118 93 410 183
+1 4 113 118 410 183
+1 4 112 113 183 411
+1 4 117 112 183 411
+1 4 118 117 183 411
+1 4 113 118 183 411
+1 4 87 112 183 407
+1 4 92 87 183 407
+1 4 117 92 183 407
+1 4 112 117 183 407
+1 4 117 118 183 412
+1 4 92 117 183 412
+1 4 93 92 183 412
+1 4 118 93 183 412
+1 4 112 113 399 183
+1 4 87 112 399 183
+1 4 88 87 399 183
+1 4 113 88 399 183
+1 4 88 89 358 184
+1 4 93 88 358 184
+1 4 94 93 358 184
+1 4 89 94 358 184
+1 4 89 114 413 184
+1 4 94 89 413 184
+1 4 119 94 413 184
+1 4 114 119 413 184
+1 4 113 114 184 414
+1 4 118 113 184 414
+1 4 119 118 184 414
+1 4 114 119 184 414
+1 4 88 113 184 410
+1 4 93 88 184 410
+1 4 118 93 184 410
+1 4 113 118 184 410
+1 4 118 119 184 415
+1 4 93 118 184 415
+1 4 94 93 184 415
+1 4 119 94 184 415
+1 4 113 114 402 184
+1 4 88 113 402 184
+1 4 89 88 402 184
+1 4 114 89 402 184
+1 4 90 91 361 185
+1 4 95 90 361 185
+1 4 96 95 361 185
+1 4 91 96 361 185
+1 4 91 116 416 185
+1 4 96 91 416 185
+1 4 121 96 416 185
+1 4 116 121 416 185
+1 4 115 116 185 417
+1 4 120 115 185 417
+1 4 121 120 185 417
+1 4 116 121 185 417
+1 4 90 115 185 418
+1 4 95 90 185 418
+1 4 120 95 185 418
+1 4 115 120 185 418
+1 4 120 121 185 419
+1 4 95 120 185 419
+1 4 96 95 185 419
+1 4 121 96 185 419
+1 4 115 116 406 185
+1 4 90 115 406 185
+1 4 91 90 406 185
+1 4 116 91 406 185
+1 4 91 92 365 186
+1 4 96 91 365 186
+1 4 97 96 365 186
+1 4 92 97 365 186
+1 4 92 117 420 186
+1 4 97 92 420 186
+1 4 122 97 420 186
+1 4 117 122 420 186
+1 4 116 117 186 421
+1 4 121 116 186 421
+1 4 122 121 186 421
+1 4 117 122 186 421
+1 4 91 116 186 416
+1 4 96 91 186 416
+1 4 121 96 186 416
+1 4 116 121 186 416
+1 4 121 122 186 422
+1 4 96 121 186 422
+1 4 97 96 186 422
+1 4 122 97 186 422
+1 4 116 117 409 186
+1 4 91 116 409 186
+1 4 92 91 409 186
+1 4 117 92 409 186
+1 4 92 93 368 187
+1 4 97 92 368 187
+1 4 98 97 368 187
+1 4 93 98 368 187
+1 4 93 118 423 187
+1 4 98 93 423 187
+1 4 123 98 423 187
+1 4 118 123 423 187
+1 4 117 118 187 424
+1 4 122 117 187 424
+1 4 123 122 187 424
+1 4 118 123 187 424
+1 4 92 117 187 420
+1 4 97 92 187 420
+1 4 122 97 187 420
+1 4 117 122 187 420
+1 4 122 123 187 425
+1 4 97 122 187 425
+1 4 98 97 187 425
+1 4 123 98 187 425
+1 4 117 118 412 187
+1 4 92 117 412 187
+1 4 93 92 412 187
+1 4 118 93 412 187
+1 4 93 94 371 188
+1 4 98 93 371 188
+1 4 99 98 371 188
+1 4 94 99 371 188
+1 4 94 119 426 188
+1 4 99 94 426 188
+1 4 124 99 426 188
+1 4 119 124 426 188
+1 4 118 119 188 427
+1 4 123 118 188 427
+1 4 124 123 188 427
+1 4 119 124 188 427
+1 4 93 118 188 423
+1 4 98 93 188 423
+1 4 123 98 188 423
+1 4 118 123 188 423
+1 4 123 124 188 428
+1 4 98 123 188 428
+1 4 99 98 188 428
+1 4 124 99 188 428
+1 4 118 119 415 188
+1 4 93 118 415 188
+1 4 94 93 415 188
+1 4 119 94 415 188
+
+boundary
+384
+3 2 0 1 189
+3 2 5 0 189
+3 2 6 5 189
+3 2 1 6 189
+1 2 0 25 192
+1 2 5 0 192
+1 2 30 5 192
+1 2 25 30 192
+2 2 25 26 194
+2 2 0 25 194
+2 2 1 0 194
+2 2 26 1 194
+3 2 1 2 195
+3 2 6 1 195
+3 2 7 6 195
+3 2 2 7 195
+2 2 26 27 199
+2 2 1 26 199
+2 2 2 1 199
+2 2 27 2 199
+3 2 2 3 200
+3 2 7 2 200
+3 2 8 7 200
+3 2 3 8 200
+2 2 27 28 204
+2 2 2 27 204
+2 2 3 2 204
+2 2 28 3 204
+3 2 3 4 205
+3 2 8 3 205
+3 2 9 8 205
+3 2 4 9 205
+1 2 4 29 206
+1 2 9 4 206
+1 2 34 9 206
+1 2 29 34 206
+2 2 28 29 209
+2 2 3 28 209
+2 2 4 3 209
+2 2 29 4 209
+3 2 5 6 210
+3 2 10 5 210
+3 2 11 10 210
+3 2 6 11 210
+1 2 5 30 213
+1 2 10 5 213
+1 2 35 10 213
+1 2 30 35 213
+3 2 6 7 215
+3 2 11 6 215
+3 2 12 11 215
+3 2 7 12 215
+3 2 7 8 219
+3 2 12 7 219
+3 2 13 12 219
+3 2 8 13 219
+3 2 8 9 223
+3 2 13 8 223
+3 2 14 13 223
+3 2 9 14 223
+1 2 9 34 224
+1 2 14 9 224
+1 2 39 14 224
+1 2 34 39 224
+3 2 10 11 227
+3 2 15 10 227
+3 2 16 15 227
+3 2 11 16 227
+1 2 10 35 230
+1 2 15 10 230
+1 2 40 15 230
+1 2 35 40 230
+3 2 11 12 232
+3 2 16 11 232
+3 2 17 16 232
+3 2 12 17 232
+3 2 12 13 236
+3 2 17 12 236
+3 2 18 17 236
+3 2 13 18 236
+3 2 13 14 240
+3 2 18 13 240
+3 2 19 18 240
+3 2 14 19 240
+1 2 14 39 241
+1 2 19 14 241
+1 2 44 19 241
+1 2 39 44 241
+3 2 15 16 244
+3 2 20 15 244
+3 2 21 20 244
+3 2 16 21 244
+1 2 15 40 247
+1 2 20 15 247
+1 2 45 20 247
+1 2 40 45 247
+2 2 45 46 248
+2 2 20 45 248
+2 2 21 20 248
+2 2 46 21 248
+3 2 16 17 249
+3 2 21 16 249
+3 2 22 21 249
+3 2 17 22 249
+2 2 46 47 252
+2 2 21 46 252
+2 2 22 21 252
+2 2 47 22 252
+3 2 17 18 253
+3 2 22 17 253
+3 2 23 22 253
+3 2 18 23 253
+2 2 47 48 256
+2 2 22 47 256
+2 2 23 22 256
+2 2 48 23 256
+3 2 18 19 257
+3 2 23 18 257
+3 2 24 23 257
+3 2 19 24 257
+1 2 19 44 258
+1 2 24 19 258
+1 2 49 24 258
+1 2 44 49 258
+2 2 48 49 260
+2 2 23 48 260
+2 2 24 23 260
+2 2 49 24 260
+1 2 25 50 263
+1 2 30 25 263
+1 2 55 30 263
+1 2 50 55 263
+2 2 50 51 265
+2 2 25 50 265
+2 2 26 25 265
+2 2 51 26 265
+2 2 51 52 269
+2 2 26 51 269
+2 2 27 26 269
+2 2 52 27 269
+2 2 52 53 273
+2 2 27 52 273
+2 2 28 27 273
+2 2 53 28 273
+1 2 29 54 274
+1 2 34 29 274
+1 2 59 34 274
+1 2 54 59 274
+2 2 53 54 277
+2 2 28 53 277
+2 2 29 28 277
+2 2 54 29 277
+1 2 30 55 280
+1 2 35 30 280
+1 2 60 35 280
+1 2 55 60 280
+1 2 34 59 288
+1 2 39 34 288
+1 2 64 39 288
+1 2 59 64 288
+1 2 35 60 293
+1 2 40 35 293
+1 2 65 40 293
+1 2 60 65 293
+1 2 39 64 301
+1 2 44 39 301
+1 2 69 44 301
+1 2 64 69 301
+1 2 40 65 306
+1 2 45 40 306
+1 2 70 45 306
+1 2 65 70 306
+2 2 70 71 307
+2 2 45 70 307
+2 2 46 45 307
+2 2 71 46 307
+2 2 71 72 310
+2 2 46 71 310
+2 2 47 46 310
+2 2 72 47 310
+2 2 72 73 313
+2 2 47 72 313
+2 2 48 47 313
+2 2 73 48 313
+1 2 44 69 314
+1 2 49 44 314
+1 2 74 49 314
+1 2 69 74 314
+2 2 73 74 316
+2 2 48 73 316
+2 2 49 48 316
+2 2 74 49 316
+1 2 50 75 319
+1 2 55 50 319
+1 2 80 55 319
+1 2 75 80 319
+2 2 75 76 321
+2 2 50 75 321
+2 2 51 50 321
+2 2 76 51 321
+2 2 76 77 325
+2 2 51 76 325
+2 2 52 51 325
+2 2 77 52 325
+2 2 77 78 329
+2 2 52 77 329
+2 2 53 52 329
+2 2 78 53 329
+1 2 54 79 330
+1 2 59 54 330
+1 2 84 59 330
+1 2 79 84 330
+2 2 78 79 333
+2 2 53 78 333
+2 2 54 53 333
+2 2 79 54 333
+1 2 55 80 336
+1 2 60 55 336
+1 2 85 60 336
+1 2 80 85 336
+1 2 59 84 344
+1 2 64 59 344
+1 2 89 64 344
+1 2 84 89 344
+1 2 60 85 349
+1 2 65 60 349
+1 2 90 65 349
+1 2 85 90 349
+1 2 64 89 357
+1 2 69 64 357
+1 2 94 69 357
+1 2 89 94 357
+1 2 65 90 362
+1 2 70 65 362
+1 2 95 70 362
+1 2 90 95 362
+2 2 95 96 363
+2 2 70 95 363
+2 2 71 70 363
+2 2 96 71 363
+2 2 96 97 366
+2 2 71 96 366
+2 2 72 71 366
+2 2 97 72 366
+2 2 97 98 369
+2 2 72 97 369
+2 2 73 72 369
+2 2 98 73 369
+1 2 69 94 370
+1 2 74 69 370
+1 2 99 74 370
+1 2 94 99 370
+2 2 98 99 372
+2 2 73 98 372
+2 2 74 73 372
+2 2 99 74 372
+3 2 100 101 374
+3 2 105 100 374
+3 2 106 105 374
+3 2 101 106 374
+1 2 75 100 375
+1 2 80 75 375
+1 2 105 80 375
+1 2 100 105 375
+2 2 100 101 377
+2 2 75 100 377
+2 2 76 75 377
+2 2 101 76 377
+3 2 101 102 379
+3 2 106 101 379
+3 2 107 106 379
+3 2 102 107 379
+2 2 101 102 381
+2 2 76 101 381
+2 2 77 76 381
+2 2 102 77 381
+3 2 102 103 383
+3 2 107 102 383
+3 2 108 107 383
+3 2 103 108 383
+2 2 102 103 385
+2 2 77 102 385
+2 2 78 77 385
+2 2 103 78 385
+1 2 79 104 386
+1 2 84 79 386
+1 2 109 84 386
+1 2 104 109 386
+3 2 103 104 387
+3 2 108 103 387
+3 2 109 108 387
+3 2 104 109 387
+2 2 103 104 389
+2 2 78 103 389
+2 2 79 78 389
+2 2 104 79 389
+3 2 105 106 391
+3 2 110 105 391
+3 2 111 110 391
+3 2 106 111 391
+1 2 80 105 392
+1 2 85 80 392
+1 2 110 85 392
+1 2 105 110 392
+3 2 106 107 395
+3 2 111 106 395
+3 2 112 111 395
+3 2 107 112 395
+3 2 107 108 398
+3 2 112 107 398
+3 2 113 112 398
+3 2 108 113 398
+1 2 84 109 400
+1 2 89 84 400
+1 2 114 89 400
+1 2 109 114 400
+3 2 108 109 401
+3 2 113 108 401
+3 2 114 113 401
+3 2 109 114 401
+3 2 110 111 404
+3 2 115 110 404
+3 2 116 115 404
+3 2 111 116 404
+1 2 85 110 405
+1 2 90 85 405
+1 2 115 90 405
+1 2 110 115 405
+3 2 111 112 408
+3 2 116 111 408
+3 2 117 116 408
+3 2 112 117 408
+3 2 112 113 411
+3 2 117 112 411
+3 2 118 117 411
+3 2 113 118 411
+1 2 89 114 413
+1 2 94 89 413
+1 2 119 94 413
+1 2 114 119 413
+3 2 113 114 414
+3 2 118 113 414
+3 2 119 118 414
+3 2 114 119 414
+3 2 115 116 417
+3 2 120 115 417
+3 2 121 120 417
+3 2 116 121 417
+1 2 90 115 418
+1 2 95 90 418
+1 2 120 95 418
+1 2 115 120 418
+2 2 120 121 419
+2 2 95 120 419
+2 2 96 95 419
+2 2 121 96 419
+3 2 116 117 421
+3 2 121 116 421
+3 2 122 121 421
+3 2 117 122 421
+2 2 121 122 422
+2 2 96 121 422
+2 2 97 96 422
+2 2 122 97 422
+3 2 117 118 424
+3 2 122 117 424
+3 2 123 122 424
+3 2 118 123 424
+2 2 122 123 425
+2 2 97 122 425
+2 2 98 97 425
+2 2 123 98 425
+1 2 94 119 426
+1 2 99 94 426
+1 2 124 99 426
+1 2 119 124 426
+3 2 118 119 427
+3 2 123 118 427
+3 2 124 123 427
+3 2 119 124 427
+2 2 123 124 428
+2 2 98 123 428
+2 2 99 98 428
+2 2 124 99 428
+
+vertices
+429
+3
+0.000000 0.000000 0.000000
+0.250000 0.000000 0.000000
+0.500000 0.000000 0.000000
+0.750000 0.000000 0.000000
+1.000000 0.000000 0.000000
+0.000000 0.250000 0.000000
+0.250000 0.250000 0.000000
+0.500000 0.250000 0.000000
+0.750000 0.250000 0.000000
+1.000000 0.250000 0.000000
+0.000000 0.500000 0.000000
+0.250000 0.500000 0.000000
+0.500000 0.500000 0.000000
+0.750000 0.500000 0.000000
+1.000000 0.500000 0.000000
+0.000000 0.750000 0.000000
+0.250000 0.750000 0.000000
+0.500000 0.750000 0.000000
+0.750000 0.750000 0.000000
+1.000000 0.750000 0.000000
+0.000000 1.000000 0.000000
+0.250000 1.000000 0.000000
+0.500000 1.000000 0.000000
+0.750000 1.000000 0.000000
+1.000000 1.000000 0.000000
+0.000000 0.000000 0.250000
+0.250000 0.000000 0.250000
+0.500000 0.000000 0.250000
+0.750000 0.000000 0.250000
+1.000000 0.000000 0.250000
+0.000000 0.250000 0.250000
+0.250000 0.250000 0.250000
+0.500000 0.250000 0.250000
+0.750000 0.250000 0.250000
+1.000000 0.250000 0.250000
+0.000000 0.500000 0.250000
+0.250000 0.500000 0.250000
+0.500000 0.500000 0.250000
+0.750000 0.500000 0.250000
+1.000000 0.500000 0.250000
+0.000000 0.750000 0.250000
+0.250000 0.750000 0.250000
+0.500000 0.750000 0.250000
+0.750000 0.750000 0.250000
+1.000000 0.750000 0.250000
+0.000000 1.000000 0.250000
+0.250000 1.000000 0.250000
+0.500000 1.000000 0.250000
+0.750000 1.000000 0.250000
+1.000000 1.000000 0.250000
+0.000000 0.000000 0.500000
+0.250000 0.000000 0.500000
+0.500000 0.000000 0.500000
+0.750000 0.000000 0.500000
+1.000000 0.000000 0.500000
+0.000000 0.250000 0.500000
+0.250000 0.250000 0.500000
+0.500000 0.250000 0.500000
+0.750000 0.250000 0.500000
+1.000000 0.250000 0.500000
+0.000000 0.500000 0.500000
+0.250000 0.500000 0.500000
+0.500000 0.500000 0.500000
+0.750000 0.500000 0.500000
+1.000000 0.500000 0.500000
+0.000000 0.750000 0.500000
+0.250000 0.750000 0.500000
+0.500000 0.750000 0.500000
+0.750000 0.750000 0.500000
+1.000000 0.750000 0.500000
+0.000000 1.000000 0.500000
+0.250000 1.000000 0.500000
+0.500000 1.000000 0.500000
+0.750000 1.000000 0.500000
+1.000000 1.000000 0.500000
+0.000000 0.000000 0.750000
+0.250000 0.000000 0.750000
+0.500000 0.000000 0.750000
+0.750000 0.000000 0.750000
+1.000000 0.000000 0.750000
+0.000000 0.250000 0.750000
+0.250000 0.250000 0.750000
+0.500000 0.250000 0.750000
+0.750000 0.250000 0.750000
+1.000000 0.250000 0.750000
+0.000000 0.500000 0.750000
+0.250000 0.500000 0.750000
+0.500000 0.500000 0.750000
+0.750000 0.500000 0.750000
+1.000000 0.500000 0.750000
+0.000000 0.750000 0.750000
+0.250000 0.750000 0.750000
+0.500000 0.750000 0.750000
+0.750000 0.750000 0.750000
+1.000000 0.750000 0.750000
+0.000000 1.000000 0.750000
+0.250000 1.000000 0.750000
+0.500000 1.000000 0.750000
+0.750000 1.000000 0.750000
+1.000000 1.000000 0.750000
+0.000000 0.000000 1.000000
+0.250000 0.000000 1.000000
+0.500000 0.000000 1.000000
+0.750000 0.000000 1.000000
+1.000000 0.000000 1.000000
+0.000000 0.250000 1.000000
+0.250000 0.250000 1.000000
+0.500000 0.250000 1.000000
+0.750000 0.250000 1.000000
+1.000000 0.250000 1.000000
+0.000000 0.500000 1.000000
+0.250000 0.500000 1.000000
+0.500000 0.500000 1.000000
+0.750000 0.500000 1.000000
+1.000000 0.500000 1.000000
+0.000000 0.750000 1.000000
+0.250000 0.750000 1.000000
+0.500000 0.750000 1.000000
+0.750000 0.750000 1.000000
+1.000000 0.750000 1.000000
+0.000000 1.000000 1.000000
+0.250000 1.000000 1.000000
+0.500000 1.000000 1.000000
+0.750000 1.000000 1.000000
+1.000000 1.000000 1.000000
+0.125000 0.125000 0.125000
+0.375000 0.125000 0.125000
+0.625000 0.125000 0.125000
+0.875000 0.125000 0.125000
+0.125000 0.375000 0.125000
+0.375000 0.375000 0.125000
+0.625000 0.375000 0.125000
+0.875000 0.375000 0.125000
+0.125000 0.625000 0.125000
+0.375000 0.625000 0.125000
+0.625000 0.625000 0.125000
+0.875000 0.625000 0.125000
+0.125000 0.875000 0.125000
+0.375000 0.875000 0.125000
+0.625000 0.875000 0.125000
+0.875000 0.875000 0.125000
+0.125000 0.125000 0.375000
+0.375000 0.125000 0.375000
+0.625000 0.125000 0.375000
+0.875000 0.125000 0.375000
+0.125000 0.375000 0.375000
+0.375000 0.375000 0.375000
+0.625000 0.375000 0.375000
+0.875000 0.375000 0.375000
+0.125000 0.625000 0.375000
+0.375000 0.625000 0.375000
+0.625000 0.625000 0.375000
+0.875000 0.625000 0.375000
+0.125000 0.875000 0.375000
+0.375000 0.875000 0.375000
+0.625000 0.875000 0.375000
+0.875000 0.875000 0.375000
+0.125000 0.125000 0.625000
+0.375000 0.125000 0.625000
+0.625000 0.125000 0.625000
+0.875000 0.125000 0.625000
+0.125000 0.375000 0.625000
+0.375000 0.375000 0.625000
+0.625000 0.375000 0.625000
+0.875000 0.375000 0.625000
+0.125000 0.625000 0.625000
+0.375000 0.625000 0.625000
+0.625000 0.625000 0.625000
+0.875000 0.625000 0.625000
+0.125000 0.875000 0.625000
+0.375000 0.875000 0.625000
+0.625000 0.875000 0.625000
+0.875000 0.875000 0.625000
+0.125000 0.125000 0.875000
+0.375000 0.125000 0.875000
+0.625000 0.125000 0.875000
+0.875000 0.125000 0.875000
+0.125000 0.375000 0.875000
+0.375000 0.375000 0.875000
+0.625000 0.375000 0.875000
+0.875000 0.375000 0.875000
+0.125000 0.625000 0.875000
+0.375000 0.625000 0.875000
+0.625000 0.625000 0.875000
+0.875000 0.625000 0.875000
+0.125000 0.875000 0.875000
+0.375000 0.875000 0.875000
+0.625000 0.875000 0.875000
+0.875000 0.875000 0.875000
+0.125000 0.125000 0.000000
+0.250000 0.125000 0.125000
+0.125000 0.125000 0.250000
+0.000000 0.125000 0.125000
+0.125000 0.250000 0.125000
+0.125000 0.000000 0.125000
+0.375000 0.125000 0.000000
+0.500000 0.125000 0.125000
+0.375000 0.125000 0.250000
+0.375000 0.250000 0.125000
+0.375000 0.000000 0.125000
+0.625000 0.125000 0.000000
+0.750000 0.125000 0.125000
+0.625000 0.125000 0.250000
+0.625000 0.250000 0.125000
+0.625000 0.000000 0.125000
+0.875000 0.125000 0.000000
+1.000000 0.125000 0.125000
+0.875000 0.125000 0.250000
+0.875000 0.250000 0.125000
+0.875000 0.000000 0.125000
+0.125000 0.375000 0.000000
+0.250000 0.375000 0.125000
+0.125000 0.375000 0.250000
+0.000000 0.375000 0.125000
+0.125000 0.500000 0.125000
+0.375000 0.375000 0.000000
+0.500000 0.375000 0.125000
+0.375000 0.375000 0.250000
+0.375000 0.500000 0.125000
+0.625000 0.375000 0.000000
+0.750000 0.375000 0.125000
+0.625000 0.375000 0.250000
+0.625000 0.500000 0.125000
+0.875000 0.375000 0.000000
+1.000000 0.375000 0.125000
+0.875000 0.375000 0.250000
+0.875000 0.500000 0.125000
+0.125000 0.625000 0.000000
+0.250000 0.625000 0.125000
+0.125000 0.625000 0.250000
+0.000000 0.625000 0.125000
+0.125000 0.750000 0.125000
+0.375000 0.625000 0.000000
+0.500000 0.625000 0.125000
+0.375000 0.625000 0.250000
+0.375000 0.750000 0.125000
+0.625000 0.625000 0.000000
+0.750000 0.625000 0.125000
+0.625000 0.625000 0.250000
+0.625000 0.750000 0.125000
+0.875000 0.625000 0.000000
+1.000000 0.625000 0.125000
+0.875000 0.625000 0.250000
+0.875000 0.750000 0.125000
+0.125000 0.875000 0.000000
+0.250000 0.875000 0.125000
+0.125000 0.875000 0.250000
+0.000000 0.875000 0.125000
+0.125000 1.000000 0.125000
+0.375000 0.875000 0.000000
+0.500000 0.875000 0.125000
+0.375000 0.875000 0.250000
+0.375000 1.000000 0.125000
+0.625000 0.875000 0.000000
+0.750000 0.875000 0.125000
+0.625000 0.875000 0.250000
+0.625000 1.000000 0.125000
+0.875000 0.875000 0.000000
+1.000000 0.875000 0.125000
+0.875000 0.875000 0.250000
+0.875000 1.000000 0.125000
+0.250000 0.125000 0.375000
+0.125000 0.125000 0.500000
+0.000000 0.125000 0.375000
+0.125000 0.250000 0.375000
+0.125000 0.000000 0.375000
+0.500000 0.125000 0.375000
+0.375000 0.125000 0.500000
+0.375000 0.250000 0.375000
+0.375000 0.000000 0.375000
+0.750000 0.125000 0.375000
+0.625000 0.125000 0.500000
+0.625000 0.250000 0.375000
+0.625000 0.000000 0.375000
+1.000000 0.125000 0.375000
+0.875000 0.125000 0.500000
+0.875000 0.250000 0.375000
+0.875000 0.000000 0.375000
+0.250000 0.375000 0.375000
+0.125000 0.375000 0.500000
+0.000000 0.375000 0.375000
+0.125000 0.500000 0.375000
+0.500000 0.375000 0.375000
+0.375000 0.375000 0.500000
+0.375000 0.500000 0.375000
+0.750000 0.375000 0.375000
+0.625000 0.375000 0.500000
+0.625000 0.500000 0.375000
+1.000000 0.375000 0.375000
+0.875000 0.375000 0.500000
+0.875000 0.500000 0.375000
+0.250000 0.625000 0.375000
+0.125000 0.625000 0.500000
+0.000000 0.625000 0.375000
+0.125000 0.750000 0.375000
+0.500000 0.625000 0.375000
+0.375000 0.625000 0.500000
+0.375000 0.750000 0.375000
+0.750000 0.625000 0.375000
+0.625000 0.625000 0.500000
+0.625000 0.750000 0.375000
+1.000000 0.625000 0.375000
+0.875000 0.625000 0.500000
+0.875000 0.750000 0.375000
+0.250000 0.875000 0.375000
+0.125000 0.875000 0.500000
+0.000000 0.875000 0.375000
+0.125000 1.000000 0.375000
+0.500000 0.875000 0.375000
+0.375000 0.875000 0.500000
+0.375000 1.000000 0.375000
+0.750000 0.875000 0.375000
+0.625000 0.875000 0.500000
+0.625000 1.000000 0.375000
+1.000000 0.875000 0.375000
+0.875000 0.875000 0.500000
+0.875000 1.000000 0.375000
+0.250000 0.125000 0.625000
+0.125000 0.125000 0.750000
+0.000000 0.125000 0.625000
+0.125000 0.250000 0.625000
+0.125000 0.000000 0.625000
+0.500000 0.125000 0.625000
+0.375000 0.125000 0.750000
+0.375000 0.250000 0.625000
+0.375000 0.000000 0.625000
+0.750000 0.125000 0.625000
+0.625000 0.125000 0.750000
+0.625000 0.250000 0.625000
+0.625000 0.000000 0.625000
+1.000000 0.125000 0.625000
+0.875000 0.125000 0.750000
+0.875000 0.250000 0.625000
+0.875000 0.000000 0.625000
+0.250000 0.375000 0.625000
+0.125000 0.375000 0.750000
+0.000000 0.375000 0.625000
+0.125000 0.500000 0.625000
+0.500000 0.375000 0.625000
+0.375000 0.375000 0.750000
+0.375000 0.500000 0.625000
+0.750000 0.375000 0.625000
+0.625000 0.375000 0.750000
+0.625000 0.500000 0.625000
+1.000000 0.375000 0.625000
+0.875000 0.375000 0.750000
+0.875000 0.500000 0.625000
+0.250000 0.625000 0.625000
+0.125000 0.625000 0.750000
+0.000000 0.625000 0.625000
+0.125000 0.750000 0.625000
+0.500000 0.625000 0.625000
+0.375000 0.625000 0.750000
+0.375000 0.750000 0.625000
+0.750000 0.625000 0.625000
+0.625000 0.625000 0.750000
+0.625000 0.750000 0.625000
+1.000000 0.625000 0.625000
+0.875000 0.625000 0.750000
+0.875000 0.750000 0.625000
+0.250000 0.875000 0.625000
+0.125000 0.875000 0.750000
+0.000000 0.875000 0.625000
+0.125000 1.000000 0.625000
+0.500000 0.875000 0.625000
+0.375000 0.875000 0.750000
+0.375000 1.000000 0.625000
+0.750000 0.875000 0.625000
+0.625000 0.875000 0.750000
+0.625000 1.000000 0.625000
+1.000000 0.875000 0.625000
+0.875000 0.875000 0.750000
+0.875000 1.000000 0.625000
+0.250000 0.125000 0.875000
+0.125000 0.125000 1.000000
+0.000000 0.125000 0.875000
+0.125000 0.250000 0.875000
+0.125000 0.000000 0.875000
+0.500000 0.125000 0.875000
+0.375000 0.125000 1.000000
+0.375000 0.250000 0.875000
+0.375000 0.000000 0.875000
+0.750000 0.125000 0.875000
+0.625000 0.125000 1.000000
+0.625000 0.250000 0.875000
+0.625000 0.000000 0.875000
+1.000000 0.125000 0.875000
+0.875000 0.125000 1.000000
+0.875000 0.250000 0.875000
+0.875000 0.000000 0.875000
+0.250000 0.375000 0.875000
+0.125000 0.375000 1.000000
+0.000000 0.375000 0.875000
+0.125000 0.500000 0.875000
+0.500000 0.375000 0.875000
+0.375000 0.375000 1.000000
+0.375000 0.500000 0.875000
+0.750000 0.375000 0.875000
+0.625000 0.375000 1.000000
+0.625000 0.500000 0.875000
+1.000000 0.375000 0.875000
+0.875000 0.375000 1.000000
+0.875000 0.500000 0.875000
+0.250000 0.625000 0.875000
+0.125000 0.625000 1.000000
+0.000000 0.625000 0.875000
+0.125000 0.750000 0.875000
+0.500000 0.625000 0.875000
+0.375000 0.625000 1.000000
+0.375000 0.750000 0.875000
+0.750000 0.625000 0.875000
+0.625000 0.625000 1.000000
+0.625000 0.750000 0.875000
+1.000000 0.625000 0.875000
+0.875000 0.625000 1.000000
+0.875000 0.750000 0.875000
+0.250000 0.875000 0.875000
+0.125000 0.875000 1.000000
+0.000000 0.875000 0.875000
+0.125000 1.000000 0.875000
+0.500000 0.875000 0.875000
+0.375000 0.875000 1.000000
+0.375000 1.000000 0.875000
+0.750000 0.875000 0.875000
+0.625000 0.875000 1.000000
+0.625000 1.000000 0.875000
+1.000000 0.875000 0.875000
+0.875000 0.875000 1.000000
+0.875000 1.000000 0.875000
diff --git a/miniapps/meshing/fit-node-position.cpp b/miniapps/meshing/fit-node-position.cpp
new file mode 100644
index 000000000..e43cf6d74
--- /dev/null
+++ b/miniapps/meshing/fit-node-position.cpp
@@ -0,0 +1,227 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+//
+//    ------------------------------------------------------------------
+//      Fitting of Selected Mesh Nodes to Specified Physical Positions
+//    ------------------------------------------------------------------
+//
+// This example fits a selected set of the mesh nodes to given physical
+// positions while maintaining a valid mesh with good quality.
+//
+// Sample runs:
+//   mpirun -np 4 fit-node-position
+//   mpirun -np 4 fit-node-position -m square01-tri.mesh
+//   mpirun -np 4 fit-node-position -m ./cube.mesh
+//   mpirun -np 4 fit-node-position -m ./cube-tet.mesh -rs 0
+
+#include "mfem.hpp"
+#include "../common/mfem-common.hpp"
+
+using namespace mfem;
+using namespace std;
+
+char vishost[] = "localhost";
+int  visport   = 19916;
+int  wsize     = 350;
+
+int main (int argc, char *argv[])
+{
+   // Initialize MPI.
+   Mpi::Init();
+   int myid = Mpi::WorldRank();
+
+   const char *mesh_file = "square01.mesh";
+   int rs_levels     = 2;
+   int mesh_poly_deg = 2;
+   int quad_order    = 5;
+   bool glvis        = true;
+
+   // Parse command-line options.
+   OptionsParser args(argc, argv);
+   args.AddOption(&mesh_file, "-m", "--mesh",
+                  "Mesh file to use.");
+   args.AddOption(&rs_levels, "-rs", "--refine-serial",
+                  "Number of times to refine the mesh uniformly in serial.");
+   args.AddOption(&mesh_poly_deg, "-o", "--order",
+                  "Polynomial degree of mesh finite element space.");
+   args.AddOption(&quad_order, "-qo", "--quad_order",
+                  "Order of the quadrature rule.");
+   args.AddOption(&glvis, "-vis", "--visualization", "-no-vis",
+                  "--no-visualization",
+                  "Enable or disable GLVis visualization.");
+   args.Parse();
+   if (!args.Good())
+   {
+      if (myid == 0) { args.PrintUsage(cout); }
+      return 1;
+   }
+   if (myid == 0) { args.PrintOptions(cout); }
+
+   // Read and refine the mesh.
+   Mesh *mesh = new Mesh(mesh_file, 1, 1, false);
+   for (int lev = 0; lev < rs_levels; lev++) { mesh->UniformRefinement(); }
+   ParMesh pmesh(MPI_COMM_WORLD, *mesh);
+   delete mesh;
+   const int dim = pmesh.Dimension();
+
+   // Setup mesh curvature and GridFunction that stores the coordinates.
+   FiniteElementCollection *fec_mesh;
+   if (mesh_poly_deg <= 0)
+   {
+      fec_mesh = new QuadraticPosFECollection;
+      mesh_poly_deg = 2;
+   }
+   else { fec_mesh = new H1_FECollection(mesh_poly_deg, dim); }
+   ParFiniteElementSpace pfes_mesh(&pmesh, fec_mesh, dim);
+   pmesh.SetNodalFESpace(&pfes_mesh);
+   ParGridFunction coord(&pfes_mesh);
+   pmesh.SetNodalGridFunction(&coord);
+   ParGridFunction x0(coord);
+
+   // Pick which nodes to fit and select the target positions.
+   // (attribute 2 would have a prescribed deformation in y-direction, same x).
+   Array<bool> fit_marker(pfes_mesh.GetNDofs());
+   ParGridFunction fit_marker_vis_gf(&pfes_mesh);
+   ParGridFunction coord_target(&pfes_mesh);
+   Array<int> vdofs;
+   fit_marker = false;
+   coord_target = coord;
+   fit_marker_vis_gf = 0.0;
+   for (int e = 0; e < pmesh.GetNBE(); e++)
+   {
+      const int nd = pfes_mesh.GetBE(e)->GetDof();
+      const int attr = pmesh.GetBdrElement(e)->GetAttribute();
+      if (attr != 2) { continue; }
+
+      pfes_mesh.GetBdrElementVDofs(e, vdofs);
+      for (int j = 0; j < nd; j++)
+      {
+         int j_x = vdofs[j], j_y = vdofs[nd+j];
+         const double x = coord(j_x),
+                      z = (dim == 2) ? 0.0 : coord(vdofs[2*nd + j]);
+         fit_marker[pfes_mesh.VDofToDof(j_x)] = true;
+         fit_marker_vis_gf(j_x) = 1.0;
+         if (coord(j_y) < 0.5)
+         {
+            coord_target(j_y) = 0.1 * sin(4 * M_PI * x) * cos(M_PI * z);
+         }
+         else
+         {
+            if (coord(j_x) < 0.5)
+            {
+               coord_target(j_y) = 1.0 + 0.1 * sin(2 * M_PI * x);
+            }
+            else
+            {
+               coord_target(j_y) = 1.0 + 0.1 * sin(2 * M_PI * (x + 0.5));
+            }
+
+         }
+      }
+   }
+
+   // Visualize the selected nodes and their target positions.
+   if (glvis)
+   {
+      socketstream vis1;
+      coord = coord_target;
+      common::VisualizeField(vis1, "localhost", 19916, fit_marker_vis_gf,
+                             "Target positions (DOFS with value 1)",
+                             0, 0, 400, 400, (dim == 2) ? "Rjm" : "");
+      coord = x0;
+   }
+
+   // Allow slipping along the remaining boundaries.
+   // (attributes 1 and 3 would slip, while 4 is completely fixed).
+   int n = 0;
+   for (int i = 0; i < pmesh.GetNBE(); i++)
+   {
+      const int nd = pfes_mesh.GetBE(i)->GetDof();
+      const int attr = pmesh.GetBdrElement(i)->GetAttribute();
+      MFEM_VERIFY(!(dim == 2 && attr == 3),
+                  "Boundary attribute 3 must be used only for 3D meshes. "
+                  "Adjust the attributes (1/2/3/4 for fixed x/y/z/all "
+                  "components, rest for free nodes), or use -fix-bnd.");
+      if (attr == 1 || attr == 3) { n += nd; }
+      if (attr == 4) { n += nd * dim; }
+   }
+   Array<int> ess_vdofs(n);
+   n = 0;
+   for (int i = 0; i < pmesh.GetNBE(); i++)
+   {
+      const int nd = pfes_mesh.GetBE(i)->GetDof();
+      const int attr = pmesh.GetBdrElement(i)->GetAttribute();
+      pfes_mesh.GetBdrElementVDofs(i, vdofs);
+      if (attr == 1) // Fix x components.
+      {
+         for (int j = 0; j < nd; j++)
+         { ess_vdofs[n++] = vdofs[j]; }
+      }
+      else if (attr == 3) // Fix z components.
+      {
+         for (int j = 0; j < nd; j++)
+         { ess_vdofs[n++] = vdofs[j+2*nd]; }
+      }
+      else if (attr == 4) // Fix all components.
+      {
+         for (int j = 0; j < vdofs.Size(); j++)
+         { ess_vdofs[n++] = vdofs[j]; }
+      }
+   }
+
+   // TMOP setup.
+   TMOP_QualityMetric *metric;
+   if (dim == 2) { metric = new TMOP_Metric_002; }
+   else          { metric = new TMOP_Metric_302; }
+   TargetConstructor target(TargetConstructor::IDEAL_SHAPE_UNIT_SIZE,
+                            pfes_mesh.GetComm());
+   ConstantCoefficient fit_weight(100.0);
+   auto integ = new TMOP_Integrator(metric, &target, nullptr);
+   integ->EnableSurfaceFitting(coord_target, fit_marker, fit_weight);
+
+   // Linear solver.
+   MINRESSolver minres(pfes_mesh.GetComm());
+   minres.SetMaxIter(100);
+   minres.SetRelTol(1e-12);
+   minres.SetAbsTol(0.0);
+
+   // Nonlinear solver.
+   ParNonlinearForm a(&pfes_mesh);
+   a.SetEssentialVDofs(ess_vdofs);
+   a.AddDomainIntegrator(integ);
+   const IntegrationRule &ir =
+      IntRules.Get(pfes_mesh.GetFE(0)->GetGeomType(), quad_order);
+   TMOPNewtonSolver solver(pfes_mesh.GetComm(), ir, 0);
+   solver.SetOperator(a);
+   solver.SetPreconditioner(minres);
+   solver.SetPrintLevel(1);
+   solver.SetMaxIter(200);
+   solver.SetRelTol(1e-10);
+   solver.SetAbsTol(0.0);
+   solver.EnableAdaptiveSurfaceFitting();
+   solver.SetTerminationWithMaxSurfaceFittingError(1e-3);
+
+   // Solve.
+   Vector b(0);
+   coord.SetTrueVector();
+   solver.Mult(b, coord.GetTrueVector());
+   coord.SetFromTrueVector();
+
+   if (glvis)
+   {
+      socketstream vis2;
+      common::VisualizeMesh(vis2, "localhost", 19916, pmesh, "Final mesh",
+                            400, 0, 400, 400);
+   }
+
+   delete metric;
+   return 0;
+}
diff --git a/miniapps/meshing/makefile b/miniapps/meshing/makefile
index 656f80d0e..e34a5637e 100644
--- a/miniapps/meshing/makefile
+++ b/miniapps/meshing/makefile
@@ -28,7 +28,7 @@ MFEM_LIB_FILE = mfem_is_not_built
 SEQ_MINIAPPS = mobius-strip klein-bottle toroid trimmer twist mesh-explorer\
 	shaper extruder mesh-optimizer minimal-surface polar-nc reflector\
 	mesh-quality
-PAR_MINIAPPS = pmesh-optimizer pminimal-surface pmesh-fitting
+PAR_MINIAPPS = pmesh-optimizer pminimal-surface pmesh-fitting fit-node-position
 ifeq ($(MFEM_USE_MPI),NO)
    MINIAPPS = $(SEQ_MINIAPPS)
 else
@@ -62,11 +62,11 @@ lib-common:
 # Rules to copy the *.mesh files - needed for running the sample runs when
 # building out-of-source:
 ifneq ($(SRC),)
-MESH_FILES = amr-quad-q2.mesh blade.mesh cube.mesh icf.mesh jagged.mesh\
- square01.mesh stretched2D.mesh
+MESH_FILES = amr-quad-q2.mesh blade.mesh cube.mesh cube-tet.mesh icf.mesh\
+jagged.mesh square01.mesh square01-tri.mesh stretched2D.mesh 
 $(MESH_FILES): %: $(SRC)%
 	ln -sf $(<) .
-mesh-optimizer pmesh-optimizer pmesh-fitting: | $(MESH_FILES)
+mesh-optimizer pmesh-optimizer pmesh-fitting fit-node-position: | $(MESH_FILES)
 .PHONY: copy-data
 copy-data: | $(MESH_FILES)
 endif
@@ -92,6 +92,8 @@ mesh-quality-test-seq: mesh-quality
 	@$(call mfem-test,$<,, Mesh quality miniapp)
 pmesh-fitting-test-par: pmesh-fitting
 	@$(call mfem-test,$<, $(RUN_MPI), Parallel mesh fitting miniapp)
+fit-node-position-test-par: fit-node-position
+	@$(call mfem-test,$<, $(RUN_MPI), Parallel position fitting miniapp)
 minimal-surface-test-seq: minimal-surface
 	@$(call mfem-test,$<,, Meshing miniapp)
 pminimal-surface-test-par: pminimal-surface
@@ -117,7 +119,7 @@ clean-build:
 	rm -f *.o *~ mobius-strip klein-bottle toroid twist
 	rm -f mesh-explorer shaper extruder trimmer reflector
 	rm -f mesh-optimizer pmesh-optimizer pmesh-fitting polar-nc
-	rm -f minimal-surface pminimal-surface mesh-quality
+	rm -f minimal-surface pminimal-surface mesh-quality fit-node-position
 	rm -rf *.dSYM *.TVD.*breakpoints
 
 clean-exec:
diff --git a/miniapps/meshing/pmesh-fitting.cpp b/miniapps/meshing/pmesh-fitting.cpp
index 376db6e57..baae15466 100644
--- a/miniapps/meshing/pmesh-fitting.cpp
+++ b/miniapps/meshing/pmesh-fitting.cpp
@@ -598,8 +598,7 @@ int main (int argc, char *argv[])
       if (!surf_bg_mesh)
       {
          tmop_integ->EnableSurfaceFitting(surf_fit_gf0, surf_fit_marker,
-                                          surf_fit_coeff,
-                                          *adapt_surface);
+                                          surf_fit_coeff, *adapt_surface);
       }
       else
       {
@@ -841,7 +840,7 @@ int main (int argc, char *argv[])
                                 "Surface DOFs", 600, 400, 300, 300);
       }
       double err_avg, err_max;
-      tmop_integ->GetSurfaceFittingErrors(err_avg, err_max);
+      tmop_integ->GetSurfaceFittingErrors(x, err_avg, err_max);
       if (myid == 0)
       {
          std::cout << "Avg fitting error: " << err_avg << std::endl
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index 673653596..1077d998a 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -385,17 +385,17 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    }
    int dim = mesh.Dimension();
 
-   FiniteElementCollection *fec;
+   std::unique_ptr<FiniteElementCollection> fec;
    if (prob)
    {
       auto basis = prob==3 ? BasisType::Positive : BasisType::GaussLobatto;
-      fec = new L2_FECollection(order, dim, basis);
+      fec.reset(new L2_FECollection(order, dim, basis));
    }
    else
    {
-      fec = new H1_FECollection(order, dim);
+      fec.reset(new H1_FECollection(order, dim));
    }
-   FiniteElementSpace fespace(&mesh, fec);
+   FiniteElementSpace fespace(&mesh, fec.get());
 
    L2_FECollection vel_fec(order, dim, BasisType::GaussLobatto);
    FiniteElementSpace vel_fespace(&mesh, &vel_fec, dim);
@@ -405,21 +405,21 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    BilinearForm k_pa(&fespace);
    BilinearForm k_fa(&fespace);
 
-   VectorCoefficient *vel_coeff;
-   Coefficient *rho;
+   std::unique_ptr<VectorCoefficient> vel_coeff;
+   std::unique_ptr<Coefficient> rho;
 
    // prob: 0: CG, 1: DG continuous coeff, 2: DG discontinuous coeff
    if (prob >= 2)
    {
       vel_gf.Randomize(1);
-      vel_coeff = new VectorGridFunctionCoefficient(&vel_gf);
+      vel_coeff.reset(new VectorGridFunctionCoefficient(&vel_gf));
       rho_gf.Randomize(1);
-      rho = new GridFunctionCoefficient(&rho_gf);
+      rho.reset(new GridFunctionCoefficient(&rho_gf));
    }
    else
    {
-      vel_coeff = new VectorFunctionCoefficient(dim, velocity_function);
-      rho = new ConstantCoefficient(1.0);
+      vel_coeff.reset(new VectorFunctionCoefficient(dim, velocity_function));
+      rho.reset(new ConstantCoefficient(1.0));
    }
 
 
@@ -451,10 +451,6 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    y_pa -= y_fa;
 
    REQUIRE(y_pa.Norml2() < 1.e-12);
-
-   delete vel_coeff;
-   delete rho;
-   delete fec;
 }
 
 // Basic unit tests for convection
@@ -468,7 +464,7 @@ TEST_CASE("PA Convection", "[PartialAssembly], [CUDA]")
    auto prob = GENERATE(0, 1, 2, 3);
    auto order = GENERATE(2);
    // refinement > 0 => Non-conforming mesh
-   auto refinement = GENERATE(0,1);
+   auto refinement = GENERATE(0, 1);
 
    SECTION("2D")
    {
diff --git a/tests/unit/mesh/test_ncmesh.cpp b/tests/unit/mesh/test_ncmesh.cpp
index dba0b4507..1c512fcd4 100644
--- a/tests/unit/mesh/test_ncmesh.cpp
+++ b/tests/unit/mesh/test_ncmesh.cpp
@@ -368,7 +368,6 @@ void CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
       x = 0.0;
 
       double pnorm = x.ComputeL2Error(rhs_coef);
-
       b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
       b.Assemble();
 
@@ -397,7 +396,6 @@ void CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
    CHECK(std::abs(serror - perror) < test_tol);
 };
 
-
 TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
 {
    constexpr int refining_rank = 0;
@@ -764,6 +762,147 @@ TEST_CASE("PNQ2PureTetHexPri",  "[Parallel], [NCMesh]")
    }
 } // test case
 
+/**
+ * @brief Test GetVectorValue on face neighbor elements for nonconformal meshes
+ *
+ * @param smesh The serial mesh to start from
+ * @param nc_level Depth of refinement on processor boundaries
+ * @param skip Refine every "skip" processor boundary element
+ * @param use_ND Whether to use Nedelec elements (which are sensitive to orientation)
+ */
+void TestVectorValueInVolume(Mesh &smesh, int nc_level, int skip, bool use_ND)
+{
+   auto vector_exact_soln = [](const Vector& x, Vector& v)
+   {
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      v = (d -= x);
+   };
+
+   smesh.Finalize();
+   smesh.EnsureNCMesh(true); // uncomment this to trigger the failure
+
+   auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+   // Apply refinement on face neighbors to achieve a given nc level mismatch.
+   for (int i = 0; i < nc_level; ++i)
+   {
+      // To refine the face neighbors, need to know where they are.
+      pmesh.ExchangeFaceNbrData();
+      Array<int> elem_to_refine;
+      // Refine only on odd ranks.
+      if ((Mpi::WorldRank() + 1) % 2 == 0)
+      {
+         // Refine a subset of all shared faces. Using a subset helps to
+         // mix in conformal faces with nonconformal faces.
+         for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+         {
+            if (n % skip != 0) { continue; }
+            const int local_face = pmesh.GetSharedFace(n);
+            const auto &face_info = pmesh.GetFaceInformation(local_face);
+            REQUIRE(face_info.IsShared());
+            REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+            elem_to_refine.Append(face_info.element[0].index);
+         }
+      }
+      pmesh.GeneralRefinement(elem_to_refine);
+   }
+
+   // Do not rebalance again! The test is also checking for nc refinements
+   // along the processor boundary.
+
+   // Create a grid function of the mesh coordinates
+   pmesh.ExchangeFaceNbrData();
+   pmesh.EnsureNodes();
+   REQUIRE(pmesh.OwnsNodes());
+   GridFunction * const coords = pmesh.GetNodes();
+   dynamic_cast<ParGridFunction *>(pmesh.GetNodes())->ExchangeFaceNbrData();
+
+   // Project the linear function onto the mesh. Quadratic ND tetrahedral
+   // elements are the first to require face orientations.
+   const int order = 2, dim = 3;
+   std::unique_ptr<FiniteElementCollection> fec;
+   if (use_ND)
+   {
+      fec = std::unique_ptr<ND_FECollection>(new ND_FECollection(order, dim));
+   }
+   else
+   {
+      fec = std::unique_ptr<RT_FECollection>(new RT_FECollection(order, dim));
+   }
+   ParFiniteElementSpace pnd_fes(&pmesh, fec.get());
+
+   ParGridFunction psol(&pnd_fes);
+
+   VectorFunctionCoefficient func(3, vector_exact_soln);
+   psol.ProjectCoefficient(func);
+   psol.ExchangeFaceNbrData();
+
+   mfem::Vector value(3), exact(3), position(3);
+   const IntegrationRule &ir = mfem::IntRules.Get(Geometry::Type::TETRAHEDRON,
+                                                  order + 1);
+
+   // Check that non-ghost elements match up on the serial and parallel spaces.
+   for (int n = 0; n < pmesh.GetNE(); ++n)
+   {
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         coords->GetVectorValue(n, ip, position);
+         psol.GetVectorValue(n, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+
+   // Loop over face neighbor elements and check the vector values match in the
+   // face neighbor elements.
+   for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+   {
+      const int local_face = pmesh.GetSharedFace(n);
+      const auto &face_info = pmesh.GetFaceInformation(local_face);
+      REQUIRE(face_info.IsShared());
+      REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+
+      auto &T = *pmesh.GetFaceNbrElementTransformation(face_info.element[1].index);
+
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         T.SetIntPoint(&ip);
+         coords->GetVectorValue(T, ip, position);
+         psol.GetVectorValue(T, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+}
+
+TEST_CASE("GetVectorValueInFaceNeighborElement", "[Parallel], [NCMesh]")
+{
+   // The aim of this test is to verify the correct behaviour of the
+   // GetVectorValue method when called on face neighbor elements in a non
+   // conforming mesh.
+   auto smesh = Mesh("../../data/beam-tet.mesh");
+
+   for (int nc_level : {0,1,2,3})
+   {
+      for (int skip : {1,2})
+      {
+         for (bool use_ND : {false, true})
+         {
+            TestVectorValueInVolume(smesh, nc_level, skip, use_ND);
+         }
+      }
+   }
+}
+
 #endif // MFEM_USE_MPI
 
 } // namespace mfem
