diff --git a/fem/fe.cpp b/fem/fe.cpp
index 44390f76c..e1aef168b 100644
--- a/fem/fe.cpp
+++ b/fem/fe.cpp
@@ -9,17 +9,11 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-// Finite Element classes
-
 #include "fe.hpp"
 
-#include <cmath>
-
 namespace mfem
 {
 
-using namespace std;
-
 // Global object definitions
 
 // Static member data declared in fe_base.hpp
@@ -27,14 +21,30 @@ using namespace std;
 Array2D<int> Poly_1D::binom;
 Poly_1D poly1d;
 
+// Object declared in mesh/point.hpp.
+// Defined here to ensure it is constructed before 'Geometries'.
+PointFiniteElement PointFE;
+
+// Object declared in mesh/segment.hpp.
+// Defined here to ensure it is constructed before 'Geometries'.
+Linear1DFiniteElement SegmentFE;
+
 // Object declared in mesh/triangle.hpp.
 // Defined here to ensure it is constructed before 'Geometries'.
 Linear2DFiniteElement TriangleFE;
 
+// Object declared in mesh/quadrilateral.hpp.
+// Defined here to ensure it is constructed before 'Geometries'.
+BiLinear2DFiniteElement QuadrilateralFE;
+
 // Object declared in mesh/tetrahedron.hpp.
 // Defined here to ensure it is constructed before 'Geometries'.
 Linear3DFiniteElement TetrahedronFE;
 
+// Object declared in mesh/hexahedron.hpp.
+// Defined here to ensure it is constructed before 'Geometries'.
+TriLinear3DFiniteElement HexahedronFE;
+
 // Object declared in mesh/wedge.hpp.
 // Defined here to ensure it is constructed before 'Geometries'.
 LinearWedgeFiniteElement WedgeFE;
@@ -44,8 +54,6 @@ LinearWedgeFiniteElement WedgeFE;
 LinearPyramidFiniteElement PyramidFE;
 
 // Object declared in geom.hpp.
-// Construct 'Geometries' after 'TriangleFE', 'TetrahedronFE', 'WedgeFE', and
-// PyramidFE.
 Geometry Geometries;
 
 }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 99ec4eaac..b651facdb 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -43,7 +43,7 @@ ParFiniteElementSpace::ParFiniteElementSpace(
 }
 
 ParFiniteElementSpace::ParFiniteElementSpace(
-   ParMesh *pm, const FiniteElementSpace *global_fes, const int *partitioning,
+   ParMesh *pm, const FiniteElementSpace *global_fes,
    const FiniteElementCollection *f)
    : FiniteElementSpace(pm, MakeLocalNURBSext(global_fes->GetNURBSext(),
                                               pm->NURBSext),
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 1fbc7ccd1..ee82b0891 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -247,14 +247,11 @@ public:
    /** @brief Construct the *local* ParFiniteElementSpace corresponding to the
        global FE space, @a global_fes. */
    /** The parameter @a pm is the *local* ParMesh obtained by decomposing the
-       global Mesh used by @a global_fes. The array @a partitioning represents
-       the parallel decomposition - it maps global element ids to MPI ranks.
-       If the FiniteElementCollection, @a f, is NULL (default), the FE
-       collection used by @a global_fes will be reused. If @a f is not NULL, it
-       must be the same as, or a copy of, the FE collection used by
-       @a global_fes. */
+       global Mesh used by @a global_fes. If the FiniteElementCollection, @a f,
+       is NULL (default), the FE collection used by @a global_fes will be
+       reused. If @a f is not NULL, it must be the same as, or a copy of, the FE
+       collection used by @a global_fes. */
    ParFiniteElementSpace(ParMesh *pm, const FiniteElementSpace *global_fes,
-                         const int *partitioning,
                          const FiniteElementCollection *f = NULL);
 
    ParFiniteElementSpace(ParMesh *pm, const FiniteElementCollection *f,
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index d49187457..0a58530c1 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -41,7 +41,7 @@ ParGridFunction::ParGridFunction(ParMesh *pmesh, const GridFunction *gf,
    // duplicate the FiniteElementCollection from 'gf'
    fec = FiniteElementCollection::New(glob_fes->FEColl()->Name());
    // create a local ParFiniteElementSpace from the global one:
-   fes = pfes = new ParFiniteElementSpace(pmesh, glob_fes, partitioning, fec);
+   fes = pfes = new ParFiniteElementSpace(pmesh, glob_fes, fec);
    SetSize(pfes->GetVSize());
 
    if (partitioning)
diff --git a/mesh/element.cpp b/mesh/element.cpp
index c21b8f9bd..1e5ee7706 100644
--- a/mesh/element.cpp
+++ b/mesh/element.cpp
@@ -9,7 +9,7 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "mesh_headers.hpp"
+#include "element.hpp"
 
 namespace mfem
 {
diff --git a/mesh/element.hpp b/mesh/element.hpp
index c37205eb1..49a4cad61 100644
--- a/mesh/element.hpp
+++ b/mesh/element.hpp
@@ -13,10 +13,9 @@
 #define MFEM_ELEMENT
 
 #include "../config/config.hpp"
+#include "../fem/geom.hpp"
 #include "../general/array.hpp"
 #include "../general/table.hpp"
-#include "../linalg/densemat.hpp"
-#include "../fem/geom.hpp"
 #include "../general/hash.hpp"
 
 namespace mfem
@@ -28,7 +27,6 @@ class Mesh;
 class Element
 {
 protected:
-
    /// Element's attribute (specifying material property, etc).
    int attribute;
 
@@ -36,7 +34,6 @@ protected:
    Geometry::Type base_geom;
 
 public:
-
    /// Constants for the classes derived from Element.
    enum Type { POINT, SEGMENT, TRIANGLE, QUADRILATERAL,
                TETRAHEDRON, HEXAHEDRON, WEDGE, PYRAMID
@@ -75,26 +72,20 @@ public:
 
    virtual const int *GetEdgeVertices(int) const = 0;
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const = 0;
-
    virtual int GetNFaces() const = 0;
 
    virtual int GetNFaceVertices(int fi) const = 0;
 
    virtual const int *GetFaceVertices(int fi) const = 0;
 
-   /// Mark the longest edge by assuming/changing the order of the vertices.
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length) {}
-
    /// Return 1 if the element needs refinement in order to get conforming mesh.
    virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const { return 0; }
 
    /// Set current coarse-fine transformation number.
-   virtual void ResetTransform(int tr) {}
+   virtual void ResetTransform(int tr) { }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr) {}
+   virtual void PushTransform(int tr) { }
 
    /// Return current coarse-fine transformation.
    virtual unsigned GetTransform() const { return 0; }
diff --git a/mesh/hexahedron.cpp b/mesh/hexahedron.cpp
index beeab3b6a..96287d6c2 100644
--- a/mesh/hexahedron.cpp
+++ b/mesh/hexahedron.cpp
@@ -9,8 +9,7 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
-#include "mesh_headers.hpp"
+#include "hexahedron.hpp"
 
 namespace mfem
 {
@@ -27,7 +26,8 @@ Hexahedron::Hexahedron(const int *ind, int attr)
 
 Hexahedron::Hexahedron(int ind1, int ind2, int ind3, int ind4,
                        int ind5, int ind6, int ind7, int ind8,
-                       int attr) : Element(Geometry::CUBE)
+                       int attr)
+   : Element(Geometry::CUBE)
 {
    attribute  = attr;
    indices[0] = ind1;
@@ -49,6 +49,4 @@ void Hexahedron::GetVertices(Array<int> &v) const
    }
 }
 
-TriLinear3DFiniteElement HexahedronFE;
-
 }
diff --git a/mesh/hexahedron.hpp b/mesh/hexahedron.hpp
index a8186c0c8..6b62a14d6 100644
--- a/mesh/hexahedron.hpp
+++ b/mesh/hexahedron.hpp
@@ -51,10 +51,6 @@ public:
    virtual const int *GetEdgeVertices(int ei) const
    { return geom_t::Edges[ei]; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
-   { nFaceVertices = 4; return 6; }
-
    virtual int GetNFaces() const { return 6; }
 
    virtual int GetNFaceVertices(int) const { return 4; }
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 36a3063cb..0ecfa5749 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -1962,7 +1962,7 @@ void Mesh::FinalizeTriMesh(int generate_edges, int refine, bool fix_orientation)
 
    if (refine)
    {
-      MarkTriMeshForRefinement();
+      MarkForRefinement();
    }
 
    if (generate_edges)
@@ -2417,82 +2417,103 @@ void Mesh::ReorderElements(const Array<int> &ordering, bool reorder_vertices)
 }
 
 
+void Mesh::GetEdgeLengths(const DSTable &v_to_v, Array<double> &lengths) const
+{
+   auto GetLength = [this](int i, int j)
+   {
+      double length = 0.;
+      if (Nodes == NULL)
+      {
+         const double *vi = vertices[i]();
+         const double *vj = vertices[j]();
+         for (int k = 0; k < spaceDim; k++)
+         {
+            length += (vi[k]-vj[k])*(vi[k]-vj[k]);
+         }
+      }
+      else
+      {
+         Array<int> ivdofs, jvdofs;
+         Nodes->FESpace()->GetVertexVDofs(i, ivdofs);
+         Nodes->FESpace()->GetVertexVDofs(j, jvdofs);
+         for (int k = 0; k < ivdofs.Size(); k++)
+         {
+            length += ((*Nodes)(ivdofs[k])-(*Nodes)(jvdofs[k]))*
+                      ((*Nodes)(ivdofs[k])-(*Nodes)(jvdofs[k]));
+         }
+      }
+      return length;
+   };
+
+   lengths.SetSize(NumOfEdges);
+   for (int i = 0; i < NumOfVertices; i++)
+   {
+      for (DSTable::RowIterator it(v_to_v, i); !it; ++it)
+      {
+         lengths[it.Index()] = GetLength(i, it.Column());
+      }
+   }
+};
+
 void Mesh::MarkForRefinement()
 {
    if (meshgen & 1)
    {
+      DSTable v_to_v(NumOfVertices);
+      GetVertexToVertexTable(v_to_v);
+      NumOfEdges = v_to_v.NumberOfEntries();
       if (Dim == 2)
       {
-         MarkTriMeshForRefinement();
+         MarkTriMeshForRefinement(v_to_v);
       }
       else if (Dim == 3)
       {
-         DSTable v_to_v(NumOfVertices);
-         GetVertexToVertexTable(v_to_v);
          MarkTetMeshForRefinement(v_to_v);
       }
    }
 }
 
-void Mesh::MarkTriMeshForRefinement()
+void Mesh::MarkTriMeshForRefinement(const DSTable &v_to_v)
 {
    // Mark the longest triangle edge by rotating the indices so that
    // vertex 0 - vertex 1 is the longest edge in the triangle.
-   DenseMatrix pmat;
-   for (int i = 0; i < NumOfElements; i++)
-   {
-      if (elements[i]->GetType() == Element::TRIANGLE)
-      {
-         GetPointMatrix(i, pmat);
-         static_cast<Triangle*>(elements[i])->MarkEdge(pmat);
-      }
-   }
-}
+   Array<double> lengths;
+   GetEdgeLengths(v_to_v, lengths);
 
-void Mesh::GetEdgeOrdering(DSTable &v_to_v, Array<int> &order)
-{
-   NumOfEdges = v_to_v.NumberOfEntries();
-   order.SetSize(NumOfEdges);
-   Array<Pair<double, int> > length_idx(NumOfEdges);
+   Array<int> idx(NumOfEdges);
+   for (int i = 0; i < NumOfEdges; i++) { idx[i] = i; }
 
-   for (int i = 0; i < NumOfVertices; i++)
+   for (int i = 0; i < NumOfElements; i++)
    {
-      for (DSTable::RowIterator it(v_to_v, i); !it; ++it)
+      if (elements[i]->GetType() == Element::TRIANGLE)
       {
-         int j = it.Index();
-         length_idx[j].one = GetLength(i, it.Column());
-         length_idx[j].two = j;
+         dynamic_cast<Triangle &>(*elements[i]).MarkEdge(v_to_v, lengths, idx);
       }
    }
-
-   // Sort by increasing edge-length.
-   length_idx.Sort();
-
-   for (int i = 0; i < NumOfEdges; i++)
-   {
-      order[length_idx[i].two] = i;
-   }
 }
 
-void Mesh::MarkTetMeshForRefinement(DSTable &v_to_v)
+void Mesh::MarkTetMeshForRefinement(const DSTable &v_to_v)
 {
    // Mark the longest tetrahedral edge by rotating the indices so that
    // vertex 0 - vertex 1 is the longest edge in the element.
-   Array<int> order;
-   GetEdgeOrdering(v_to_v, order);
+   Array<double> lengths;
+   GetEdgeLengths(v_to_v, lengths);
+
+   Array<int> idx(NumOfEdges);
+   for (int i = 0; i < NumOfEdges; i++) { idx[i] = i; }
 
    for (int i = 0; i < NumOfElements; i++)
    {
       if (elements[i]->GetType() == Element::TETRAHEDRON)
       {
-         elements[i]->MarkEdge(v_to_v, order);
+         dynamic_cast<Tetrahedron &>(*elements[i]).MarkEdge(v_to_v, lengths, idx);
       }
    }
    for (int i = 0; i < NumOfBdrElements; i++)
    {
       if (boundary[i]->GetType() == Element::TRIANGLE)
       {
-         boundary[i]->MarkEdge(v_to_v, order);
+         dynamic_cast<Triangle &>(*boundary[i]).MarkEdge(v_to_v, lengths, idx);
       }
    }
 }
@@ -2842,9 +2863,7 @@ void Mesh::FinalizeTetMesh(int generate_edges, int refine, bool fix_orientation)
 
    if (refine)
    {
-      DSTable v_to_v(NumOfVertices);
-      GetVertexToVertexTable(v_to_v);
-      MarkTetMeshForRefinement(v_to_v);
+      MarkForRefinement();
    }
 
    GetElementToFaceTable();
@@ -3077,6 +3096,9 @@ void Mesh::Finalize(bool refine, bool fix_orientation)
       MarkForRefinement();   // may change topology!
    }
 
+   // check and fix boundary element orientation
+   CheckBdrElementOrientation();
+
    if (may_change_topology)
    {
       if (curved)
@@ -3094,9 +3116,6 @@ void Mesh::Finalize(bool refine, bool fix_orientation)
       // NodeReorderMatrix and do Nodes->Update() instead of DoNodeReorder?
    }
 
-   // check and fix boundary element orientation
-   CheckBdrElementOrientation();
-
 #ifdef MFEM_DEBUG
    // For non-orientable surfaces/manifolds, the check below will fail, so we
    // only perform it when Dim == spaceDim.
@@ -3540,8 +3559,6 @@ void Mesh::Make2D(int nx, int ny, Element::Type type,
          boundary[2*nx+j] = new Segment((j+1)*m, j*m, 4);
          boundary[2*nx+ny+j] = new Segment(j*m+nx, (j+1)*m+nx, 2);
       }
-
-      // MarkTriMeshForRefinement(); // done in Finalize(...)
    }
    else
    {
@@ -5710,37 +5727,21 @@ static const char *fixed_or_not[] = { "fixed", "NOT FIXED" };
 
 int Mesh::CheckElementOrientation(bool fix_it)
 {
-   int i, j, k, wo = 0, fo = 0;
-   double *v[4];
+   int wo = 0, fo = 0;
 
    if (Dim == 2 && spaceDim == 2)
    {
       DenseMatrix J(2, 2);
 
-      for (i = 0; i < NumOfElements; i++)
+      for (int i = 0; i < NumOfElements; i++)
       {
-         int *vi = elements[i]->GetVertices();
-         if (Nodes == NULL)
-         {
-            for (j = 0; j < 3; j++)
-            {
-               v[j] = vertices[vi[j]]();
-            }
-            for (j = 0; j < 2; j++)
-               for (k = 0; k < 2; k++)
-               {
-                  J(j, k) = v[j+1][k] - v[0][k];
-               }
-         }
-         else
-         {
-            // only check the Jacobian at the center of the element
-            GetElementJacobian(i, J);
-         }
+         // only check the Jacobian at the center of the element
+         GetElementJacobian(i, J);
          if (J.Det() < 0.0)
          {
             if (fix_it)
             {
+               int *vi = elements[i]->GetVertices();
                switch (GetElementType(i))
                {
                   case Element::TRIANGLE:
@@ -5765,29 +5766,14 @@ int Mesh::CheckElementOrientation(bool fix_it)
    {
       DenseMatrix J(3, 3);
 
-      for (i = 0; i < NumOfElements; i++)
+      for (int i = 0; i < NumOfElements; i++)
       {
          int *vi = elements[i]->GetVertices();
          switch (GetElementType(i))
          {
             case Element::TETRAHEDRON:
-               if (Nodes == NULL)
-               {
-                  for (j = 0; j < 4; j++)
-                  {
-                     v[j] = vertices[vi[j]]();
-                  }
-                  for (j = 0; j < 3; j++)
-                     for (k = 0; k < 3; k++)
-                     {
-                        J(j, k) = v[j+1][k] - v[0][k];
-                     }
-               }
-               else
-               {
-                  // only check the Jacobian at the center of the element
-                  GetElementJacobian(i, J);
-               }
+               // only check the Jacobian at the center of the element
+               GetElementJacobian(i, J);
                if (J.Det() < 0.0)
                {
                   wo++;
@@ -6678,24 +6664,12 @@ void Mesh::GetBdrPointMatrix(int i,DenseMatrix &pointmat) const
 
    pointmat.SetSize(spaceDim, nv);
    for (k = 0; k < spaceDim; k++)
+   {
       for (j = 0; j < nv; j++)
       {
          pointmat(k, j) = vertices[v[j]](k);
       }
-}
-
-double Mesh::GetLength(int i, int j) const
-{
-   const double *vi = vertices[i]();
-   const double *vj = vertices[j]();
-   double length = 0.;
-
-   for (int k = 0; k < spaceDim; k++)
-   {
-      length += (vi[k]-vj[k])*(vi[k]-vj[k]);
    }
-
-   return sqrt(length);
 }
 
 // static method
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index b373fb72d..c88bf2e55 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -31,8 +31,6 @@
 namespace mfem
 {
 
-// Data type mesh
-
 class GeometricFactors;
 class FaceGeometricFactors;
 class KnotVector;
@@ -49,15 +47,15 @@ class ParMesh;
 class ParNCMesh;
 #endif
 
+/// Mesh data type
 class Mesh
 {
+   friend class NCMesh;
+   friend class NURBSExtension;
 #ifdef MFEM_USE_MPI
    friend class ParMesh;
    friend class ParNCMesh;
 #endif
-   friend class NCMesh;
-   friend class NURBSExtension;
-
 #ifdef MFEM_USE_ADIOS2
    friend class adios2stream;
 #endif
@@ -331,13 +329,10 @@ protected:
    /** Also, initializes #mesh_geoms. */
    void SetMeshGen();
 
-   /// Return the length of the segment from node i to node j.
-   double GetLength(int i, int j) const;
-
+   void GetEdgeLengths(const DSTable &v_to_v, Array<double> &lengths) const;
    void MarkForRefinement();
-   void MarkTriMeshForRefinement();
-   void GetEdgeOrdering(DSTable &v_to_v, Array<int> &order);
-   virtual void MarkTetMeshForRefinement(DSTable &v_to_v);
+   void MarkTriMeshForRefinement(const DSTable &v_to_v);
+   virtual void MarkTetMeshForRefinement(const DSTable &v_to_v);
 
    // Methods used to prepare and apply permutation of the mesh nodes assuming
    // that the mesh elements may be rotated (e.g. to mark triangle or tet edges
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index cffe6828e..9ec7fe07d 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -20,6 +20,7 @@
 #include "../general/text.hpp"
 #include "../general/globals.hpp"
 
+#include <cstdint>
 #include <iostream>
 #include <fstream>
 
@@ -921,22 +922,21 @@ void ParMesh::FinalizeParTopo()
    }
 }
 
-ParMesh::ParMesh(MPI_Comm comm, istream &input, bool refine)
+ParMesh::ParMesh(MPI_Comm comm, istream &input, int generate_edges,
+                 int refine, bool fix_orientation)
    : face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
+   , pncmesh(NULL)
 {
    MyComm = comm;
    MPI_Comm_size(MyComm, &NRanks);
    MPI_Comm_rank(MyComm, &MyRank);
 
-   have_face_nbr_data = false;
-   pncmesh = NULL;
-
-   const int gen_edges = 1;
+   Load(input, generate_edges, refine, fix_orientation);
 
-   Load(input, gen_edges, refine, true);
+   have_face_nbr_data = false;
 }
 
 void ParMesh::Load(istream &input, int generate_edges, int refine,
@@ -1730,99 +1730,59 @@ void ParMesh::GetSharedTriCommunicator(int ordering,
    stria_comm.Finalize();
 }
 
-void ParMesh::MarkTetMeshForRefinement(DSTable &v_to_v)
+void ParMesh::MarkTetMeshForRefinement(const DSTable &v_to_v)
 {
-   Array<int> order;
-   GetEdgeOrdering(v_to_v, order); // local edge ordering
+   Array<double> lengths;
+   GetEdgeLengths(v_to_v, lengths);
 
-   // create a GroupCommunicator on the shared edges
+   // create a GroupCommunicator over shared edges
    GroupCommunicator sedge_comm(gtopo);
-   GetSharedEdgeCommunicator(sedge_comm);
+   GetSharedEdgeCommunicator(0, sedge_comm);
 
-   Array<int> sedge_ord(shared_edges.Size());
-   Array<Pair<int,int> > sedge_ord_map(shared_edges.Size());
-   for (int k = 0; k < shared_edges.Size(); k++)
+   // communicate the local index of each shared edge from the group master to
+   // other ranks in the group
+   Array<int> sedge_master_rank(shared_edges.Size());
+   Array<int> sedge_master_index(shared_edges.Size());
+   for (int i = 0; i < group_sedge.Size(); i++)
    {
-      // sedge_ledge may be undefined -- use shared_edges and v_to_v instead
-      const int sedge = group_sedge.GetJ()[k];
+      int rank = gtopo.GetGroupMasterRank(i+1);
+      for (int j = 0; j < group_sedge.RowSize(i); j++)
+      {
+         sedge_master_rank[group_sedge.GetRow(i)[j]] = rank;
+      }
+   }
+   for (int i = 0; i < shared_edges.Size(); i++)
+   {
+      // sedge_ledge may be undefined so use shared_edges and v_to_v instead
+      const int sedge = group_sedge.GetJ()[i];
       const int *v = shared_edges[sedge]->GetVertices();
-      sedge_ord[k] = order[v_to_v(v[0], v[1])];
+      sedge_master_index[i] = v_to_v(v[0], v[1]);
    }
+   sedge_comm.Bcast(sedge_master_index);
 
-   sedge_comm.Bcast<int>(sedge_ord, 1);
-
-   for (int k = 0, gr = 1; gr < GetNGroups(); gr++)
+   // the pairs (master rank, master local index) define a globally consistent
+   // edge ordering
+   Array<std::int64_t> glob_edge_order(NumOfEdges);
+   for (int i = 0; i < NumOfEdges; i++)
    {
-      const int n = group_sedge.RowSize(gr-1);
-      if (n == 0) { continue; }
-      sedge_ord_map.SetSize(n);
-      for (int j = 0; j < n; j++)
-      {
-         sedge_ord_map[j].one = sedge_ord[k+j];
-         sedge_ord_map[j].two = j;
-      }
-      SortPairs<int, int>(sedge_ord_map, n);
-      for (int j = 0; j < n; j++)
-      {
-         const int sedge_from = group_sedge.GetJ()[k+j];
-         const int *v = shared_edges[sedge_from]->GetVertices();
-         sedge_ord[k+j] = order[v_to_v(v[0], v[1])];
-      }
-      std::sort(&sedge_ord[k], &sedge_ord[k] + n);
-      for (int j = 0; j < n; j++)
-      {
-         const int sedge_to = group_sedge.GetJ()[k+sedge_ord_map[j].two];
-         const int *v = shared_edges[sedge_to]->GetVertices();
-         order[v_to_v(v[0], v[1])] = sedge_ord[k+j];
-      }
-      k += n;
+      glob_edge_order[i] = (std::int64_t(MyRank) << 32) + i;
    }
-
-#ifdef MFEM_DEBUG
+   for (int i = 0; i < shared_edges.Size(); i++)
    {
-      Array<Pair<int, double> > ilen_len(order.Size());
-
-      for (int i = 0; i < NumOfVertices; i++)
-      {
-         for (DSTable::RowIterator it(v_to_v, i); !it; ++it)
-         {
-            int j = it.Index();
-            ilen_len[j].one = order[j];
-            ilen_len[j].two = GetLength(i, it.Column());
-         }
-      }
-
-      SortPairs<int, double>(ilen_len, order.Size());
-
-      double d_max = 0.;
-      for (int i = 1; i < order.Size(); i++)
-      {
-         d_max = std::max(d_max, ilen_len[i-1].two-ilen_len[i].two);
-      }
-
-#if 0
-      // Debug message from every MPI rank.
-      mfem::out << "proc. " << MyRank << '/' << NRanks << ": d_max = " << d_max
-                << endl;
-#else
-      // Debug message just from rank 0.
-      double glob_d_max;
-      MPI_Reduce(&d_max, &glob_d_max, 1, MPI_DOUBLE, MPI_MAX, 0, MyComm);
-      if (MyRank == 0)
-      {
-         mfem::out << "glob_d_max = " << glob_d_max << endl;
-      }
-#endif
+      const int sedge = group_sedge.GetJ()[i];
+      const int *v = shared_edges[sedge]->GetVertices();
+      glob_edge_order[v_to_v(v[0], v[1])] =
+         (std::int64_t(sedge_master_rank[i]) << 32) + sedge_master_index[i];
    }
-#endif
 
-   // use 'order' to mark the tets, the boundary triangles, and the shared
+   // use the lengths to mark the tets, the boundary triangles, and the shared
    // triangle faces
    for (int i = 0; i < NumOfElements; i++)
    {
       if (elements[i]->GetType() == Element::TETRAHEDRON)
       {
-         elements[i]->MarkEdge(v_to_v, order);
+         dynamic_cast<Tetrahedron &>(*elements[i]).MarkEdge(v_to_v, lengths,
+                                                            glob_edge_order);
       }
    }
 
@@ -1830,13 +1790,14 @@ void ParMesh::MarkTetMeshForRefinement(DSTable &v_to_v)
    {
       if (boundary[i]->GetType() == Element::TRIANGLE)
       {
-         boundary[i]->MarkEdge(v_to_v, order);
+         dynamic_cast<Triangle &>(*boundary[i]).MarkEdge(v_to_v, lengths,
+                                                         glob_edge_order);
       }
    }
 
    for (int i = 0; i < shared_trias.Size(); i++)
    {
-      Triangle::MarkEdge(shared_trias[i].v, v_to_v, order);
+      Triangle::MarkEdge(shared_trias[i].v, v_to_v, lengths, glob_edge_order);
    }
 }
 
@@ -2099,16 +2060,13 @@ void ParMesh::EnsureParNodes()
       ParFiniteElementSpace *pfes =
          new ParFiniteElementSpace(*Nodes->FESpace(), *this);
       ParGridFunction *new_nodes = new ParGridFunction(pfes);
-
       *new_nodes = *Nodes;
-
       if (Nodes->OwnFEC())
       {
          new_nodes->MakeOwner(Nodes->OwnFEC());
          Nodes->MakeOwner(NULL); // takes away ownership of 'fec' and 'fes'
          delete Nodes->FESpace();
       }
-
       delete Nodes;
       Nodes = new_nodes;
    }
@@ -3285,23 +3243,21 @@ void ParMesh::ReorientTetMesh()
 
    // create a GroupCommunicator over shared vertices
    GroupCommunicator svert_comm(gtopo);
-   GetSharedVertexCommunicator(svert_comm);
+   GetSharedVertexCommunicator(0, svert_comm);
 
    // communicate the local index of each shared vertex from the group master to
    // other ranks in the group
    Array<int> svert_master_rank(svert_lvert.Size());
    Array<int> svert_master_index(svert_lvert);
+   for (int i = 0; i < group_svert.Size(); i++)
    {
-      for (int i = 0; i < group_svert.Size(); i++)
+      int rank = gtopo.GetGroupMasterRank(i+1);
+      for (int j = 0; j < group_svert.RowSize(i); j++)
       {
-         int rank = gtopo.GetGroupMasterRank(i+1);
-         for (int j = 0; j < group_svert.RowSize(i); j++)
-         {
-            svert_master_rank[group_svert.GetRow(i)[j]] = rank;
-         }
+         svert_master_rank[group_svert.GetRow(i)[j]] = rank;
       }
-      svert_comm.Bcast(svert_master_index);
    }
+   svert_comm.Bcast(svert_master_index);
 
    // the pairs (master rank, master local index) define a globally consistent
    // vertex ordering
@@ -3367,22 +3323,8 @@ void ParMesh::ReorientTetMesh()
    {
       // create a GroupCommunicator on the shared triangles
       GroupCommunicator stria_comm(gtopo);
-      {
-         // initialize stria_comm
-         Table &gr_stria = stria_comm.GroupLDofTable();
-         // gr_stria differs from group_stria - the latter does not store gr. 0
-         gr_stria.SetDims(GetNGroups(), shared_trias.Size());
-         gr_stria.GetI()[0] = 0;
-         for (int gr = 1; gr <= GetNGroups(); gr++)
-         {
-            gr_stria.GetI()[gr] = group_stria.GetI()[gr-1];
-         }
-         for (int k = 0; k < shared_trias.Size(); k++)
-         {
-            gr_stria.GetJ()[k] = group_stria.GetJ()[k];
-         }
-         stria_comm.Finalize();
-      }
+      GetSharedTriCommunicator(0, stria_comm);
+
       Array<int> stria_flag(shared_trias.Size());
       for (int i = 0; i < stria_flag.Size(); i++)
       {
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index 2395bc538..5e286d5b9 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -24,6 +24,7 @@
 
 namespace mfem
 {
+
 #ifdef MFEM_USE_PUMI
 class ParPumiMesh;
 #endif
@@ -31,9 +32,16 @@ class ParPumiMesh;
 /// Class for parallel meshes
 class ParMesh : public Mesh
 {
-protected:
+   friend class ParNCMesh;
    friend class ParSubMesh;
+#ifdef MFEM_USE_PUMI
+   friend class ParPumiMesh;
+#endif
+#ifdef MFEM_USE_ADIOS2
+   friend class adios2stream;
+#endif
 
+protected:
    MPI_Comm MyComm;
    int NRanks, MyRank;
 
@@ -102,7 +110,7 @@ protected:
 
    // Mark all tets to ensure consistency across MPI tasks; also mark the
    // shared and boundary triangle faces using the consistently marked tets.
-   void MarkTetMeshForRefinement(DSTable &v_to_v) override;
+   void MarkTetMeshForRefinement(const DSTable &v_to_v) override;
 
    /// Return a number(0-1) identifying how the given edge has been split
    int GetEdgeSplittings(Element *edge, const DSTable &v_to_v, int *middle);
@@ -309,7 +317,8 @@ public:
 
    /// Read a parallel mesh, each MPI rank from its own file/stream.
    /** The @a refine parameter is passed to the method Mesh::Finalize(). */
-   ParMesh(MPI_Comm comm, std::istream &input, bool refine = true);
+   ParMesh(MPI_Comm comm, std::istream &input, int generate_edges = 0,
+           int refine = 1, bool fix_orientation = true);
 
    /// Deprecated: see @a ParMesh::MakeRefined
    MFEM_DEPRECATED
@@ -666,14 +675,6 @@ public:
    void PrintSharedEntities(const std::string &fname_prefix) const;
 
    virtual ~ParMesh();
-
-   friend class ParNCMesh;
-#ifdef MFEM_USE_PUMI
-   friend class ParPumiMesh;
-#endif
-#ifdef MFEM_USE_ADIOS2
-   friend class adios2stream;
-#endif
 };
 
 }
diff --git a/mesh/point.cpp b/mesh/point.cpp
index ecf6a4dd0..93df9f9f4 100644
--- a/mesh/point.cpp
+++ b/mesh/point.cpp
@@ -9,24 +9,21 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
-#include "mesh_headers.hpp"
+#include "point.hpp"
 
 namespace mfem
 {
 
-Point::Point( const int *ind, int attr ) : Element(Geometry::POINT)
+Point::Point(const int *ind, int attr) : Element(Geometry::POINT)
 {
    attribute = attr;
    indices[0] = ind[0];
 }
 
-void Point::GetVertices( Array<int> &v ) const
+void Point::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 1 );
+   v.SetSize(1);
    v[0] = indices[0];
 }
 
-PointFiniteElement PointFE;
-
 }
diff --git a/mesh/point.hpp b/mesh/point.hpp
index f154e205e..db14bfb77 100644
--- a/mesh/point.hpp
+++ b/mesh/point.hpp
@@ -30,26 +30,22 @@ public:
    Point() : Element(Geometry::POINT) {}
 
    /// Constructs point by specifying the indices and the attribute.
-   Point( const int *ind, int attr = -1 );
+   Point(const int *ind, int attr = 1);
 
    /// Return element's type.
    virtual Type GetType() const { return Element::POINT; }
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices( Array<int> &v ) const;
+   /// Returns the indices of the element's vertices.
+   virtual void GetVertices(Array<int> &v) const;
 
-   virtual int * GetVertices () { return indices; }
+   virtual int *GetVertices() { return indices; }
 
    virtual int GetNVertices() const { return 1; }
 
-   virtual int GetNEdges() const { return (0); }
+   virtual int GetNEdges() const { return 0; }
 
    virtual const int *GetEdgeVertices(int ei) const { return NULL; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
-   { nFaceVertices = 0; return 0; }
-
    virtual int GetNFaces() const { return 0; }
 
    virtual int GetNFaceVertices(int) const { return 0; }
@@ -62,8 +58,7 @@ public:
    virtual ~Point() { }
 };
 
-class PointFiniteElement;
-extern MFEM_EXPORT PointFiniteElement PointFE;
+extern MFEM_EXPORT class PointFiniteElement PointFE;
 
 }
 
diff --git a/mesh/pyramid.cpp b/mesh/pyramid.cpp
index d67841564..038a3c378 100644
--- a/mesh/pyramid.cpp
+++ b/mesh/pyramid.cpp
@@ -9,9 +9,7 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-// Implementation of class Pyramid
-
-#include "mesh_headers.hpp"
+#include "pyramid.hpp"
 
 namespace mfem
 {
@@ -54,11 +52,4 @@ void Pyramid::GetVertices(Array<int> &v) const
    }
 }
 
-int Pyramid::GetNFaces(int &nFaceVertices) const
-{
-   MFEM_ABORT("this method is not valid for Pyramid elements");
-   nFaceVertices = 4;
-   return 5;
-}
-
 }
diff --git a/mesh/pyramid.hpp b/mesh/pyramid.hpp
index 8e171a31d..1a8af4ed3 100644
--- a/mesh/pyramid.hpp
+++ b/mesh/pyramid.hpp
@@ -18,7 +18,7 @@
 namespace mfem
 {
 
-/// Data type Pyramid element
+/// Data type pyramid element
 class Pyramid : public Element
 {
 protected:
@@ -54,13 +54,10 @@ public:
    virtual const int *GetEdgeVertices(int ei) const
    { return geom_t::Edges[ei]; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
-
    virtual int GetNFaces() const { return 5; }
 
    virtual int GetNFaceVertices(int fi) const
-   { return ( ( fi < 1 ) ? 4 : 3); }
+   { return (fi < 1) ? 4 : 3; }
 
    virtual const int *GetFaceVertices(int fi) const
    { return geom_t::FaceVert[fi]; }
@@ -71,7 +68,7 @@ public:
    virtual ~Pyramid() { }
 };
 
-extern class LinearPyramidFiniteElement PyramidFE;
+extern MFEM_EXPORT class LinearPyramidFiniteElement PyramidFE;
 
 }
 
diff --git a/mesh/quadrilateral.cpp b/mesh/quadrilateral.cpp
index 1a69cf179..57f14800f 100644
--- a/mesh/quadrilateral.cpp
+++ b/mesh/quadrilateral.cpp
@@ -9,24 +9,23 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
-#include "mesh_headers.hpp"
+#include "quadrilateral.hpp"
 
 namespace mfem
 {
 
-Quadrilateral::Quadrilateral( const int *ind, int attr )
+Quadrilateral::Quadrilateral(const int *ind, int attr)
    : Element(Geometry::SQUARE)
 {
    attribute = attr;
-   for (int i=0; i<4; i++)
+   for (int i = 0; i < 4; i++)
    {
       indices[i] = ind[i];
    }
 }
 
-Quadrilateral::Quadrilateral( int ind1, int ind2, int ind3, int ind4,
-                              int attr ) : Element(Geometry::SQUARE)
+Quadrilateral::Quadrilateral(int ind1, int ind2, int ind3, int ind4, int attr)
+   : Element(Geometry::SQUARE)
 {
    attribute  = attr;
    indices[0] = ind1;
@@ -37,21 +36,19 @@ Quadrilateral::Quadrilateral( int ind1, int ind2, int ind3, int ind4,
 
 void Quadrilateral::SetVertices(const int *ind)
 {
-   for (int i=0; i<4; i++)
+   for (int i = 0; i < 4; i++)
    {
       indices[i] = ind[i];
    }
 }
 
-void Quadrilateral::GetVertices( Array<int> &v ) const
+void Quadrilateral::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 4 );
-   for (int i=0; i<4; i++)
+   v.SetSize(4);
+   for (int i = 0; i < 4; i++)
    {
       v[i] = indices[i];
    }
 }
 
-BiLinear2DFiniteElement QuadrilateralFE;
-
 }
diff --git a/mesh/quadrilateral.hpp b/mesh/quadrilateral.hpp
index 9f6b9a442..4ad31c33d 100644
--- a/mesh/quadrilateral.hpp
+++ b/mesh/quadrilateral.hpp
@@ -48,15 +48,11 @@ public:
 
    virtual int GetNVertices() const { return 4; }
 
-   virtual int GetNEdges() const { return (4); }
+   virtual int GetNEdges() const { return 4; }
 
    virtual const int *GetEdgeVertices(int ei) const
    { return geom_t::Edges[ei]; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
-   { nFaceVertices = 0; return 0; }
-
    virtual int GetNFaces() const { return 0; }
 
    virtual int GetNFaceVertices(int) const { return 0; }
diff --git a/mesh/segment.cpp b/mesh/segment.cpp
index 717245907..82bdbdf3b 100644
--- a/mesh/segment.cpp
+++ b/mesh/segment.cpp
@@ -9,22 +9,21 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
-#include "mesh_headers.hpp"
+#include "segment.hpp"
 
 namespace mfem
 {
 
-Segment::Segment( const int *ind, int attr ) : Element(Geometry::SEGMENT)
+Segment::Segment(const int *ind, int attr) : Element(Geometry::SEGMENT)
 {
    attribute = attr;
-   for (int i=0; i<2; i++)
+   for (int i = 0; i < 2; i++)
    {
       indices[i] = ind[i];
    }
 }
 
-Segment::Segment( int ind1, int ind2, int attr ) : Element(Geometry::SEGMENT)
+Segment::Segment(int ind1, int ind2, int attr) : Element(Geometry::SEGMENT)
 {
    attribute  = attr;
    indices[0] = ind1;
@@ -37,15 +36,13 @@ void Segment::SetVertices(const int *ind)
    indices[1] = ind[1];
 }
 
-void Segment::GetVertices( Array<int> &v ) const
+void Segment::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 2 );
-   for (int i=0; i<2; i++)
+   v.SetSize(2);
+   for (int i = 0; i < 2; i++)
    {
       v[i] = indices[i];
    }
 }
 
-Linear1DFiniteElement SegmentFE;
-
 }
diff --git a/mesh/segment.hpp b/mesh/segment.hpp
index 6ca918758..3cefa7edc 100644
--- a/mesh/segment.hpp
+++ b/mesh/segment.hpp
@@ -48,14 +48,10 @@ public:
 
    virtual int GetNVertices() const { return 2; }
 
-   virtual int GetNEdges() const { return (0); }
+   virtual int GetNEdges() const { return 0; }
 
    virtual const int *GetEdgeVertices(int ei) const { return NULL; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
-   { nFaceVertices = 0; return 0; }
-
    virtual int GetNFaces() const { return 0; }
 
    virtual int GetNFaceVertices(int) const { return 0; }
@@ -68,8 +64,7 @@ public:
    virtual ~Segment() { }
 };
 
-class Linear1DFiniteElement;
-extern MFEM_EXPORT Linear1DFiniteElement SegmentFE;
+extern MFEM_EXPORT class Linear1DFiniteElement SegmentFE;
 
 }
 
diff --git a/mesh/tetrahedron.cpp b/mesh/tetrahedron.cpp
index c7ebc064b..27e634545 100644
--- a/mesh/tetrahedron.cpp
+++ b/mesh/tetrahedron.cpp
@@ -9,9 +9,12 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-// Implementation of class Tetrahedron
+#include "tetrahedron.hpp"
 
-#include "mesh_headers.hpp"
+#include "../mesh/mesh.hpp"
+#include "../linalg/densemat.hpp"
+
+#include <cstdint>
 
 namespace mfem
 {
@@ -184,19 +187,30 @@ void Tetrahedron::SetVertices(const int *ind)
    }
 }
 
-void Tetrahedron::MarkEdge(const DSTable &v_to_v, const int *length)
+template <typename T1, typename T2>
+void Tetrahedron::MarkEdge(const DSTable &v_to_v, const Array<T1> &length,
+                           const Array<T2> &length2)
 {
-   int ind[4], i, j, l, L, type;
-
-   // determine the longest edge
-   L = length[v_to_v(indices[0], indices[1])]; j = 0;
-   if ((l = length[v_to_v(indices[1], indices[2])]) > L) { L = l; j = 1; }
-   if ((l = length[v_to_v(indices[2], indices[0])]) > L) { L = l; j = 2; }
-   if ((l = length[v_to_v(indices[0], indices[3])]) > L) { L = l; j = 3; }
-   if ((l = length[v_to_v(indices[1], indices[3])]) > L) { L = l; j = 4; }
-   if ((l = length[v_to_v(indices[2], indices[3])]) > L) { j = 5; }
+   int e, j, ind[4], type;
+   T1 l, L;
+   T2 l2, L2;
+   auto Compare = [&length, &length2, &l, &l2, &L, &L2](int e)
+   {
+      constexpr T1 rtol = 1.0e-6;
+      l = length[e];
+      l2 = length2[e];
+      MFEM_ASSERT(l2 != L2, "Tie-breaking lengths should be unique for MarkEdge");
+      return (l > L * (1.0 + rtol) || (l > L * (1.0 - rtol) && l2 > L2));
+   };
+
+   e = v_to_v(indices[0], indices[1]); L = length[e]; L2 = length2[e]; j = 0;
+   if (Compare(v_to_v(indices[1], indices[2]))) { L = l; L2 = l2; j = 1; }
+   if (Compare(v_to_v(indices[2], indices[0]))) { L = l; L2 = l2; j = 2; }
+   if (Compare(v_to_v(indices[0], indices[3]))) { L = l; L2 = l2; j = 3; }
+   if (Compare(v_to_v(indices[1], indices[3]))) { L = l; L2 = l2; j = 4; }
+   if (Compare(v_to_v(indices[2], indices[3]))) { j = 5; }
 
-   for (i = 0; i < 4; i++)
+   for (int i = 0; i < 4; i++)
    {
       ind[i] = indices[i];
    }
@@ -228,13 +242,14 @@ void Tetrahedron::MarkEdge(const DSTable &v_to_v, const int *length)
    // Determine the two longest edges for the other two faces and
    // store them in ind[0] and ind[1]
    ind[0] = 2; ind[1] = 1;
-   L = length[v_to_v(indices[0], indices[2])];
-   if ((l = length[v_to_v(indices[0], indices[3])]) > L) { L = l; ind[0] = 3; }
-   if ((l = length[v_to_v(indices[2], indices[3])]) > L) { ind[0] = 5; }
 
-   L = length[v_to_v(indices[1], indices[2])];
-   if ((l = length[v_to_v(indices[1], indices[3])]) > L) { L = l; ind[1] = 4; }
-   if ((l = length[v_to_v(indices[2], indices[3])]) > L) { ind[1] = 5; }
+   e = v_to_v(indices[0], indices[2]); L = length[e]; L2 = length2[e];
+   if (Compare(v_to_v(indices[0], indices[3]))) { L = l; L2 = l2; ind[0] = 3; }
+   if (Compare(v_to_v(indices[2], indices[3]))) { L = l; L2 = l2; ind[0] = 5; }
+
+   e = v_to_v(indices[1], indices[2]); L = length[e]; L2 = length2[e];
+   if (Compare(v_to_v(indices[1], indices[3]))) { L = l; L2 = l2; ind[1] = 4; }
+   if (Compare(v_to_v(indices[2], indices[3]))) { L = l; L2 = l2; ind[1] = 5; }
 
    j = 0;
    switch (ind[0])
@@ -345,4 +360,13 @@ Element *Tetrahedron::Duplicate(Mesh *m) const
    return tet;
 }
 
+// @cond DOXYGEN_SKIP
+
+template void Tetrahedron::MarkEdge(const DSTable &, const Array<double> &,
+                                    const Array<int> &);
+template void Tetrahedron::MarkEdge(const DSTable &, const Array<double> &,
+                                    const Array<std::int64_t> &);
+
+// @endcond
+
 }
diff --git a/mesh/tetrahedron.hpp b/mesh/tetrahedron.hpp
index c434ae903..ffc14be00 100644
--- a/mesh/tetrahedron.hpp
+++ b/mesh/tetrahedron.hpp
@@ -76,7 +76,9 @@ public:
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
        because the order may be used later for setting the edges. **/
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length);
+   template <typename T1, typename T2>
+   void MarkEdge(const DSTable &v_to_v, const Array<T1> &length,
+                 const Array<T2> &length2);
 
    virtual void ResetTransform(int tr) { transform = tr; }
    virtual unsigned GetTransform() const { return transform; }
@@ -95,15 +97,11 @@ public:
 
    virtual int GetNVertices() const { return 4; }
 
-   virtual int GetNEdges() const { return (6); }
+   virtual int GetNEdges() const { return 6; }
 
    virtual const int *GetEdgeVertices(int ei) const
    { return geom_t::Edges[ei]; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
-   { nFaceVertices = 3; return 4; }
-
    virtual int GetNFaces() const { return 4; }
 
    virtual int GetNFaceVertices(int) const { return 3; }
@@ -116,7 +114,6 @@ public:
    virtual ~Tetrahedron() { }
 };
 
-// Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
 extern MFEM_EXPORT class Linear3DFiniteElement TetrahedronFE;
 
 }
diff --git a/mesh/triangle.cpp b/mesh/triangle.cpp
index 5ce32cb31..6eb8c7e59 100644
--- a/mesh/triangle.cpp
+++ b/mesh/triangle.cpp
@@ -9,7 +9,11 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "mesh_headers.hpp"
+#include "triangle.hpp"
+
+#include "../linalg/densemat.hpp"
+
+#include <cstdint>
 
 namespace mfem
 {
@@ -50,63 +54,28 @@ void Triangle::SetVertices(const int *ind)
    }
 }
 
-void Triangle::MarkEdge(DenseMatrix &pmat)
+// static method
+template <typename T1, typename T2>
+void Triangle::MarkEdge(int indices[3], const DSTable &v_to_v,
+                        const Array<T1> &length, const Array<T2> &length2)
 {
-   double d[3];
-   int shift, v;
-
-   d[0] = ( (pmat(0,1)-pmat(0,0))*(pmat(0,1)-pmat(0,0)) +
-            (pmat(1,1)-pmat(1,0))*(pmat(1,1)-pmat(1,0)) );
-   d[1] = ( (pmat(0,2)-pmat(0,1))*(pmat(0,2)-pmat(0,1)) +
-            (pmat(1,2)-pmat(1,1))*(pmat(1,2)-pmat(1,1)) );
-   d[2] = ( (pmat(0,2)-pmat(0,0))*(pmat(0,2)-pmat(0,0)) +
-            (pmat(1,2)-pmat(1,0))*(pmat(1,2)-pmat(1,0)) );
-
-   // if pmat has 3 rows, then use extra term in each sum
-   if (pmat.Height()==3)
+   int e, j, ind[3];
+   T1 l, L;
+   T2 l2, L2;
+   auto Compare = [&length, &length2, &l, &l2, &L, &L2](int e)
    {
-      d[0] += (pmat(2,1)-pmat(2,0))*(pmat(2,1)-pmat(2,0));
-      d[1] += (pmat(2,2)-pmat(2,1))*(pmat(2,2)-pmat(2,1));
-      d[2] += (pmat(2,2)-pmat(2,0))*(pmat(2,2)-pmat(2,0));
-   }
+      constexpr T1 rtol = 1.0e-6;
+      l = length[e];
+      l2 = length2[e];
+      MFEM_ASSERT(l2 != L2, "Tie-breaking lengths should be unique for MarkEdge");
+      return (l > L * (1.0 + rtol) || (l > L * (1.0 - rtol) && l2 > L2));
+   };
 
-   if (d[0] >= d[1])
-   {
-      if (d[0] >= d[2]) { shift = 0; }
-      else { shift = 2; }
-   }
-   else if (d[1] >= d[2]) { shift = 1; }
-   else { shift = 2; }
+   e = v_to_v(indices[0], indices[1]); L = length[e]; L2 = length2[e]; j = 0;
+   if (Compare(v_to_v(indices[1], indices[2]))) { L = l; L2 = l2; j = 1; }
+   if (Compare(v_to_v(indices[2], indices[0]))) { j = 2; }
 
-   switch (shift)
-   {
-      case 0:
-         break;
-      case 1:
-         v = indices[0];
-         indices[0] = indices[1];
-         indices[1] = indices[2];
-         indices[2] = v;
-         break;
-      case 2:
-         v = indices[0];
-         indices[0] = indices[2];
-         indices[2] = indices[1];
-         indices[1] = v;
-         break;
-   }
-}
-
-// Static method
-void Triangle::MarkEdge(int *indices, const DSTable &v_to_v, const int *length)
-{
-   int l, L, j, ind[3], i;
-
-   L = length[ v_to_v(indices[0], indices[1]) ]; j = 0;
-   if ( (l = length[ v_to_v(indices[1], indices[2]) ]) > L ) { L = l; j = 1; }
-   if ( (l = length[ v_to_v(indices[2], indices[0]) ]) > L ) { j = 2; }
-
-   for (i = 0; i < 3; i++)
+   for (int i = 0; i < 3; i++)
    {
       ind[i] = indices[i];
    }
@@ -194,4 +163,13 @@ void Triangle::GetVertices(Array<int> &v) const
    }
 }
 
-} // namespace mfem
+// @cond DOXYGEN_SKIP
+
+template void Triangle::MarkEdge(int *, const DSTable &, const Array<double> &,
+                                 const Array<int> &);
+template void Triangle::MarkEdge(int *, const DSTable &, const Array<double> &,
+                                 const Array<std::int64_t> &);
+
+// @endcond
+
+}
diff --git a/mesh/triangle.hpp b/mesh/triangle.hpp
index 363bd4503..919b491f9 100644
--- a/mesh/triangle.hpp
+++ b/mesh/triangle.hpp
@@ -13,7 +13,6 @@
 #define MFEM_TRIANGLE
 
 #include "../config/config.hpp"
-#include "../fem/fe.hpp"
 #include "element.hpp"
 
 namespace mfem
@@ -50,13 +49,14 @@ public:
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
        because the order may be used later for setting the edges. **/
-   void MarkEdge(DenseMatrix & pmat);
+   template <typename T1, typename T2>
+   void MarkEdge(const DSTable &v_to_v, const Array<T1> &length,
+                 const Array<T2> &length2)
+   { MarkEdge(indices, v_to_v, length, length2); }
 
-   static void MarkEdge(int *indices, const DSTable &v_to_v, const int *length);
-
-   /// Mark the longest edge by assuming/changing the order of the vertices.
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length)
-   { MarkEdge(indices, v_to_v, length); }
+   template <typename T1, typename T2>
+   static void MarkEdge(int *indices, const DSTable &v_to_v,
+                        const Array<T1> &length, const Array<T2> &length2);
 
    virtual void ResetTransform(int tr) { transform = tr; }
    virtual unsigned GetTransform() const { return transform; }
@@ -75,21 +75,16 @@ public:
 
    virtual int GetNVertices() const { return 3; }
 
-   virtual int GetNEdges() const { return (3); }
+   virtual int GetNEdges() const { return 3; }
 
    virtual const int *GetEdgeVertices(int ei) const
    { return geom_t::Edges[ei]; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
-   { nFaceVertices = 0; return 0; }
-
    virtual int GetNFaces() const { return 0; }
 
    virtual int GetNFaceVertices(int) const { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const
-   { MFEM_ABORT("not implemented"); return NULL; }
+   virtual const int *GetFaceVertices(int fi) const { return NULL; }
 
    virtual Element *Duplicate(Mesh *m) const
    { return new Triangle(indices, attribute); }
@@ -97,8 +92,7 @@ public:
    virtual ~Triangle() { }
 };
 
-// Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
-extern MFEM_EXPORT Linear2DFiniteElement TriangleFE;
+extern MFEM_EXPORT class Linear2DFiniteElement TriangleFE;
 
 }
 
diff --git a/mesh/vertex.cpp b/mesh/vertex.cpp
index e5c1a5739..8be65774a 100644
--- a/mesh/vertex.cpp
+++ b/mesh/vertex.cpp
@@ -9,13 +9,12 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
 #include "vertex.hpp"
 
 namespace mfem
 {
 
-Vertex::Vertex (double *xx, int dim)
+Vertex::Vertex(const double *xx, int dim)
 {
    for (int i = 0; i < dim; i++)
    {
diff --git a/mesh/vertex.hpp b/mesh/vertex.hpp
index 3267b904f..117beaa36 100644
--- a/mesh/vertex.hpp
+++ b/mesh/vertex.hpp
@@ -13,7 +13,6 @@
 #define MFEM_VERTEX
 
 #include "../config/config.hpp"
-#include "../general/globals.hpp"
 
 namespace mfem
 {
@@ -29,24 +28,19 @@ public:
 
    // Trivial copy constructor and trivial copy assignment operator
 
-   Vertex (double *xx, int dim);
-   Vertex( double x, double y) { coord[0] = x; coord[1] = y; coord[2] = 0.; }
-   Vertex( double x, double y, double z)
+   Vertex(const double *xx, int dim);
+   Vertex(double x, double y) { coord[0] = x; coord[1] = y; coord[2] = 0.; }
+   Vertex(double x, double y, double z)
    { coord[0] = x; coord[1] = y; coord[2] = z; }
 
    /// Returns pointer to the coordinates of the vertex.
-   inline double * operator() () const { return (double*)coord; }
+   inline double *operator()() const { return (double *)coord; }
 
    /// Returns the i'th coordinate of the vertex.
-   inline double & operator() (int i) { return coord[i]; }
+   inline double &operator()(int i) { return coord[i]; }
 
    /// Returns the i'th coordinate of the vertex.
-   inline const double & operator() (int i) const { return coord[i]; }
-
-   /// (DEPRECATED) Set the coordinates of the Vertex.
-   /** @deprecated This old version of SetCoords is not always memory safe. */
-   MFEM_DEPRECATED void SetCoords(const double *p)
-   { coord[0] = p[0]; coord[1] = p[1]; coord[2] = p[2]; }
+   inline const double &operator()(int i) const { return coord[i]; }
 
    /// Sets vertex location based on given point p
    void SetCoords(int dim, const double *p)
diff --git a/mesh/wedge.cpp b/mesh/wedge.cpp
index 898da7653..0f7335aa6 100644
--- a/mesh/wedge.cpp
+++ b/mesh/wedge.cpp
@@ -9,9 +9,7 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-// Implementation of class Wedge
-
-#include "mesh_headers.hpp"
+#include "wedge.hpp"
 
 namespace mfem
 {
@@ -56,11 +54,4 @@ void Wedge::GetVertices(Array<int> &v) const
    }
 }
 
-int Wedge::GetNFaces(int &nFaceVertices) const
-{
-   MFEM_ABORT("this method is not valid for Wedge elements");
-   nFaceVertices = 4;
-   return 5;
-}
-
 }
diff --git a/mesh/wedge.hpp b/mesh/wedge.hpp
index fb8583f8e..764a681a4 100644
--- a/mesh/wedge.hpp
+++ b/mesh/wedge.hpp
@@ -18,7 +18,7 @@
 namespace mfem
 {
 
-/// Data type Wedge element
+/// Data type wedge element
 class Wedge : public Element
 {
 protected:
@@ -54,9 +54,6 @@ public:
    virtual const int *GetEdgeVertices(int ei) const
    { return geom_t::Edges[ei]; }
 
-   /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
-
    virtual int GetNFaces() const { return 5; }
 
    virtual int GetNFaceVertices(int fi) const
